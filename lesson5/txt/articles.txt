article  1
title: ASP.NET Core 快速入门（环境篇）
body: 
【申明】：本人.NET Core小白、Linux小白、MySql小白、nginx小白。而今天要说是让你精通Linux ... 的开机与关机、nginx安装与部署、Core的Hello World ...等。
首先，入门文章园子里面已经很多了。这里再做个整理和备忘。您也可以根据目录挑着看。（亲测多次可行，以下多图预警！）
vmware虚拟机安装
vmware哪里下载？360软件管家就可以下载。然后网上找个序列号。
我这里安装的是12.1.1

安装很简单一直下一步就好了。
CentOS7.3安装
下载CentOS http://isoredirect.centos.org/centos/7/isos/x86_64/ 我们可以选择163或阿里云的节点，速度会快点。

下载完成后打开vmware准备安装







菜鸟可以选择有界面的


选好后然后开始安装，然后设置密码，然后重启就好了。

Windows的客户端软件
下载安装Xshell https://www.baidu.com/baidu?word=Xshell
下载安装WinSCP https://www.baidu.com/baidu?word=WinSCP (你也可以使用Xftp，记得选sftp，不然需要服务器支持ftp)
进入CentOS，右键

开始第一个命令。查看IP
ifconfig -a

接下来，可以全部由Xshell操作。
打开Xshell

然后输入用户名密码登录。（使用root登录）

.NET Core1.1安装
根据微软资料 https://www.microsoft.com/net/core#linuxcentos
在命令行执行：
sudo yum install libunwind libicu  #（安装libicu依赖）
curl -sSL -o dotnet.tar.gz https://go.microsoft.com/fwlink/?linkid=848821 #（下载sdk压缩包） 根据网速，可能快可能慢
sudo mkdir -p /opt/dotnet && sudo tar zxf dotnet.tar.gz -C /opt/dotnet #（解压缩）
sudo ln -s /opt/dotnet/dotnet /usr/local/bin #（创建链接）
dotnet new console -o hwapp   # 我们初始化一个示例Hello World应用程序 （这里稍微耗时点）
cd hwapp
dotnet restore
dotnet run   #运行应用程序 

看到打印的hello world证明 .net core的环境已经装好了。
【小白技巧】

"#"是注释
shirf + insert 粘贴 （不能ctrl + c v 有点不习惯）
ctrl + insert 复制

nginx1.12.1安装
curl -o  nginx.rpm http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
rpm -ivh nginx.rpm
yum install nginx #安装

systemctl start nginx #启动nginx
systemctl enable nginx #设置nginx的开机启动
然后登录 CentOs系统 打开浏览器 输入 ：192.168.233.129 （之前查到的IP）

看到这个页面就代表安装成功了。
配置防火墙
如果你在物理机的浏览器访问，你会发现访问不了。
那是因为CentOs的防火墙拦截了，我们打开端口。
firewall-cmd --zone=public --add-port=80/tcp --permanent #（开放80端口）
systemctl restart firewalld #（重启防火墙以使配置即时生效）
然后访问成功。
部署ASP.NET Core应用程序
打开VS2017 新建一个.net core 项目

右键发布（发布之前最好先在本地跑下看正常不）

然后打开我们的WinSCP（前面下载的）

点击登录，然后就可以看到CentOs系统的文件目录了。然后随便建个文件夹，准备放我们发布发好的程序。

右键上传

然后命令运行
cd /home/NetCoreDemo #这个目录 要输入你自己对应放的目录
dotnet netcoreDemo.dll # netcoreDemo.dll 这个对应你建的项目生成的dll

看到了5000 端口的一个网址，证明部署好了。
然后在虚拟机里面访问 http://localhost:5000 ，ok。

nginx 配置
前面我们只说了nginx，并没有说是干嘛的。nginx的作用有点先iis，是个web服务器。做转发。
我们发现http://localhost:5000 可以访问。但是通过ip却不能访问。那么我们现在就可以通过80访问nginx，然后nginx再帮我们访问5000。

打开路径 /etc/nginx/conf.d
编辑default.conf 文件内容替换为
server {
    listen 80;
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
将nginx添加至SELinux的白名单，否则会报502错误。
nginx -s reload #使其即时生效
【注意】然后这里访问下 http://192.168.233.130/ （对应你自己的centos ip，这一步好重要。应该是要先主动触发这个502错误吧。）
yum install policycoreutils-python  #（选y）
cat /var/log/audit/audit.log | grep nginx | grep denied | audit2allow -M mynginx
semodule -i mynginx.pp
然后我们就可以在物理机上通过ip访问了（不用带端口了，直接80 然后 nginx 转到了5000）。
配置守护服务（Supervisor）
yum install python-setuptools
easy_install supervisor  #安装Supervisor
mkdir /etc/supervisor
echo_supervisord_conf > /etc/supervisor/supervisord.conf  #配置Supervisor

文件的最后
;[include]
;files = relative/directory/*.ini
改成（【注意】去掉;且不能有空格）
[include]
files = conf.d/*.conf
进入目录 /etc/supervisor/ 新建 conf.d文件夹，conf.d文件夹下新建 netcoreDemo.conf文件
内容（【注意】看 第二行 第三行的 注释，根据实际名字填入）
[program:netcoreDemo]
command=dotnet netcoreDemo.dll ; （注意）运行程序的命令
directory= /home/NetCoreDemo/ ; （注意 注意）对应的你的项目的存放目录，这个地方好多初学者搞错！！！
autorestart=true ; 程序意外退出是否自动重启
stderr_logfile=/var/log/WebApplication1.err.log ; 错误日志文件
stdout_logfile=/var/log/WebApplication1.out.log ; 输出日志文件
environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量
user=root ; 进程执行的用户身份
stopsignal=INT
supervisord -c /etc/supervisor/supervisord.conf
ps -ef | grep netcoreDemo  #【注意】netcoreDemo是上面 program:netcoreDemo 的命名 
supervisorctl reload  #重新加载

然后就好了，现在关掉那个5000界面也可以访问。
配置Supervisor开机启动
打开目录 /usr/lib/systemd/system/ 新建文件 supervisord.service
内容：
# dservice for systemd (CentOS 7.0+)
# by ET-CS (https://github.com/ET-CS)
[Unit]
Description=Supervisor daemon

[Service]
Type=forking
ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf
ExecStop=/usr/bin/supervisorctl shutdown
ExecReload=/usr/bin/supervisorctl reload
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
执行命令：
systemctl enable supervisord  
systemctl is-enabled supervisord #来验证是否为开机启动
到此，完工。现在重新电脑什么都不用管，直接可以访问部署好的网站。
MySql5.6.37安装
http://www.cnblogs.com/starof/p/4680083.html （我用的方法二）
安装rar压缩
下载 http://www.rarsoft.com/download.htm

把文件放服务器上。然后cd到这个目录执行
tar -zxvf rarlinux-x64-5.4.0.tar.gz # rarlinux-x64-5.4.0.tar.gz是你下载的文件名
cd rar
make
rar #安装
安装好了后我们就可以打命令解压文件了
cd #跳到压缩文件目录
rar x ceshi.rar     #解压到当前文件夹 ceshi.rar是压缩文件名
rar a abc.rar ceshi #压缩文件夹 到 abc.rar
在CentOS中安装完rar命令，会自动安装zip命令
cd /home #进入/home目录
zip -r mydata.zip mydata      #把/home目录下面的mydata目录压缩为mydata.zip
unzip mydata.zip -d mydatabak #把/home目录下面的mydata.zip解压到mydatabak目录里面
zip -r abc123.zip abc 123.txt #把/home目录下面的abc文件夹和123.txt压缩成为abc123.zip
unzip wwwroot.zip             #把/home目录下面的wwwroot.zip直接解压到/home目录里面
unzip abc\*.zip               #把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面
unzip -v wwwroot.zip          #查看把/home目录下面的wwwroot.zip里面的内容
unzip -t wwwroot.zip          #验证/home目录下面的wwwroot.zip是否完整
unzip -j wwwroot.zip          #把/home目录下面wwwroot.zip里面的所有文件解压到第一级目录
常用linux命令
cd                 #目录跳转
cd /               #回到上一个目录
ls                 #查看目录下的文件
df -h              #查看文件使用情况
mkdir              #创建文件夹文件夹
vi                 # 编辑文件
:wq!               #强制保存文件，并退出vi

ifconfig -a        #查看ip
free #查看系统资源使用情况 http://blog.csdn.net/zhongluhuaok/article/details/52804187

firewall-cmd --zone=public --add-port=80/tcp --permanent     #开放80端口，也可以是其他端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent  # 关闭端口
systemctl restart firewalld                                  #重启防火墙，使其生效

service mysqld restart #重启mysql
nginx -s reload        # nginx 生效
reboot                 # 重启系统

supervisorctl start program_name   #启动某个进程(program_name=你配置中写的程序名称)
supervisorctl stop program_name    #停止某一进程 (program_name=你配置中写的程序名称)
supervisorctl reload               #重新启动配置中的所有程序
supervisorctl stop all             #停止全部进程
supervisorctl update               #更新新的配置到supervisord    
supervisorctl restart program_name #重启某一进程 (program_name=你配置中写的程序名称)
supervisorctl                      #查看正在守候的进程
http://blog.csdn.net/shudaqi2010/article/details/51153961

clear          #刷新终端屏幕 （或者 ctrl + l）
exit           #退出
shift + insert #粘贴
ctrl + insert  #复制
补充
centos上升级 .net core 2.0 需要先执行官网命令
curl -sSL -o dotnet.tar.gz https://aka.ms/dotnet-sdk-2.0.0-linux-x64
mkdir -p ~/dotnet && tar zxf dotnet.tar.gz -C ~/dotnet
export PATH=$PATH:$HOME/dotnet
然后再删除原有文件夹
rm -rf /opt/dotnet                              #删除原有文件夹
rm -rf /usr/local/bin/dotnet                    #删除原来定义的dotnet命令
sudo ln -s /root/dotnet/dotnet /usr/local/bin   #重新定义dotnet命令
且，项目程序也要升级到2.0，不然dotnet dll不能成功。
 
结束
这几天给我的感受就是，CentOS带我进入了一个更开阔的世界！！！开启我们的.net core吧，你会觉得很好玩的。
打算重写Hi-Blogs系统
访问地址：http://haojima.net （刚入手做了一个留言板、聊天室快去体验下吧。.net core 跑在阿里云linux上的。）
开源地址：https://github.com/zhaopeiym/Hi-Blogs
 
参考

http://www.cnblogs.com/ants/p/5732337.html
http://www.cnblogs.com/keepcodingforever/p/6642183.html
http://www.cnblogs.com/starof/p/4680083.html
http://www.cnblogs.com/linjiqin/archive/2013/03/24/2979897.html


article  2
title: 关于健康和运动
body: 
    像我们程序猿/媛们，天天坐在电脑旁边。运动量为零，还要时刻接受电脑的辐射。那么日子长了，健康自然就出问题了。什么近视眼和肩周炎应是最常见的，就是所谓的职业病。IT界有名的乔帮主都挂了，国内的有张孝祥也挂了年仅38，不是还有李开复也得了淋巴癌。这是大名鼎鼎的。其中还有多少多少的IT草根，加班猝死，时不时都有这样的新闻。难道这还不够我们程序猿/媛们引起警觉吗？健康是大问题啊。身体是革命的本钱， 身体不好，拼不过菜鸟。很多人对技术非常的热爱，天天无休止的学习进步，当人投入到了一件事情里面去了，是不知道时间过了多少的，也许天天加班加点的，但是从中得到了提升，我们就不觉得那么累了。但心里好像过的充实、兴奋，身体就不一定受的了了。
    万事开头难，千里之行始于足下。那就从今天开始，从现在开始。每天进步一点点，坚持下来，你会发现原来我也可以。
    下面我就来与大家分享下，我最近的运动情况。我觉得有效的运动，还是要做有氧运动，比如慢跑啊、爬山啊、滑冰啊、、我在上海，这边都没有看到山，所以只能选择跑步了。滑冰偶尔去。怎样坚持自己的运动呢？最好有个运动记录软件，那样的话，就好像有个东西在督促着，然后有份数据在那里自己的特有成就感。

 
 

 
    这就是我17天的运动数据，其中除了天气下雨和加班。每天必跑。其实老早去年的时候我就想跑步了。一直觉得实在是没时间。唯一有时间就只有周末了，发现周末两天实在是很难坚持。后来又想，要不早上跑吧，懒床有起不来。某次，偶然晚上有人跑步，想了想，那我就晚上跑吧。说实在的，刚开始确实很累很吃力。跑的时候，眼都看不清前面、脚也抬不起来、严重缺氧，肚子里面像打翻了什么一样。但我还是坚持了，心想付出了汗水，总会有回报的。不仅可以锻炼身体，更能锻炼我的毅力。刚开始的时候回到家里起码要半个小时后才能恢复，现在慢慢的十分钟不到就能呼吸平稳，也不继续流汗了。
 
一个人跑步是很孤独的，如果人多了。更能坚持。所以大家可以在网友约跑友一起。
 

 
----------------------------------更新2016-07-10----------------------------------
距离这篇博文发布已经一年多了，是时候更新下数据了。

 

什么事，都是贵在坚持。且，我们每个人都是可以被自己的坚持所吓到！
跑步是一种生活，当你汗流浃背的感觉有多爽，整个人都是轻松的。
不一定要跑多远，但是一定要坚持每天都跑。
我们不比时间、不比路程、不比速度，我们只比看谁更能坚持。
不要求有兔子般的速度，只求有乌龟般的精神。

 
另，热爱运动的农码可以进群（咕咚群）分享心得：
团号：11251918

 
article  3
title: ASP.NET Core 快速入门（实战篇）
body: 
上篇讲了《asp.net core在linux上的环境部署》。今天我们将做几个小玩意实战一下。用到的技术和工具有mysql、websocket、AngleSharp（爬虫html解析）、nginx多站点部署。
NO1 留言板（mysql的使用）
演示：http://haojima.net
这个功能很简单。就是对数据库的写入和展示。如果在Windows下，相信大家分分钟都可以搞定。而初次接触.net core + mysql可能需要注意些细节。
首先打开vs2017新建一个asp.net core项目（选Web应用程序），然后nuget 导入Microsoft.EntityFrameworkCore.Tools 1.1.1和MySql.Data.EntityFrameworkCore 8.0.8-dmr。
然后新建一个DbContext类。
public class DataContext : DbContext
{
    //【注意】连接字符串一定要加 sslmode=none 
    string str = @"Data Source=;Database=;User ID=;Password=;pooling=true;CharSet=utf8;port=3306;sslmode=none";
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =>
        optionsBuilder.UseMySQL(str);

    //下面就可以添加要加入数据库的实体了
    //public DbSet<Message> Messages { get; set; }
}
到此为止，我们已经可以利用EF Core直接连接mysql进行增删改查操作了。注意：需要导入命名空间using Microsoft.EntityFrameworkCore; using MySQL.Data.EntityFrameworkCore.Extensions;
当然。你会说，连接字符串不能硬编码到代码里面。我们也可以放配置文件。appsettings.json
{
  "Logging": {
    "IncludeScopes": false,
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "ConnectionStrings": { "SqlServerConnection": "Data Source=;Database=;User ID=;Password=;pooling=true;CharSet=utf8;port=3306;sslmode=none" }
}

然后把上面的硬编码注释掉。在Startup.cs文件的ConfigureServices方法添加
var connection = Configuration.GetConnectionString("SqlServerConnection");
services.AddDbContext<DataContext>(options => options.UseMySQL(connection));
【注意】项目名称和路径最好不要有中文，不然会出现些乱七八糟的问题。
【完整代码】：https://github.com/zhaopeiym/BlogDemoCode/tree/master/MessageBoard
NO2 聊天室（WebSocket的使用）
演示：http://socket.haojima.net
WebSocket是Html5新增的一个很酷的技术。下面我们简单讲解下这个很酷的技术
var Socket = new WebSocket(url);//创建 WebSocket 对象
创建了一个WebSocket对象后会触发打开连接事件：
Socket.onopen = function(){  }
除了onopen事件，还有其他三个事件：
Socket.onmessage  //客户端接收服务端数据时触发
Socket.onerror    //通信发生错误时触发
Socket.onclose    //连接关闭时触发
另外还有两个方法：
Socket.send()   //使用连接发送数据
Socket.close()  //关闭连接
最后还有四个连接状态属性：
Socket.readyState
0 - 表示连接尚未建立。
1 - 表示连接已建立，可以进行通信。
2 - 表示连接正在进行关闭。
3 - 表示连接已经关闭或者连接不能打开。
整个WebSocket常用功能知识点就四个事件、两个方法、四种状态。简单吧，下面我们看看asp.net core后台的配合：
后台添加一个SocketHandler类，并添加一个静态方法Map：
/// <summary>
/// 请求
/// </summary>
/// <param name="app"></param>
public static void Map(IApplicationBuilder app)
{
    app.UseWebSockets(); //【注意】需要 nuget   导入 Microsoft.AspNetCore.WebSockets.Server
    app.Use(Acceptor);
}
然后新增对应的Acceptor方法：
/// <summary>
/// 接收请求
/// </summary>
/// <param name="httpContext"></param>
/// <param name="n"></param>
/// <returns></returns>
static async Task Acceptor(HttpContext httpContext, Func<Task> n)
{
需要在Startup.cs类里面的Configure方法里面加入
app.Map("/ws", SocketHandler.Map);   //传入我们刚才新建的静态方法Map
现在为止，基本的类和配置已经完成。
我们主要操作，是在Acceptor方法里面接收和发送消息。
//建立连接
var socket = await httpContext.WebSockets.AcceptWebSocketAsync();
//等待接收数据
await socket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
//发送消息
await socket.SendAsync(arraySegment, WebSocketMessageType.Text, true, CancellationToken.None);
后台关键代码也就这三句，建立连接、等待接收、发送消息。
不过这里有一点需要理解。建立连接后，可以接收任意多次客户端消息。所以ReceiveAsync等待接收这里需要死循环接收消息，直到连接断开。（不用担心真的死循环，没有消息发送的时候，代码会阻塞在那里等待消息）
【完整实现】：https://github.com/zhaopeiym/ChatRoom
NO3 找工作（AngleSharp的使用）
演示：http://job.haojima.net
对于爬虫抓包，我相信大家初次接触都非常的热衷于此。我也不例外。
那么在asp.net core下面是否也有这样的插件呢？答案是肯定的。
http://www.cnblogs.com/linezero/p/5599611.html HtmlAgilityPack HTML解析（感谢博主对.net core的贡献）。不过xpath用起来超级恶心。
之前在.net下面有一款Jumony http://www.cnblogs.com/Ivony/p/3447536.html（博客园大牛写的）。支持CSS选择和linq查询。简直不要太爽。可是不支持.net core。（本人试了下迁移.net core，发现很多类在.net core没有实现）
最后还是到了一款支持.net core的解析组件。并可以媲美Jumony，同样支持css选择和linq查询。那就是AngleSharp。
新建项目，nuget 安装 AngleSharp。然后以下简单使用：
using (HttpClient http = new HttpClient())
{
    var htmlString = await http.GetStringAsync(url);
    HtmlParser htmlParser = new HtmlParser();
    var jobInfos = htmlParser.Parse(htmlString)
        .QuerySelectorAll(".newlist_list_content table")
        .Where(t => t.QuerySelectorAll(".zwmc a").FirstOrDefault() != null)
        .Select(t => new JobInfo()
        {
            PositionName = t.QuerySelectorAll(".zwmc a").FirstOrDefault().TextContent,
            CorporateName = t.QuerySelectorAll(".gsmc a").FirstOrDefault().TextContent,
            Salary = t.QuerySelectorAll(".zwyx").FirstOrDefault().TextContent,
            WorkingPlace = t.QuerySelectorAll(".gzdd").FirstOrDefault().TextContent,
        .ToList();
    return jobInfos;
}
看到没有，就像jq一样解析html。如果你说不爽我都不信。
【完整实现】：https://github.com/zhaopeiym/JobWanted
部署多个站点
以上，这些项目都比较简单。关键技术点和难点都进行的分析。我相信大家都可以动起手练习起来了。
不过有个问题，前面我们只说了部署一个应用程序。如果是多个该怎么部署呢？
首先我们把多个程序发布包放到服务器上。
然后修改nginx的配置文件/etc/nginx/conf.d/default.conf
server {
    listen 80;
    server_name www.haojima.net;           #对应的域名
    root /home/projects/messagBoard;       #程序路径
    location / {
        proxy_pass http://localhost:5000;  #内网端口
        proxy_http_version 1.1; 
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;
        
        proxy_set_header Upgrade $http_upgrade;   
    }
}
有几个程序就添加几个server，不过需要修改你解析到的域名、程序路径和内网对应的端口(看配置里的注释) 。
然后修改supervisor的配置文件/etc/supervisor/conf.d/supervisord.conf
[program:MessageBoard]
command=dotnet MessageBoard.dll        ; 运行程序的命令
directory= /home/projects/messagBoard/ ; 命令执行的目录
autorestart=true                    ; 程序意外退出是否自动重启
stderr_logfile=/var/log/WebApplication1.err.log ; 错误日志文件
stdout_logfile=/var/log/WebApplication1.out.log ; 输出日志文件
environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量
user=root ; 进程执行的用户身份
stopsignal=INT
有几个程序就往下复制几份program。需要修改program名称，只要名称不重复就可以。然后修改 运行程序的命令 对应的dll和命令执行的目录（看配置文件的注释）。
如此就可以部署多个程序了。
开始我还以为是在域名解析的时候，解析IP + 端口。原来是多个域名解析到同一个IP，然后nginx在内部做域名和内网端口分发。
一些其它的细节
部署阿里云
我们在linux的防火墙开放了端口，发现在外面还是访问不了（可以telnet IP 端口 来测试）。有可能是阿里云拦截了。https://help.aliyun.com/document_detail/25471.html 在安全组添加某端口哪些IP可以访问。
mysql的客户端
对于mysql，我们安装好之后总不能每次命令操作吧。在Windows下面有个客户端Navicat可以方便管理mysql。Navicat
获取ip
用了nginx后发现取不到浏览器IP了。那是因为我们程序都是浏览器访问nginx，然后nginx转发内网程序端口。所以取到的IP都是内网本机IP。如果需要取浏览器IP需要在nginx配置
server {
    listen 80;
    server_name www.haojima.net;
    root /home/projects/messagBoard;
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1; 
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;     # 新添加
    }
}
然后代码里面取IP：
 var ip = HttpContext.Request.Headers["X-real-ip"].FirstOrDefault();
WebSocket在nginx的配置
上面我们写的WebSocket直接运行发现没有任何问题，可是部署在nginx去跑不起来了。那是因为需要nginx支持WebSocket，需要配置。http://nginx.org/en/docs/http/websocket.html
server {
    listen 80;
    server_name job.haojima.net;
    root /home/projects/jobWanted;
    location / {
        proxy_pass http://localhost:5002;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;
        proxy_set_header Upgrade $http_upgrade;     # 新增
        proxy_set_header Connection "upgrade";      # 新增 
    }
}
WebSocket心跳
经过上面的配置，我们的WebSocket在nginx上跑起来了。万分欢喜的我们，发现一分钟不发消息就自动掉线了。郁闷至极到头大。细心的同学通过上面的链接资料其实已经有说明：
By default, the connection will be closed if the proxied server does not transmit any data within 60 seconds. This timeout can be increased with the proxy_read_timeout directive. Alternatively, the proxied server can be configured to periodically send WebSocket ping frames to reset the timeout and check if the connection is still alive.
靠，英文实在太烂了。
默认情况下，如果代理的服务器在60秒内没有传输任何数据，则连接将被关闭。可以使用proxy_read_timeout指令增加此超时 。或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。
nginx给出了两种解决方案。第一种，修改proxy_read_timeout (默认60秒)。第二种，浏览器客户端定时发送心跳包（时间要短于proxy_read_timeout）。
我使用的是第二种方式。
第一种虽然简单粗暴，但是时间再长也是一个值，还是会有超时的可能。再者，谁能保证浏览器端不会new 很多个WebSocket出来捣蛋。
第二种方式，浏览器定时发送一条消息，内容和后台约定下。如发送“心跳”，然后后台接收消息是，判断如果是“心跳”则不做任何处理。
中文编码
在做“找工作”爬前程无忧的数据时，发现他们使用的GBK编码。而在.net core中默认不支持这种格式，导致取到的数据都是乱码。我们需要nuget安装System.Text.Encoding.CodePages。然后在Startup.cs的Configure里面注册：
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);//注册编码提供程序
使用：
var htmlBytes = await http.GetByteArrayAsync(url);
var htmlString = Encoding.GetEncoding("GBK").GetString(htmlBytes);
asp.net core 端口分配
asp.net core 默认端口都是5000。那么我们运行第二个程序的时候就会提示5000端口被占用。这个时候，我们就需要为每个程序分配不同的端口了。
在根目录新建一个json文件hosting.json
{
  "server.urls": "http://*:5002"
}
在Program.cs文件修改
public static void Main(string[] args)
{
    var config = new ConfigurationBuilder()
          .SetBasePath(Directory.GetCurrentDirectory())
          .AddJsonFile("hosting.json", optional: true)
          .Build();

    var host = new WebHostBuilder()
        .UseKestrel()
        .UseConfiguration(config)
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup<Startup>()
        .UseApplicationInsights()
        .Build();

    host.Run();
}
爬拉勾数据
在爬拉勾网的时候没有搞定，不知道是不是因为https的原因。
using (HttpClient http = new HttpClient())
{
    var url = "https://www.lagou.com/zhaopin/Java/?labelWords=label";
    var htmlString = await http.GetStringAsync(url);
}
在.net core中报错：An unhandled exception occurred while processing the request.
在.net 4.5 中抓到的数据是“页面加载中...”。和浏览器访问的结果不一样。
原因未知。如果有大佬解惑，感激不尽！
 
参考
http://www.runoob.com/html/html5-websocket.html
http://www.cnblogs.com/liguobao/p/6130121.html
http://www.cnblogs.com/linezero/p/5806814.html
演示
http://haojima.net
http://socket.haojima.net
http://job.haojima.net
源码
https://github.com/zhaopeiym/JobWanted
https://github.com/zhaopeiym/ChatRoom
https://github.com/zhaopeiym/BlogDemoCode

article  4
title: Linux学习(1)-常用快捷键、文件管理和查询
body: 
有话要说
为什么要用Linux？要用Linux的原因太多，想说说不完啊。
如果你说用Linux只是为了装逼，那证明你真的还很菜。不排除有装逼了因素，那也只占非常少的比例，可以忽略不计。
我们反问一下，为什么不用Linux呢？回答无非就是：没有图像界面、操作太复杂、和我以前的使用习惯不一样、学习新的系统需要学习成本。
其实只是我们排斥未知的恐惧，从心底里面抵触，而找的各种理由。要想做好一件事，我们会去找各种方法。不想做一件事，我们会去找各种理由。
.net core的推出绝对不是让我们在Windows上玩玩的。特别是多年经验的.net er，需要快速适应这种变化，不然这是个危险的信号啊。
我们正在进行一场革命，革的不好就没命了。微软都已经拥抱Linux了，你还有在坚持什么呢？（当然，如果你只是想玩.net framework的话，当我没说。）

进入Linux你将进入另一个世界，下面开始我们Linux的学习吧~
Shell应用技巧，常用快捷键
Shift + insert             #粘贴
Ctrl + insert              #复制
Tab【按键】或者 Ctrl + i   #命令补齐 【这个快捷键太有用了，这不就是linux下的智能提示么】
Ctrl + w                   #删除前一个单词
Ctrl + u                   #删除光标前全部字符
Ctrl + k                   #删除光标后全部字符
Ctrl + d                   #删除光标所在字符
Ctrl + y                   #将删除的字符粘出来
Ctrl + a                   #将光标移动到行首
Ctrl + e                   #将光标移动到行尾
← 或者 ctrl + b            #光标左移动
→ 或者 Ctrl + f            #光标右移动
↑ 或者 Ctrl + p            #显示上一条命令
↓ 或者 ctrl + n            #显示下一条命令
ctrl + s                   #暂时冻结输入
ctrl + q                   #解冻(解冻后会自动输入之前的输入)
Ctrl + l                   #清屏  
Ctrl + c                   #退出正在的执行命令或另起一行
Ctrl + d                   #退出登录
Ctrl + z
帮助命令
man （帮助命令）
原意：manual
语法：man [命令或配置文件]  
首先我们学习linux命令太多，不可能记住所有命令。那么这个man命令就是个很好的帮助命令。  
示例：
man 1 passwd  # 1查看命令帮助 ，1默认可以省略
man 5 passwd  # 5查看配置文件帮助
#只要按下/，光标就会跑到这个地方来，你就可以开始输入搜寻字串（n继续往下查询，N方向查询）
#q退出、空格向下翻页、pgup向上翻页
info （和man差不多）
原意：information
语法：info [任何关键字]
whatis （查询基本信息，等效于man -f）
#mandb 更新whatis数据库
help （帮助）
可以查询一些shell内置命令帮助，如 cd、pwd
--help (获取选项信息【常用】)
示例: 
[root@localhost ~]# cat --help
用法：cat [选项]... [文件]...
将[文件]或标准输入组合输出到标准输出。
  -A, --show-all           等于-vET
  -b, --number-nonblank    对非空输出行编号
  -e                       等于-vE
  -E, --show-ends          在每行结束处显示"$"
  -n, --number             对输出的所有行编号
  -s, --squeeze-blank      不输出多行空行
  -t                       与-vT 等价
  -T, --show-tabs          将跳格字符显示为^I
  -u                       (被忽略)
  ...
有了这个命令，我们学习起来就有了诀窍。  
alias （别名）
查看别名：alias
命令别名：alias mycp='cp'
这样起的别名只在当前窗口有效，如果要是命令长期有效则要修改配置文件.bashrc，在/root目录下。  
这样就很方便我们定制自己的个性命令了。比如重启supervisorctl reload这个命令记不住，太长了。我们可以别名alias reloadsupervisorctl='supervisorctl reload'。这样我们只要记住reload然后按tab键就可以自动补全了。
文件管理、文件搜索命令
cd （切换目录）
原意：change directo
语法：cd [目录]
pwd （显示当前目录）
原意：print working directory
语法：pwd
特殊目录
. 代表此层目录（cd ./dotnet 和 cd dotnet等效）
.. 代表上一层目录
- 代表前一个工作目录（上次执行cd前的目录）
~ 代表“目前使用者身份”所在的主文件夹（和直接执行cd等效）
~account 代表 account 这个使用者的主文件夹（ account是个帐号名称）
示例：
cd ~   #和直接cd 等效
cd ..  #返回上层目录
cd -   #回到上次执行cd执行前的目录
ls （显示目录文件）
- 原意：list
- 语法：ls [-ald] [文件或目录]
touch （创建空文件）
语法：touch [文件名]
查看文件的时间信息：
modification time （ mtime）：内容数据变更时
status time （ ctime）：状态改变时
access time （ atime） ：该文件的内容被取用时
示例：
[root@localhost dotnet]# ls -l dotnet              #查看dotnet文件的创建时间（默认就是mtime）
-rwxr-xr-x. 1 1002 27 105664 7月  21 07:16 dotnet
[root@localhost dotnet]# ls -l --time=atime dotnet #查看dotnet文件的读取时间
-rwxr-xr-x. 1 1002 27 105664 8月  19 17:31 dotnet
[root@localhost dotnet]# ls -l --time=ctime dotnet #查看dotnet文件的状态更新时间
-rwxr-xr-x. 1 1002 27 105664 8月  15 20:23 dotnet

mkdir （创建新目录）
语法：mkdir [目录名]
cp （复制文件或目录）
语法：cp -r [原文件或目录][目的目录]
示例：
[root@localhost ~]# cp mytest.txt mytest2.txt #复制mytest.txt 到 mytest2.txt
[root@localhost ~]# cp project project2       #复制文件夹（如果文件夹里面有内容赋值失败） 
cp: 略过目录"project"
[root@localhost ~]# cp -r project project2    #复制文件夹 （需要带上 -r参数，递回持续复制）
mv （移动文件或重命名）
原意：move
语法：mv [源文件或目录 ][目的目录]
rm （删除文件）
原意：remove
语法：rm -rf [文件或目录]   #r是删除目录 f是不需要确认
示例：
[root@localhost ~]# rm mytest2.txt     #删除文件mytext2.txt（会默认给出提示）
rm：是否删除普通文件 "mytest2.txt"？y
[root@localhost ~]# rm -f mytest.txt   #删除文件不需要提示（带上 -f参数）
[root@localhost ~]# rm project2        #不能删除目录
rm: 无法删除"project2": 是一个目录
[root@localhost ~]# rm -rf project2    #删除目录需要带上-r（-r递回删除、带上f是不需要确认提示，如果一百个文件，提示一百次会疯的）
[root@localhost project2]# rm System.Xml*                #删除System.Xml开头的文件
rm：是否删除普通文件 "System.Xml.ReaderWriter.dll"？y
rm：是否删除普通文件 "System.Xml.XDocument.dll"？y

cat （显示文件内容）
原意：Concatenate
语法：cat [文件名]
示例：
[root@localhost ~]# cat mytest.test     #查看文件mytest.test
[root@localhost ~]# cat -n mytest.test  #-n显示行号 （类似nl命令）
这个命令有个缺点，就是显示全部信息，如果内容过多，浏览就不方便了。
more （分页显示文件内容）
语法：more [文件名] 
 空格或f显示下一页
 回车显示下一行
 q退出
示例：
[root@localhost ~]# more 三体.txt 
输入/  然后输入关键字比如“三”
/三
...跳过
相关文章
 
《三体3》未获雨果奖 ...
《三体》电影确定上映日程,...
#把带“三”的行都搜索出来了。
less （分页查询，比more更加强大）
more 只能翻下一页，less可以上下翻页。
参数：
[pagedown]：向下翻动一页；
[pageup] ：向上翻动一页；
/字串 ：向下搜寻“字串”的功能；
?字串 ：向上搜寻“字串”的功能；
n ：重复前一个搜寻 （ 与 / 或 ? 有关！）
N ：反向的重复前一个搜寻 （ 与 / 或 ? 有关！）
g ：前进到这个数据的第一行去；
G ：前进到这个数据的最后一行去 （ 注意大小写） ；
q ：离开 less 这个程序；
示例：
[root@localhost ~]# less  三体.txt 
输入/  然后输入关键字比如“三” 可以高亮关键字。
head （查看文件的前几行）
语法：head -num [文件名]
示例：
[root@localhost ~]# head -n 5 三体.txt   #显示前五行
[root@localhost ~]# head -n 5 三体.txt   #不显示后五行
tail （查看文件的后几行）
语法：tail -num [文件名]
ln （产生链接文件）
原意：link
语法：ln -s [源文件] [目标文件]
示例：  
ln -s /home/testfile /home/testfile.soft  #创建文件的软链接testfile.soft  
ls -s /home.testfile /home/testifle.hard  #创建文件的硬链接testfile.hard
which （显示系统命令所在目录）
语法：which [命令名称]
示例：
[root@localhost dotnet]# which ifconfig
/usr/sbin/ifconfig
find （查找文件或目录）
语法：find [搜索路径][搜索关键字]
-a 逻辑与 -o 逻辑或  -name文件名 -size文件大小 -cteime文件修改时间
示例：
find /etc -name init    #查找目录下名字是inti的文件   
find /etc -size +204800 #查找目录下大于100M的文件   
find /etc -ctime -1     #查找24小时内被修改过属性的文件和目录  
find mytest -exec ls -l {} \; #查看当前目录mytest文件夹下的文件执行 ls -l 命令。 -exec {}\; 是固定格式。
find mytest -name F* #查找mytest文件夹下以F开头的文件
find mytest -name F??? #查找mytest文件夹下以F开头的并且文件名只有四个字母
locate （寻找文件或目录）
用法：locate [搜索关键字]
示例：
[root@localhost dotnet]# locate dotnet    #查询所有包含dotnet的文件和目录  
[root@localhost dotnet]# locate Dotnet    #查询不到，因为区分大小写
[root@localhost dotnet]# locate -i Dotnet #查找所有路径或文件名包含dotnet关键字文件路径，且不区分大小写
[root@localhost dotnet]# locate -ic Dotnet#查询搜索结果的数量 
3661
说明：
查询缓存数据库里查询（可以使用updatedb命令 [建立目录文件的数据库]，默认每天更新一次）
grep （在文件内容中搜索匹配的行并输出）
用法：grep [指定字符串][源文件]
示例：
grep 我 testfile #搜索当前目录下的文件testfile中包含“我”的行
其他
输入/输出重定向
- > 输出重定向
示例： ls -l > mytest.txt #将当前目录的所以文件信息写入mytest.txt文件下。
- < 输入重定向
示例：wall <  mytest.txt  #将mytest.txt文件里面的内容广播（wall广播命令）  
- 2> 错误重定向
示例：ggg 2> err.txt      # err.txt将记录错误信息 (ggg是个错误命令)
history （显示历史命令）
| （管道）
ls查询到的文件可能很多，如果我们想要分页浏览，我们可以使用管道命令  
ls -l /etc | more              #分页查看etc目录下的文件  
ls -l /etc | grep init         #查看etc目录下文件名包含init的文件  
ls -l /etc | grep init | wc -l #查看etc目录下文件名包含init的文件的个数
命令连接符
 ; 
示例：cd /home ; ls #跳转到home目录并且查看里面的文件（就算是错误的命令也会继续执行后面的命令。）
 &&
示例：ggg && ls #不会查看目录下的文件（中间有错误的命令存在就不会执行后面的命令）
 ||
示例：ggg || ls #会执行查看目录下的文件（遇到可以执行成功的命令就会停止执行后面的命令）
命令替换符
用法：命令1 `命令2`
示例：
ls -l `which cd` #查看cd命令的文件信息（which定位命令的位置）
netstat
netstat -lntp  #查看监听(Listen)的端口
netstat -antp  #查看所有建立的TCP连接
netstat -tunlp #查看端口使用情况 （如  netstat -tunlp | grep 3306 查看3306端口是否被使用）
netstat -n | grep tcp | grep 80 | wc -l #监控网络客户连接数
负载信息
ps -eLf | grep dotnet | wc -l           #监控dotnet线程数
mpstat       #不但能查看所有CPU的平均信息，还能查看指定CPU的信息。
top -u mysql #查看使用情况 按键盘数字“1”，可监控每个逻辑CPU的状况 （http://blog.csdn.net/dxl342/article/details/53507673）
df -lh            #显示所有硬盘的使用状况
firewall防火墙
firewall-cmd --zone=public --add-port=80/tcp --permanent     #开放80端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent  #关闭80端口
firewall-cmd --reload                                        #重新载入，使其生效
systemctl restart firewalld                                  #重启防火墙
firewall-cmd --zone=public --list-ports                      #查看防火墙开启的端口
http://www.cnblogs.com/moxiaoan/p/5683743.html
其他
- su #用户切换
[root@localhost dotnet]# su BennyZhao
[BennyZhao@localhost dotnet]$ su root
- 图形界面与字符界面切换
init 5 #切换到图形界面
init 3 #切换到命令行界面
- 安装rz
yum install lrzsz #安装rz和sz命令
- curl访问
curl              #访问
注意：除了 / 之外，所有的符号都可以为文件或文件夹命名。命名大小写敏感。
yum list installed | grep dotnet  #查找已经安装的程序
yum remove dotnet                  #卸载安装的程序
推荐
我的博客只是个人学习总结，并不适合园友用来学习。
这里推荐《鸟哥的Linux 私房菜》：http://linux.vbird.org/linux_basic/0220filemanager.php 这是网页版（默认是繁体字，可以使用chrome浏览器自动翻译成简体。可以用pocket插件在手机端看）网上也有PDF、mobi版。
然后喜欢看视频的可以：http://study.163.com/course/introduction.htm?courseId=266032#/courseDetail?tab=1 李明老师的视频也很不错，你也可以下载网易云课堂手机版在公交车或地铁上看。

article  5
title: 文件下载之断点续传（客户端与服务端的实现）
body: 
前面讲了文件的上传，今天来聊聊文件的下载。
老规矩，还是从最简单粗暴的开始。那么多简单算简单？多粗暴算粗暴？我告诉你可以不写一句代码，你信吗？直接把一个文件往IIS服务器上一扔，就支持下载。还TM么可以断点续传（IIS服务端默认支持）。
在贴代码之前先来了解下什么是断点续传（这里说的是下载断点续传）？怎么实现的断点续传？
断点续传就是下载了一半断网或者暂停了，然后可以接着下载。不用从头开始下载。
很神奇吗，其实简单得很，我们想想也是可以想到的。
首先客户端向服务端发送一个请求（下载文件）。然后服务端响应请求，信息包含文件总大小、文件流开始和结束位置、内容大小等。那具体是怎么实现的呢？
HTTP/1.1有个头属性Range。比如你发送请求的时候带上Range:0-199，等于你是请求0到199之间的数据。然后服务器响应请求Content-Range: bytes 0-199/250 ，表示你获取了0到199之间的数据，总大小是250。（也就是告诉你还有数据没有下载完）。
我们来画个图吧。

是不是很简单？这么神奇的东西也就是个“约定”而已，也就是所谓的HTTP协议。
然而，协议这东西你遵守它就存在，不遵守它就不存在。就像民国时期的钱大家都信它，它就有用。如果大部分人不信它，也就没卵用了。
这个断点续传也是这样。你服务端遵守就支持，不遵守也就不支持断点续传。所以我们写下载工具的时候需要判断响应报文里有没有Content-Range，来确定是否支持断点续传。
废话够多了，下面撸起袖子开干。
文件下载-服务端
使用a标签提供文件下载
利用a标签来下载文件，也就是我们前面说的不写代码就可以实现下载。直接把文件往iis服务器上一扔，然后把链接贴到a标签上，完事。
<a href="/新建文件夹2.rar">下载</a>
简单、粗暴不用说了。如真得这么好那大家也不会费力去写其他下载逻辑了。这里有个致命的缺点。这种方式提供的下载不够安全。谁都可以下载，没有权限控制，说不定还会被人文件扫描（好像csdn就出过这档子事）。
使用Response.TransmitFile提供文件下载
上面说直接a标签提供下载不够安全。那我们怎么提供相对安全的下载呢。asp.net默认App_Data文件夹是不能被直接访问的，那我们把下载文件放这里面。然后下载的时候我们读取文件在返回到响应流。
//文件下载
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    Response.ContentType = "application/octet-stream";  //二进制流
    Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
    Response.TransmitFile(filePath); //将指定文件写入 HTTP 响应输出流
}

其他方式文件下载
在网上搜索C#文件下载一般都会搜到所谓的“四种方式”。其实那些代码并不能拿来直接使用，有坑的。
第一种：（Response.BinaryWrite）
 public void FileDownload2()
 {
     string fileName = "新建文件夹2.rar";//客户端保存的文件名  
     string filePath = Server.MapPath("/App_Data/新建文件夹2.rar");//要被下载的文件路径   

     Response.ContentType = "application/octet-stream";//二进制流
     //通知浏览器下载文件而不是打开  
     Response.AddHeader("Content-Disposition", "attachment;  filename=" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8));

     //以字符流的形式下载文件  
     using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
     {
         Response.AddHeader("Content-Length", fs.Length.ToString());
         //这里容易内存溢出
         //理论上数组最大长度 int.MaxValue 2147483647 
         //（实际分不到这么多，不同的程序能分到值也不同，本人机器，winfrom( 2147483591 相差56)、iis(也差不多2G)、iis Express（只有100多MB））
         byte[] bytes = new byte[(int)fs.Length];
         fs.Read(bytes, 0, bytes.Length);
         Response.BinaryWrite(bytes);
     }
     Response.Flush();
     Response.End();
 }
首先数组最大长度为int.MaxValue，然后正常程序是不会分这么大内存，很容易搞挂服务器。（也就是可以下载的文件，极限值最多也就2G不到。）【不推荐】
第二种：（Response.WriteFile）
public void FileDownload3()
{
    string fileName = "新建文件夹2.rar";//客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/新建文件夹2.rar");//要被下载的文件路径  
    FileInfo fileInfo = new FileInfo(filePath);
    Response.Clear();
    Response.ClearContent();
    Response.ClearHeaders();
    Response.AddHeader("Content-Disposition", "attachment;filename=\"" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8) + "\"");
    Response.AddHeader("Content-Length", fileInfo.Length.ToString());//文件大小
    Response.AddHeader("Content-Transfer-Encoding", "binary");
    Response.ContentType = "application/octet-stream";
    Response.WriteFile(fileInfo.FullName);//大小参数必须介于零和最大的 Int32 值之间(也就是最大2G，不过这个操作非常耗内存)
    //这里容易内存溢出
    Response.Flush();
    Response.End();
}
问题和第一种类似，也是不能下载大于2G的文件。然后下载差不多2G文件时，机器也是处在被挂的边缘，相当恐怖。【不推荐】
第三种：（Response.OutputStream.Write）
public void FileDownload4()
{
    string fileName = "大数据.rar";//客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径   

    if (System.IO.File.Exists(filePath))
    {
        const long ChunkSize = 102400; //100K 每次读取文件，只读取100K，这样可以缓解服务器的压力  
        byte[] buffer = new byte[ChunkSize];

        Response.Clear();
        using (FileStream fileStream = System.IO.File.OpenRead(filePath))
        {
            long fileSize = fileStream.Length; //文件大小  
            Response.ContentType = "application/octet-stream"; //二进制流
            Response.AddHeader("Content-Disposition", "attachment; filename=" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8));
            Response.AddHeader("Content-Length", fileStream.Length.ToString());//文件总大小
            while (fileSize > 0 && Response.IsClientConnected)//判断客户端是否还连接了服务器
            {
                //实际读取的大小  
                int readSize = fileStream.Read(buffer, 0, Convert.ToInt32(ChunkSize));
                Response.OutputStream.Write(buffer, 0, readSize);
                Response.Flush();//如果客户端 暂停下载时，这里会阻塞。
                fileSize = fileSize - readSize;//文件剩余大小
            }
        }
        Response.Close();
    }
}
这里明显看到了是在循环读取输出，比较机智。下载大文件时没有压力。【推荐】
第四种：（Response.TransmitFile）
也就上开始举例说的那种，下载大文件也没有压力。【推荐】
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    Response.ContentType = "application/octet-stream";  //二进制流
    Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
    Response.TransmitFile(filePath); //将指定文件写入 HTTP 响应输出流
}
文件下载-客户端
上面实现了文件下载的服务端实现，接下来我们实现文件下载的客户端实现。客户端的下载可以直接是浏览器提供的下载，也可以是迅雷或者我们自己写的下载程序。这里为了更好的分析，我们来用winfrom程序自己写个下载客户端。
直接下载
private async void button1_ClickAsync(object sender, EventArgs e)
{
    using (HttpClient http = new HttpClient())
    {
        var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar");//发送请求 (链接是a标签提供的)
        var contentLength = httpResponseMessage.Content.Headers.ContentLength;//读取文件大小
        using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())//读取文件流
        {
            var readLength = 1024000;//1000K  每次读取大小
            byte[] bytes = new byte[readLength];
            int writeLength;
            while ((writeLength = stream.Read(bytes, 0, readLength)) > 0)//分块读取文件流
            {
                using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))//使用追加方式打开一个文件流
                {
                    fs.Write(bytes, 0, writeLength);//追加写入文件
                    contentLength -= writeLength;
                    if (contentLength == 0)//如果写入完成 给出提示
                        MessageBox.Show("下载完成");
                }
            }
        }
    } 
}
看着这么漂亮的代码，好像没问题。可现实往往事与愿违。

我们看到了一个异常“System.Net.Http.HttpRequestException:“不能向缓冲区写入比所配置最大缓冲区大小 2147483647 更多的字节。”，什么鬼，又是2147483647这个数字。因为我们下载的文件大小超过了2G，无法缓冲下载。
可是“缓冲下载”下又是什么鬼。我也不知道。那我们试试可以关掉这个东东呢？答案是肯定的。
var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar");//发送请求
改成下面就可以了
var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar",HttpCompletionOption.ResponseHeadersRead);//响应一可用且标题可读时即应完成的操作。 (尚未读取的内容。)

我们看到枚举HttpCompletionOption的两个值。一个是响应读取内容，一个是响应读取标题（也就是Headers里的内容）。
异步下载
我们发现在下载大文件的时候会造成界面假死。这是UI单线程程序的通病。当然，这么差的用户体验是我们不能容忍的。下面我们为下载开一个线程，避免造成UI线程的阻塞。
/// <summary>
/// 异步下载
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void button2_ClickAsync(object sender, EventArgs e)
{
    //开启一个异步线程
    await Task.Run(async () =>
    {
        //异步操作UI元素
        label1.Invoke((Action)(() =>
                {
                    label1.Text = "准备下载...";
                }));

        long downloadSize = 0;//已经下载大小
        long downloadSpeed = 0;//下载速度
        using (HttpClient http = new HttpClient())
        {
            var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar", HttpCompletionOption.ResponseHeadersRead);//发送请求
            var contentLength = httpResponseMessage.Content.Headers.ContentLength;   //文件大小                
            using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())
            {
                var readLength = 1024000;//1000K
                byte[] bytes = new byte[readLength];
                int writeLength;
                var beginSecond = DateTime.Now.Second;//当前时间秒
                while ((writeLength = stream.Read(bytes, 0, readLength)) > 0)
                {
                    //使用追加方式打开一个文件流
                    using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))
                    {
                        fs.Write(bytes, 0, writeLength);
                    }
                    downloadSize += writeLength;
                    downloadSpeed += writeLength;
                    progressBar1.Invoke((Action)(() =>
                    {
                        var endSecond = DateTime.Now.Second;
                        if (beginSecond != endSecond)//计算速度
                        {
                            downloadSpeed = downloadSpeed / (endSecond - beginSecond);
                            label1.Text = "下载速度" + downloadSpeed / 1024 + "KB/S";

                            beginSecond = DateTime.Now.Second;
                            downloadSpeed = 0;//清空
                        }
                        progressBar1.Value = Math.Max((int)(downloadSize * 100 / contentLength), 1);
                    }));
                }

                label1.Invoke((Action)(() =>
                {
                    label1.Text = "下载完成";
                }));
            }
        }
    });
}
效果图：

断点续传
上面的方式我们发现，如果下载到一个半断网了下次会重头开始下载。这和我们今天的主题明显不符嘛。下面我们开始正式进入主题文件下载之断点续传。把前面我们说到的头属性Range用起来。
var request = new HttpRequestMessage { RequestUri = new Uri(url) };
request.Headers.Range = new RangeHeaderValue(rangeBegin, null); //【关键点】全局变量记录已经下载了多少，然后下次从这个位置开始下载。
var httpResponseMessage = await http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
完整代码：
/// <summary>
/// 是否暂停
/// </summary>
static bool isPause = true;
/// <summary>
/// 下载开始位置（也就是已经下载了的位置）
/// </summary>
static long rangeBegin = 0; //(当然，这个值也可以存为持久化。如文本、数据库等)

private async void button3_ClickAsync(object sender, EventArgs e)
{
    isPause = !isPause;
    if (!isPause)//点击下载
    {
        button3.Text = "暂停";

        await Task.Run(async () =>
        {
            //异步操作UI元素
            label1.Invoke((Action)(() =>
           {
               label1.Text = "准备下载...";
           }));

            long downloadSpeed = 0;//下载速度
            using (HttpClient http = new HttpClient())
            {
                var url = "http://localhost:813/新建文件夹2.rar";
                var request = new HttpRequestMessage { RequestUri = new Uri(url) };
                request.Headers.Range = new RangeHeaderValue(rangeBegin, null); //【关键点】全局变量记录已经下载了多少，然后下次从这个位置开始下载。
                var httpResponseMessage = await http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
                var contentLength = httpResponseMessage.Content.Headers.ContentLength;//本次请求的内容大小
                if (httpResponseMessage.Content.Headers.ContentRange != null) //如果为空，则说明服务器不支持断点续传
                {
                    contentLength = httpResponseMessage.Content.Headers.ContentRange.Length;//服务器上的文件大小
                }

                using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())
                {
                    var readLength = 1024000;//1000K
                    byte[] bytes = new byte[readLength];
                    int writeLength;
                    var beginSecond = DateTime.Now.Second;//当前时间秒
                    while ((writeLength = stream.Read(bytes, 0, readLength)) > 0 && !isPause)
                    {
                        //使用追加方式打开一个文件流
                        using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))
                        {
                            fs.Write(bytes, 0, writeLength);
                        }
                        downloadSpeed += writeLength;
                        rangeBegin += writeLength;
                        progressBar1.Invoke((Action)(() =>
                        {
                            var endSecond = DateTime.Now.Second;
                            if (beginSecond != endSecond)//计算速度
                            {
                                downloadSpeed = downloadSpeed / (endSecond - beginSecond);
                                label1.Text = "下载速度" + downloadSpeed / 1024 + "KB/S";

                                beginSecond = DateTime.Now.Second;
                                downloadSpeed = 0;//清空
                            }
                            progressBar1.Value = Math.Max((int)((rangeBegin) * 100 / contentLength), 1);
                        }));
                    }

                    if (rangeBegin == contentLength)
                    {
                        label1.Invoke((Action)(() =>
                        {
                            label1.Text = "下载完成";
                        }));
                    }
                }
            }
        });
    }
    else//点击暂停
    {
        button3.Text = "继续下载";
        label1.Text = "暂停下载";
    }
}
效果图：

到现在为止，你以为我们的断点续传就完成了吗？
错，你有没有发现我们使用的下载链接是a标签的。也就是我们自己写服务端提供的下载链接是不是也可以支持断点续传呢？下面我换个下载链接试试便知。
断点续传(服务端的支持)
测试结果如下：

发现并不支持断点续传。为什么a标签链接可以直接支持，我们写的下载却不支持呢。
a标签的链接指向的直接是iis上的文件（iis默认支持），而我们写的却没有做响应报文表头Range的处理。（没想象中的那么智能嘛 >_<）
前面我们说过，断线续传是HTTP的一个协议。我们遵守它，它就存在，我们不遵守它也就不存在。
那下面我们修改前面的文件下载代码（服务端）：
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    var range = Request.Headers["Range"];
    if (!string.IsNullOrWhiteSpace(range))//如果遵守协议，支持断点续传
    {
        var fileLength = new FileInfo(filePath).Length;//文件的总大小
        long begin;//文件的开始位置
        long end;//文件的结束位置
        long.TryParse(range.Split('=')[1].Split('-')[0], out begin);
        long.TryParse(range.Split('-')[1], out end);
        end = end - begin > 0 ? end : (fileLength - 1);// 如果没有结束位置，那我们读剩下的全部

        //表头 表明  下载文件的开始、结束位置 和文件总大小
        Response.AddHeader("Content-Range", "bytes " + begin + "-" + end + "/" + fileLength);
        Response.ContentType = "application/octet-stream";
        Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
        Response.TransmitFile(filePath, begin, (end - begin));//发送 文件开始位置读取的大小
    }
    else
    {
        Response.ContentType = "application/octet-stream";
        Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
        Response.TransmitFile(filePath);
    }
}
然后再测试断点续传，完美支持。
多线程同时下载（分片下载）
文件的断点续传已经分析完了。不过中间有些细节的东西你可以根据实际需求去完善。如：文件命名、断点续传的文件是否发生了改变、下载完成后验证文件和服务器上的是否一致。
还有我们可以根据表头属性Range来实现多线程下载，不过这里就不贴代码了,贴个效果图吧。和上一篇文件上传里的多线程上传同理。您也可以根据提供的demo代码下载查看，内有完整实现。

 
参考资料

http://www.cnblogs.com/yank/p/HTTP-Range.html
http://www.cnblogs.com/sparkdev/p/6141539.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/上传下载


article  6
title: 面对疑似网络诈骗，应该怎样维权？反信用钱包！
body: 

受害人群逐渐增多，各平台依然可以下载，相关部门依然没有动作。
反信用钱包群：187865423
新浪新闻：
http://comment5.news.sina.com.cn/comment/skin/default.html?channel=cj&newsid=comos-fxwvpar8410253
同步知乎提问：（请求各位园友、知乎大佬加速扩散）
https://www.zhihu.com/question/60349734/answer/175494684


article  7
title: 文件各种上传，离不开的表单
body: 
作为程序员的我们，经常会要用到文件的上传和下载功能。到了需要用的时候，各种查资料。有木有..有木有...。为了方便下次使用，这里来做个总结和备忘。
利用表单实现文件上传
最原始、最简单、最粗暴的文件上传。
前端代码：
//方式1
<form action="/Home/SaveFile1" method="post" enctype="multipart/form-data">
     <input type="file" class="file1" name="file1" />
     <button type="submit" class="but1">上传</button>
</form>

【注意】

1、需要post提交
2、enctype="multipart/form-data" （传输文件）
3、需要提交的表单元素需要设置 name 属性

后台代码：
public ActionResult SaveFile1()
{
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Request.Files[0].FileName);
        return Content("保存成功");
    }
    return Content("没有读到文件");
}
表单异步上传（jquery.form插件）
虽然上面的方式简单粗暴，但是不够友好。页面必然会刷新。难以实现停留在当前页面，并给出文件上传成功的提示。
随着时间的流逝，技术日新月异。ajax的出现，使得异步文件提交变得更加容易。
下面我们利用jquery.form插件来实现文件的异步上传。
首先我们需要导入jquery.js和jquery.form.js
前端代码：
<form id="form2" action="/Home/SaveFile2" method="post" enctype="multipart/form-data">
    <input type="file" class="file1" name="file1" />
    <button type="submit" class="but1">上传1</button>
    <button type="button" class="but2">上传2</button>
</form>

//方式2（通过ajaxForm绑定ajax操作）
$(function () {
    $('#form2').ajaxForm({
        success: function (responseText) {
            alert(responseText);
        }
    });
});

//方式3（通过ajaxSubmit直接执行ajax操作）
$(function () {
    $(".but2").click(function () {
        $('#form2').ajaxSubmit({
            success: function (responseText) {
                alert(responseText);
            }
        });
    });
});

后台代码：
public string SaveFile2()
{
    if (Request.Files.Count > 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
原理：
我们很多时候使用了插件，就不管其他三七二十一呢。
如果有点好奇心，想想这个插件是怎么实现的。随便看了看源码一千五百多行。我的妈呀，不就是个异步上传吗，怎么这么复杂。
难以看出个什么鬼来，直接断点调试下吧。

原来插件内部有iframe和FormData不同方式来上传，来适应更多版本浏览器。
模拟表单数据上传（FormData）
iframe这东西太恶心。我们看到上面可以利用FormData来上传文件，这个是Html 5 才有的。下面我们自己也来试试把。
前端代码：
<input id="fileinfo" type="file" class="notFormFile" />
<button type="button" class="btnNotForm">上传4</button>
//方式4
$(".btnNotForm").click(function () {
    var formData = new FormData();//初始化一个FormData对象
    formData.append("files", $(".notFormFile")[0].files[0]);//将文件塞入FormData
    $.ajax({
        url: "/Home/SaveFile2",
        type: "POST",
        data: formData,
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });
});

后的代码：（不变，还是上例代码）
public string SaveFile2()
{
    if (Request.Files.Count > 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
我们看到，FormData对象也只是在模拟一个原始的表单格式的数据。那有没有可能不利用表单或表单格式来上传文件呢？答案是肯定的。（下面马上揭晓）
前端代码：
<input type="file"  id="file5" multiple>
<button type="button" class="btnFile5">上传5</button>    

//方式5
$(".btnFile5").click(function () {
    $.ajax({
        url: "/Home/SaveFile4",
        type: "POST",
        data: $("#file5")[0].files[0],
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });;       
});       
     
后台代码：
public string SaveFile4()
{
    //这里发现只能得到一个网络流，没有其他信息了。（比如，文件大小、文件格式、文件名等）
    Request.SaveAs(Server.MapPath("~/App_Data/SaveFile4.data") + "", false);
    return "保存成功";
}
细心的你发现没有了表单格式，我们除了可以上传文件流数据外，不能再告诉后台其他信息了（如文件格式）。
到这里，我似乎明白了以前上传文件为什么非得要用个form包起来，原来这只是和后台约定的一个传输格式而已。
其实我们单纯的用jq的ajax传输文本数据的时候，最后也是组装成了form格式的数据，如：
 $.ajax({
    data: { "userName": "张三" } 
分片上传
在知道了上面的各种上传之后，我们是不是就满于现状了呢？no，很多时候我们需要传输大文件，一般服务器都会有一定的大小限制。
某天，你发现了一个激情小电影想要分享个大家。无奈，高清文件太大传不了，怎么办？我们可以化整为零，一部分一部分的传嘛，也就是所谓的分片上传。
前端代码：
<input type="file" id="file6" multiple>
<button type="button" class="btnFile6">分片上传6</button>
<div class="result"></div>

//方式6
 $(".btnFile6").click(function () { 
     var upload = function (file, skip) {
         var formData = new FormData();//初始化一个FormData对象
         var blockSize = 1000000;//每块的大小
         var nextSize = Math.min((skip + 1) * blockSize, file.size);//读取到结束位置             
         var fileData = file.slice(skip * blockSize, nextSize);//截取 部分文件 块
         formData.append("file", fileData);//将 部分文件 塞入FormData
         formData.append("fileName", file.name);//保存文件名字
         $.ajax({
             url: "/Home/SaveFile6",
             type: "POST",
             data: formData,
             processData: false,  // 告诉jQuery不要去处理发送的数据
             contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
             success: function (responseText) {
                 $(".result").html("已经上传了" + (skip + 1) + "块文件");
                 if (file.size <= nextSize) {//如果上传完成，则跳出继续上传
                     alert("上传完成");
                     return;
                 }
                 upload(file, ++skip);//递归调用
             }
         });
     };

     var file = $("#file6")[0].files[0];
     upload(file, 0);
 }); 

后台代码：
public string SaveFile6()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
相对而言，代码量多了一点，复杂了一点。不过相对于网上的其他分片上传的代码应该要简单得多（因为这里没有考虑多文件块同时上传、断点续传。那样就需要在后台把文件块排序，然后上传完成按序合并，然后删除原来的临时文件。有兴趣的同学可以自己试试，稍候在分析上传插件webuploader的时候也会实现）。
效果图：

【说明】：如果我们想要上传多个文件怎么办？其实H5中也提供了非常简单的方式。直接在input里面标记multiple，<input type="file" id="file6" multiple>，然后我们后台接收的也是一个数组Request.Files。
使用HTML5 拖拽、粘贴上传
只能说H5真是强大啊，权限越来越大，操作越来越牛逼。
前端代码（拖拽上传）：
<textarea class="divFile7" style="min-width:800px;height:150px" placeholder="请将文件拖拽或直接粘贴到这里"></textarea>
//方式7
 $(".divFile7")[0].ondrop = function (event) {

     event.preventDefault();//不要执行与事件关联的默认动作
     var files = event.dataTransfer.files;//获取拖上来的文件

     //以下代码不变
     var formData = new FormData();//初始化一个FormData对象
     formData.append("files", files[0]);//将文件塞入FormData
     $.ajax({
         url: "/Home/SaveFile2",
         type: "POST",
         data: formData,
         processData: false,  // 告诉jQuery不要去处理发送的数据
         contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
         success: function (responseText) {
             alert(responseText);
         }
     });
 };

后台代码：
略（和之前的SaveFile2一样）
前端代码（粘贴上传 限图片格式）：
//方式8
$(".divFile7")[0].onpaste = function (event) {
    event.preventDefault();//不要执行与事件关联的默认动作
    var clipboard = event.clipboardData.items[0];//剪贴板数据
    if (clipboard.kind == 'file' || clipboard.type.indexOf('image') > -1) {//判断是图片格式
        var imageFile = clipboard.getAsFile();//获取文件

        //以下代码不变
        var formData = new FormData;
        formData.append('files', imageFile);
        formData.append('fileName', "temp.png");//这里给文件命个名（或者直接在后台保存的时候命名）
        $.ajax({
            url: "/Home/SaveFile8",
            type: "POST",
            data: formData,
            processData: false,  // 告诉jQuery不要去处理发送的数据
            contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
            success: function (responseText) {
                alert(responseText);
            }
        });
    }
};

后台代码：
public string SaveFile8()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];      
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(filePath);
        return "保存成功";
    }
    return "没有读到文件";
}

效果图：

上传插件（WebUploader）
已经列举分析了多种上传文件的方式，我想总有一种适合你。不过，上传这个功能比较通用，而我们自己写的可能好多情况没有考虑到。接下来简单介绍下百度的WebUploader插件。
比起我们自己写的简单上传，它的优势：稳定、兼容性好（有flash切换，所以支持IE）、功能多、并发上传、断点续传（主要还是靠后台配合）。
官网：http://fex.baidu.com/webuploader/
插件下载：https://github.com/fex-team/webuploader/releases/download/0.1.5/webuploader-0.1.5.zip
下面开始对WebUploader的使用
第一种，简单粗暴
前端代码：
<div id="picker">选择文件</div>
<button id="ctlBtn" class="btn btn-default">开始上传</button>

<!--引用webuploader的js和css-->
<link href="~/Scripts/webuploader-0.1.5/webuploader.css" rel="stylesheet" />
<script src="~/Scripts/webuploader-0.1.5/webuploader.js"></script>
<script type="text/javascript">
    var uploader = WebUploader.create({

        // (如果是新浏览器 可以不用 flash)
        //swf: '/Scripts/webuploader-0.1.5/Uploader.swf',

        // 文件接收服务端。
        server: '/Webuploader/SaveFile',

        // 选择文件的按钮。可选。
        // 内部根据当前运行是创建，可能是input元素，也可能是flash.
        pick: '#picker'
    });

    $("#ctlBtn").click(function () {
        uploader.upload();
    });

    uploader.on('uploadSuccess', function (file) {
        alert("上传成功");
    });

</script>

后台代码：
public string SaveFile()
{
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
第二种，分片上传。和我们之前自己写的效果差不多。
前端代码：
var uploader = WebUploader.create({ 
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf', 
    // 文件接收服务端。
    server: '/Webuploader/SveFile2', 
    // 开起分片上传。
    chunked: true, 
    //分片大小
    chunkSize: 1000000, 
    //上传并发数
    threads: 1,
    // 选择文件的按钮。 
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    alert("上传成功");
});

后台代码：
public string SveFile2()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName);
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
我们看到了有个参数threads: 1上传并发数，如果我们改成大于1会怎样？前端会同时发起多个文件片上传。后台就会报错，多个进程同时操作一个文件。
那如果我们想要多线程上传怎么办？改代码吧（主要是后台逻辑）。
前端代码：
//并发上传（多线程上传）
var uploader = WebUploader.create({
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf',
    // 文件接收服务端。
    server: '/Webuploader/SveFile3',
    // 开起分片上传。
    chunked: true,
    //分片大小
    chunkSize: 1000000,
    //上传并发数
    threads: 10,
    // 选择文件的按钮。
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    //上传完成后，给后台发送一个合并文件的命令
    $.ajax({
        url: "/Webuploader/FileMerge",
        data: { "fileName": file.name },
        type: "post",
        success: function () {
            alert("上传成功");
        }
    });
});

后台代码：
public string SveFile3()
{
    var chunk = Request.Form["chunk"];//当前是第多少片 

    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(Request.Files
    if (!Directory.Exists(path))//判断是否存在此路径，如果不存在则创建
    {
        Directory.CreateDirectory(path);
    }
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = path + "/" + chunk;
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }           
    return "保存成功";
}
/// <summary>
/// 合并文件
/// </summary>
/// <param name="path"></param>
/// <returns></returns>
public bool FileMerge()
{
    var fileName = Request.Form["fileName"];
    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(fileName);

    //这里排序一定要正确，转成数字后排序（字符串会按1 10 11排序，默认10比2小）
    foreach (var filePath in Directory.GetFiles(path).OrderBy(t => int.Parse(Path.GetFileNameWithoutExtension(t))))
    {
        using (FileStream fs = new FileStream(Server.MapPath("~/App_Data/") + fileName, FileMode.Append, FileAccess.Write))
        {
            byte[] bytes = System.IO.File.ReadAllBytes(filePath);//读取文件到字节数组
            fs.Write(bytes, 0, bytes.Length);//写入文件
        }
        System.IO.File.Delete(filePath);
    }
    Directory.Delete(path);
    return true;
}
到这里你以为就结束了吗？错，还有好多情况没有考虑到。如果多个用户上传的文件名字一样会怎样？如何实现断点续传？还没实现选择多个文件？不过，这里不打算继续贴代码了（再贴下去，代码量越来越多了），自己也来练习练习吧。
提供一个思路，上传前先往数据库插入一条数据。数据包含文件要存的路径、文件名（用GUID命名，防止同名文件冲突）、文件MD5（用来识别下次续传和秒传）、临时文件块存放路径、文件是否完整上传成功等信息。
然后如果我们断网后再传，首先获取文件MD5值，看数据库里面有没上传完成的文件，如果有就实现秒传。如果没有，看是不是有上传了部分的。如果有接着传，如果没有则重新传一个新的文件。
总结
之前我一直很疑惑，为什么上传文件一定要用form包起来，现在算是大概明白了。
最开始在javascript还不流行时，我们就可以直接使用submit按钮提交表单数据了。表单里面可以包含文字和文件。然后随着js和ajax的流行，可以利用ajax直接异步提交部分表单数据。这里开始我就纠结了，为什么ajax可以提交自己组装的数据。那为什么不能直接提交文件呢。这里我错了，ajax提交的并不是随意的数据，最后还是组装成了表单格式（因为后台技术对表单格式数据的支持比较普及）。但是现有的技术还不能通过js组装一个文件格式的表单数据。直到H5中的FormData出现，让前端js组装一个包含文件的表单格式数据成为了可能。所以说表单只是为了满足和后台“约定”的数据格式而已。
 
相关推荐

http://www.cnblogs.com/fish-li/archive/2011/07/17/2108884.html
http://javascript.ruanyifeng.com/htmlapi/file.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/上传下载


article  8
title: 我们为什么应该坚持写博客
body: 
种种原因：
我们很多人都有过写点东西的冲动，只是又因为种种原因没有发表。

写着写着，挤不出字来了。
总感觉自己的内心想法表达不出来。
感觉写了没什么用，自己都明白了干嘛还要写。
怕写出来被人笑话被人喷。（这个也是我经常害怕的）
写博客的费脑力，耗时间。还不如拿这精力去再学更多的东西。

关于以上几点我的理解：

第一点：万事开头难，我们不管做什么事，最难的就是从零到一的过程。只要你跨过了，什么都是那么的自然。不管写的多差，你就要坚持，然后慢慢得就有了感觉。
第二点：从一个方面说明，我们的表达能力还不行（这正好可以锻炼我们的表达能力）。从另一方面也说明，你对这个问题或是知识点了解得还不够透彻。如果你知道了来龙去脉、前因后果不会说不清除的（借此我们可以更加深入的学习）。
第三点：写博客当然有用，不然那么多牛人为什么写博客。首先，人都有一个遗忘规律。现在你认为已经烂记于心的东西，几个月后说不定就模糊了。其实，很多时候我们都是在反复的记忆遗忘做斗争。不说别的，现在要你写个数据库ado连接你写得出来吗？现在要你写个原生的ajax你写得出来吗？其实，这都是我们读书的时候就写过好多遍的，不如工作中不是经常手动去写很可能现在就忘记了。然，我们写博客有效的加深记忆。万一，还是忘记了，我们查找自己的博客也是很快就能回忆起来的。（其实，我们很多时候都是在反复的在学以前学过的东西，如果我们能过目不忘以前所接触、所学过的，我们一定是牛人了）
第四点：笑就笑呗，哪个牛人不是从菜鸟过来的。我不写教程，我写笔记写心得总可以吧。喷子，是少不了的。就是世上的蚊子无法灭绝。（正好可以锻炼你强大的内心）
第五点：费脑力，确实。耗时间，也是。不过这是值得的。为什么这么说，不管做什么，都是要有付出的。（不过，在后期越写越顺，脑力和时间也就越用越少，就像平时说话那么自然）

好处多多：

可以结交更多的朋友。和同档次和高于你档次的人做朋友，你可以学到很多。（近朱者赤，同道的朋友会有一种暗自竞争的动力）
在我们博文写成，会有很多道友阅读。很多我们自己认为是对的，实际上是错误的东西、或是我们难以发现的错误，热心的道友会帮你指出。这是一个难得的成长机会。
在写博客的过程中，我们肯定会遇到这样或那样的疑问会去查资料。在这过程，我们可能会引发更多的知识或疑问。这个时候问题本身可能就不是那么重要的，引申出来的问题和知识带你会让我们学习到更多。
很多时候，我们也会有心或是无心帮到一些初学者或是遇到同样问题的人。在得到他人的感谢或是肯定的时候心里满满的美（或是虚荣心吧）。
通过博客轨迹，我们以后也可以看到自己的成长轨迹。我们都做过些什么，以后应该怎么做，以至于不忘初心，不迷失自己。
还有一点，也许不是那么明显。我觉得博客是一个非常好的简历。不仅可以看到你的技术水平，还可以看到你平时的关注内容、评论言辞，从而看出你的为人和人品。

我们应该怎样去写好博客：

首先，我们要么就不写要么用心写。也不是说一定要写得多么牛逼，起码用心了，我们就有长进。如果随意滥竽充数，那就真的是浪费时间了。用心了，也不一定就是好的博文，但是会慢慢的一篇篇的变成好的博文。
然后，我们需要假想观众。我们写出来的东西，总是会有人去读的，起码自己会读吧。所以，一定要以能让别人读懂为基础理念。然后就是怎样能让别人更加容易读懂。
想象我们的读者是个初学者。不要一开始，在认为自己懂了的前提直接写下结论。（就像注释一样，也许我们写代码的时候整个逻辑都清晰明了。不过几个后，就要把代码从头理解了。所以，我们必要的时候会标上注释。我们假想对象是初学者，那样我们以后看自己的博客也会马上进入状态理解以前是要表达的意思）。
我们在看某本书的时候就开始计划着，我应该怎样更好的把自己现在看的这节通过博文的方式表达出来，而让读者看得懂。（有个这个想法，你看书会更加的专心，会去了解其原理。而不是像有时候，似懂非懂的情况下继续接着看），我们通过博文形式记录自己的读书笔记，会要比只是把书浏览一遍，然后过几个月又忘记了，然后又去读，要好的多。

 
我注册博客园已经整整五年了，真正开始写博客也只是近一年的事情，以前没写也是因为上面的“种种原因”。然而，正是这一年，是我在程序员的这条道路上，成长最多最快也是这一年。也不是说写博客就真的会让你想开挂般成长。只是真的可以引发很多积极的东西，一些平时你不会去做的东西或者难以坚持的东西。（本人现在正在看《javascript高级程序设计》，并以博文笔记形式记下所读所解）
 
最后附上一副图，平时我群里群友闲聊时的镇群图。 （一图足以解释标题的疑问）

  

这是我个人对写博客的一点心得，每个写博客的人都有自己的心得，我这里列举出来的肯定不全，也有些是你并不认同的。但是，我相信还是有部分是正确有用的。道友们也可以在评论区，写下自己的一点心得，大家探讨探讨。
原文链接：http://www.cnblogs.com/zhaopei/p/4998937.html
如果本文引起了您的共鸣或是对您有点帮助，那么请您轻轻点个赞，鼓励下。

 

 
园友心得（评论）：
 五月的仓颉 
“就拿我自己来说，每次写博客的时候，我都会想到我的博客是面向网友们的，所以必须要非常严谨，一定不能把自己都想不明白的知识点就这么随意往博客上一放，每一句话都必须自己想清楚了才可以，每一个知识点必须自己弄懂了才会写上去。就像我博客里面的一篇Java代码性能优化的文章吧，在发表之前在我的草稿箱里面放了至少有半个月，不断思考、修改，结果在发表之后收到了一些的好评，也被广泛转载。现在，我自己的博客里面草稿箱里面还有9篇文章，只有完全搞懂了，才会发布出去。从这个角度说，对于一个用心写博客的人来说，写博客对于提升自己的严谨度、专业性是非常有帮助的，久而久之，你对于技术的态度也会潜移默化地变成你对于生活的态度。”
 
相关文章推荐：
《为什么要写技术博》：http://www.cnblogs.com/vamei/archive/2012/11/17/2774208.html
《为什么写技术博客对新人如此重要？》：http://blog.csdn.net/oiio/article/details/6913156
《为什么你应该（从现在开始就）写博客》：http://blog.csdn.net/pongba/article/details/3896311
《我为什么鼓励工程师写blog》：https://news.cnblogs.com/n/566179/
 
article  9
title: 《HiBlogs》重写笔记[1]--从DbContext到依赖注入再到自动注入
body: 
本篇文章主要分析DbContext的线程内唯一，然后ASP.NET Core的注入，再到实现自动注入。
DbContext为什么要线程内唯一（非线程安全）
我们在使用EF的时候，可能使用相关框架封装过了，也可能是自己直接使用DbContext。但是有没有想过怎么使用DbContext才是正确的姿势呢？
DbContext可以访问操作所有数据表、保持跟踪状态、SaveChanges统一提交等等强大的功能。我们会不会想，它的创建和销毁是否要付出昂贵的代价？
其实不是的，DataContext 是轻量的，创建它不需要很大的开销。
在EF6的DbContext文档 https://msdn.microsoft.com/zh-cn/library/system.data.entity.dbcontext(v=vs.113).aspx 最下面有句话 此类型的任何公共 static（在 Visual Basic 中为 Shared） 成员都是线程安全的。但不保证所有实例成员都是线程安全的。DbContext实例不保证线程安全。也就是说多线程同时操作一个DbContext实例，可能会有意想不到的问题。
比如我前面的文章 http://www.cnblogs.com/zhaopei/p/async_two.html 遇到的问题就是如此

之所以本地iis和iis express测试都是没问题，是因为本地访问速度快，没有并发。
更加极端点的体现，全局使用一个静态DbContext实例（之前我就这么想过）。
比如：线程a正在修改一个实体到一半，线程b给不小心保存了。线程c在修改一个实体，线程d又把这个实体不小心删了。这玩笑就开大了。并发越大，此类情况越多。所以DbContext实例只能被单个线程访问。还有，在执行异步的方法的时候切不可能自认为的“效率提升”同时发起多个异步查询。
当然，这也只是我个人认为可能存在的问题。不过你只要记住DbContext不是线程安全类型就够了。
如此，我们是不是应该每次数据操作都应该实例一个新的DbContext呢？也不尽然。比如方法a中的DbContext实例查询出实体修改跟踪，并把实体传入了方法b，而方法b是另外实例的DbContext，那么在方法b中就不能保存方法a传过来的实体了。如果非得这么做方法b中的DbContext也应该由方法a传过来。也就是说我们要的效果是线程内的DbContext实例唯一。
DbContext怎么做到线程内唯一（依赖注入）
在使用EF x时你可能是
public static BlogDbContext dbEntities
{
    get
    {
        DbContext dbContext = CallContext.GetData("dbContext") as DbContext;
        if (dbContext == null)
        {
            dbContext = new BlogDbContext();
             //将新创建的 ef上下文对象 存入线程
            CallContext.SetData("dbContext", dbContext);
         }
        return dbContext as BlogDbContext;
    }
}
而在EF Core中没有了CallContext。其实我们不需要CallContext，通过自带的注入框架就可以实现线程内唯一。
我们来写个demo
首先创建一个类库，通过注入得到DbContext。然后在web里面也注入一个DbContext，然后在web里面调用类库里面的方法。验证两个DbContext的GetHashCode()值是否一致。
类库内获取DbContext的HashCode
namespace DemoLibrary
{
    public class TempDemo
    {
        BloggingContext bloggingContext;
        public TempDemo(BloggingContext bloggingContext)
        {
            this.bloggingContext = bloggingContext;
        }
        //获取DbContext的HashCode
        public int GetDBHashCode()
        {
            return bloggingContext.GetHashCode();
        }
    }
}
然后在web里面也注入DbContext，并对比HashCode
public IActionResult Index()
{
    // 获取类库中的DbContext实例Code
    var code1 = tempDemo.GetDBHashCode();
    // 获取web启动项中DbContext实例Code
    var code2 = bloggingContext.GetHashCode();
    return View();
}
效果图：

由此可见通过注入得到的DbContext对象是同一个（起码在一个线程内是同一个）
另外，我们还可以反面验证通过new关键字实例DbContext对象在线程内不是同一个

为什么可以通过注入的方式得到线程内唯一（注入的原理）
这里不说注入的定义，也不说注入的好处有兴趣可查看。我们直接来模拟实现注入功能。
首先我们定义一个接口IUser和一个实现类User
public interface IUser
{
    string GetName();
}
public class User : IUser
{
    public string GetName()
    {
        return "农码一生";
    }
}
然后通过不同方式获取User实例

第一种不用说大家都懂的
第二种和第三种我们看到使用到了DI类（自己实现的一个简易注入"框架"），下面我们来看看DI类中的Resolve到底是个什么鬼
public class DI
{
    //通过反射 获取实例  并向上转成接口类型
    public static IUser Resolve(string name)
    {
        Assembly assembly = Assembly.GetExecutingAssembly();//获取当前代码的程序集
        return (IUser)assembly.CreateInstance(name);//这里写死了，创建实例后强转IUser
    }

    //通过反射 获取“一个”实现了此接口的实例
    public static T Resolve<T>()
    {
        Assembly assembly = Assembly.GetExecutingAssembly();
        //获取“第一个”实现了此接口的实例
        var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(typeof(T))).FirstOrDefault();
        if (type == null)
            throw new Exception("没有此接口的实现");
        return (T)assembly.CreateInstance(type.ToString());//创建实例 转成接口类型
    }
是不是想说“靠，这么简单”。简单的注入就这样简单的实现了。如果是相对复杂点的呢？比如我们经常会用到，构造注入里面的参数本身也需要注入。
比如我们再创建一个IUserService接口和一个UserService类
public interface IUserService
{
    IUser GetUser();
}

public class UserService : IUserService
{
    private IUser _user;
    public UserService(IUser user)
    {
        _user = user;
    }

    public IUser GetUser()
    {
        return _user;
    }
}
我们发现UserService的构造需要传入IUser，而IUser的实例使用也是需要注入IUser的实例。

这里需要思考的就是userService.GetUser()怎么可以得到IUser的实现类实例。所以，我们需要继续看Resolve2的具体实现了。
public static T Resolve2<T>()
{
    Assembly assembly = Assembly.GetExecutingAssembly();//获取当前代码的程序集
    //获取“第一个”实现了此接口的实例（UserService）
    var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(typeof(T))).FirstOrDefault();
    if (type == null)          
        throw new Exception("没有此接口的实现");
    
    var parameter = new List<object>();
    //type.GetConstructors()[0]获取第一个构造函数 GetParameters的所有参数（IUser接口）
    var constructorParameters = type.GetConstructors()[0].GetParameters();
    foreach (var constructorParameter in constructorParameters)
    {
        //获取实现了（IUser）这个接口类型（User）
        var tempType = assembly.GetTypes().Where(t => t.GetInterfaces()
                    .Contains(Type.GetType(constructorParameter.ParameterType.FullName)))
                    .FirstOrDefault();
        //并实例化成对象（也就是User实例） 添加到一个集合里面 供最上面（UserService）的注入提供参数 
        parameter.Add(assembly.CreateInstance(tempType.ToString()));
    }
    //创建实例，并传入需要的参数 【public UserService(IUser user)】
    return (T)assembly.CreateInstance(type.ToString(), true, BindingFlags.Default, null, parameter.ToArray(), null, null);//true：不区分大小写 
}
仔细看了也不难，就是稍微有点绕。
既然知道了注入的原理，那我们控制通过方法A注入创建实例每次都是重新创建、通过方法B创建的实例在后续参数使用相同的实例、通过方便C创建的实例全局单例，就不是难事了。
以下伪代码：
//每次访问都是新的实例(通过obj1_1、obj1_2可以体现)
public static T Transient<T>()
{
    //var obj1_1 = assembly.CreateInstance(name);
    //var obj2 = assembly.CreateInstance(obj1_1,...)
    //var obj1_2 = assembly.CreateInstance(name);
    //var obj3 = assembly.CreateInstance(obj1_2,...)
    //var obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
//一次请求中唯一实例(通过obj1可以体现)
public static T Scoped<T>()
{
    //var obj1 = assembly.CreateInstance(name);
    //var obj2 = assembly.CreateInstance(obj1,...)
    //var obj3 = assembly.CreateInstance(obj1,...)
    //var obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
//全局单例（通过obj1 == null可以体现）
public static T Singleton<T>()
{
    //if(obj1 == null)
    //  obj1 = assembly.CreateInstance(name);
    //if(obj2 == null)
    //  obj2 = assembly.CreateInstance(obj1,...)
    //if(obj3 == null)
    //  obj3 = assembly.CreateInstance(obj1,...)
    //if(obj4 == null)
    //  obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
通过伪代码，应该不难理解怎么通过注入框架实现一个请求内实现DbContext的唯一实例了吧。
同时也应该更加深刻的理解了ASP.NET Core中对应的AddScoped、AddTransient、AddSingleton这三个方法和生命周期了吧。
在ASP.NET Core中实现自动注入
不知道你有没有在使用AddScoped、AddTransient、AddSingleton这类方法的时候很烦。每次要使用一个对象都需要手动注入，每次都要到Startup.cs文件里面去做对应的修改。真是烦不胜烦。
使用过ABP的同学就有种感觉，那就是根本体会不到注入框架的存在。我们写的接口和实现都自动注入了。使用的时候直接往构造函数里面扔就好了。那我们在使用ASP.NET Core的时候很是不是也可以实现类似的功能呢？
答案是肯定的。我们先定义这三种生命周期的标识接口，这三个接口仅仅只是做标记作用。（名字你可以随意）
// 瞬时（每次都重新实例）
public interface ITransientDependency
//一个请求内唯一（线程内唯一）
public interface IScopedDependency
//单例（全局唯一）
public interface ISingletonDependency
我们以ISingletonDependency为例
/// 自动注入
/// </summary>
private void AutoInjection(IServiceCollection services, Assembly assembly)
{
    //获取标记了ISingletonDependency接口的接口
    var singletonInterfaceDependency = assembly.GetTypes()
            .Where(t => t.GetInterfaces().Contains(typeof(ISingletonDependency)))
            .SelectMany(t => t.GetInterfaces().Where(f => !f.FullName.Contains(".ISingletonDependency")))
            .ToList();
    //获取标记了ISingletonDependency接口的类
    var singletonTypeDependency = assembly.GetTypes()
            .Where(t => t.GetInterfaces().Contains(typeof(ISingletonDependency)))
            .ToList();
    //自动注入标记了 ISingletonDependency接口的 接口
    foreach (var interfaceName in singletonInterfaceDependency)
    {
        var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(interfaceName)).FirstOrDefault();
        if (type != null)
            services.AddSingleton(interfaceName, type);
    }
    //自动注入标记了 ISingletonDependency接口的 类
    foreach (var type in singletonTypeDependency)
    {             
        services.AddSingleton(type, type);
    }
然后在Startup.cs文件的ConfigureServices方法里调用下就好了
public void ConfigureServices(IServiceCollection services)
{
    var assemblyWeb = Assembly.GetExecutingAssembly();
    // 自动注入
    AutoInjection(services, assemblyApplication);
这样以后我们只要给某个接口和类定义了ISingletonDependency接口就会被自动单例注入了。是不是很酸爽！
什么？反射低效？别闹了，这只是在程序第一次启动的时候才运行的。
嗨-博客，的源代码就是如此实现。
当然，给你一个跑不起来的Demo是很痛苦的，没有对应源码的博文看起来更加痛苦。特别是总有这里或那里有些细节没注意，导致达不到和博文一样的效果。
所以我又另外重写了一个Demo。话说，我都这么体贴了你不留下赞了再走真的好吗？如果能在github上送我颗星星就再好不过了！
 
-------------------- 更新 -------------------------
基于园友对关于DbContext能不能单次请求内唯一？DbContex需不需要主动释放？：http://www.cnblogs.com/zhaopei/p/dispose-on-dbcontext.html
 
博文源码

嗨博客，基于ASP.NET COre 2.0的跨平台的免费开源博客 https://github.com/zhaopeiym/Hi-Blogs （求⭐⭐）
demo https://github.com/zhaopeiym/BlogDemoCode/tree/master/依赖注入/DIDemo

相关资料

http://www.cnblogs.com/hjf1223/archive/2010/10/10/static_datacontext.html

http://www.cnblogs.com/xishuai/p/ef-dbcontext-thread-safe.html


article  10
title: 关于DbContext能不能单次请求内唯一？DbContex需不需要主动释放？欢迎各路大侠来“参战”！
body: 
基于上篇文章《HiBlogs》重写笔记[1]--从DbContext到依赖注入再到自动注入园友 @Flaming丶淡蓝@ 吴瑞祥 提出了讨论和质疑，吓得我连夜查询资料（玩笑~）。
本来重点是想分析“自动注入”和对“注入”有更深的理解。不过既然有疑问和讨论那也是很好的。总比时不时来篇“这个不行”“那个要死了”的好。
之所以没有在评论区马上回复，是因为我确实不懂。所以下班后赶紧查阅相关资料。
我个人得出来的结论是：DbContext可以单次请求内唯一，且可以不主动释放。（其实当时心里也纳闷了。asp.net core就是这么干的啊，如果有问题还玩个毛线啊）
相关资料：http://blog.jongallant.com/2012/10/do-i-have-to-call-dispose-on-dbcontext/
这篇资料博客应该还是有一定的权威性的，内容是EF团队解释回应。
Hello Jon,
The default behavior of DbContext is that the underlying connection is automatically opened any time is needed and closed when it is no longer needed. E.g. when you execute a query and iterate over query results using “foreach”, the call to IEnumerable<T>.GetEnumerator() will cause the connection to be opened, and when later there are no more results available, “foreach” will take care of calling Dispose on the enumerator, which will close the connection. In a similar way, a call to DbContext.SaveChanges() will open the connection before sending changes to the database and will close it before returning.
Given this default behavior, in many real-world cases it is harmless to leave the context without disposing it and just rely on garbage collection.
That said, there are two main reason our sample code tends to always use “using” or dispose the context in some other way:
1. The default automatic open/close behavior is relatively easy to override: you can assume control of when the connection is opened and closed by manually opening the connection. Once you start doing this in some part of your code, then forgetting to dipose the context becomes harmful, because you might be leaking open connections.
2. DbContext implements IDiposable following the recommended pattern, which includes exposing a virtual protected Dispose method that derived types can override if for example the need to aggregate other unmanaged resources into the lifetime of the context.
By the way, with DbContext the pattern to open the connection manually and override the automatic open/close behavior is a bit awkward:
((IObjectContextAdapter)dbContext).ObjectContext.Connection.Open()
But we have a bug to make this easier as it used to be with ObjectContext before, e.g.:
dbContext.Database.Connection.Open()
Hope this helps,
Diego
谷歌翻译如下（英文不行，不知道翻译是否正确）：
乔恩，
DbContext的默认行为是底层连接在需要时自动打开，并在不再需要时关闭。例如，当您执行查询并使用“foreach”迭代查询结果时，对IEnumerable <T> .GetEnumerator（）的调用将导致打开连接，并且稍后再没有可用的结果，“foreach”将会关闭调用Dispose在枚举器上，这将关闭连接。以类似的方式，调用DbContext.SaveChanges（）将在将更改发送到数据库之前打开连接，并在返回之前关闭它。
鉴于这种默认行为，在许多现实世界的情况下，离开上下文而不处理它，只依靠垃圾回收是无害的。
也就是说，我们的示例代码往往总是使用“使用”或以其他方式处理上下文的两个主要原因：
1.默认的自动打开/关闭行为相对容易被覆盖：您可以通过手动打开连接来控制何时打开和关闭连接。一旦您在代码的某些部分开始执行此操作，那么忘记使用上下文会变得有害，因为您可能会泄露打开的连接。
2.DbContext根据推荐的模式实现IDiposable，其中包括暴露一个虚拟保护的Dispose方法，如果需要将其他非托管资源聚合到上下文的生命周期中，派生类型可以覆盖。
顺便说一下，用DbContext打开手动连接的模式，覆盖自动打开/关闭的行为有点尴尬：
（（IObjectContextAdapter）的DbContext）.ObjectContext.Connection.Open（）
但是，我们有一个错误，使之更容易，因为它曾经与ObjectContext之前，例如：
dbContext.Database.Connection.Open（）
希望这可以帮助，
迭戈
光说不练假把式，我们还是亲自来测试一下吧。
我们测试分两种情况：

1、主动释放DbContext
2、不释放DbContext
3、最好能用多线程模拟下并发
4、然后查看执行时数据库的连接数，和程序执行完之后数据库的连接数。

测试代码：
//模拟数据库的一些操作（为了相对真实，包含了新增、修改和查询）
private static void DbOperation(BloggingContext db)
{
    db.Blogs.Add(new Blog()
    {
        Rating = 1,
        Url = "www.i.haojima.net"
    });
    db.SaveChanges();

    db.Blogs.First().Url = "www.haojima.net";
    db.SaveChanges();

    foreach (var item in db.Blogs.Take(10).ToList())
    {
        Console.WriteLine("查询到的博客id：" + item.BlogId);
    }
}
条件输入：
static void Main(string[] args)
{
    Console.WriteLine("是否主动释放DbContext（y/n）");
    var yes = Console.ReadLine();
    Console.WriteLine("请输入模拟并发量");
    var number = Console.ReadLine();
    SemaphoreSlim _sem = new SemaphoreSlim(int.Parse(number));
循环代码：
var i = 0;
while (i <= 5000)
{
    Console.WriteLine("启动第" + i++ + "个线程");

    _sem.Wait();

    #region Thread
    new Thread(() =>
           {
               if (yes == "y")
               {
                   using (BloggingContext bloggingContext = new BloggingContext())//主动释放
                   {
                       DbOperation(bloggingContext);
                   }
               }
               else
               {
                   BloggingContext bloggingContext = new BloggingContext();//不释放
                   DbOperation(bloggingContext);
               }

           }).Start();
    #endregion

    _sem.Release();
查看连接数量（sql语句）：
SELECT count(1) AS '连接到EFCoreDemoDB2数据库的数量' FROM
[Master].[dbo].[SYSPROCESSES] WHERE [DBID] IN ( SELECT 
   [DBID]
FROM 
   [Master].[dbo].[SYSDATABASES]
WHERE 
   NAME='EFCoreDemoDB2'
)
操作截图如下（你也可以下载demo代码自行测试）：
主动释放、模拟200并发量


数据库看到的连接数最多的时候54个

不释放、模拟200并发量

数据库看到的连接数最多的时候56个

程序执行完成后，连接自动释放了

 
【技巧】：
我们使用ef或dbcontext的时候主要注意三个问题：

1、多个线程不能访问同一个dbcontext
2、同一个跟踪实体不能被多个dbcontext操作
3、如果查询数据不需要被修改，一定按需查询.select(t=>new Dto(){ })。最不济也要AsNoTracking().ToList()。
一般也就不会出现奇怪的问题了。

 
【注意】运行测试的时候用命令行执行或者“开始执行不调试”
demo：https://github.com/zhaopeiym/BlogDemoCode/tree/master/EFCoreDemo
当然，我也不知道这种测试是否合理。如果园友有更好的测试方式可以提供。欢迎大家交流。

article  11
title: 权限管理学习 一、ASP.NET Forms身份认证
body: 
说明：本文示例使用的VS2017和MVC5。
系统无论大小、牛逼或屌丝，一般都离不开注册、登录。那么接下来我们就来分析下用户身份认证。
简单实现登录、注销
以前在学习.net的时候不知道什么Forms身份认证，直接用session实现登录，效果也蛮好嘛。而且用户信息存在服务端，安全。
前端代码：
@if (string.IsNullOrWhiteSpace(ViewBag.UserName))
{
    <form action="/home/login1">
        <input type="text" name="userName" />
        <input type="submit" value="登录" />
    </form>
}
else
{
    <form action="/home/logout1">
        <div>当前用户已登录，登录名：@ViewBag.UserName</div>
        <input type="submit" value="退出" />
    </form>
}

后台代码：
public ActionResult Index()
{
    ViewBag.UserName = Session["userName"]?.ToString();           
    return View();
}       

public void Login1(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了     
        Session["userName"] = userName;
    else
        Session["userName"] = null;
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}

public void Logout1()
{
    Session["userName"] = null;
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
是不是，简单明了。想要自己扩展或是定制什么功能都非常好用。不过我们需要维护session。比如系统重新发布，或者iis被自动重启。就会出现session丢失的情况。也就是用户会莫名其妙提升需要重新登录。体验非常不好。（这里先不讨论session服务和数据库的情况）。既然微软有一套成熟的权限管理我们为什么不用呢？
Forms认证登录、注销
首先在web.config里开启Forms身份认证：
<system.web>
  <authentication mode="Forms"></authentication>
后台代码：
public void Login2(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了
        FormsAuthentication.SetAuthCookie(userName, true); //登录
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}

public void Logout2()
{
    FormsAuthentication.SignOut();//登出
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
前台代码：
@if (!Request.IsAuthenticated)
{
    <form action="/home/login2">
        <input type="text" name="userName" />
        <input type="submit" value="登录" />
    </form>
}
else
{
    <form action="/home/logout2">
        <div>当前用户已登录，登录名：@Context.User.Identity.Name</div>
        <input type="submit" value="退出" />
    </form>
}
如此几句代码就实现了我们的登录和注销。和我们自己用session管理登录不同。Forms身份认证是直接把信息存cookie到浏览器的。通过SetAuthCookie这个方法名也可以看出来。不过Cookie信息经过了加密。
这里有必要说明session和cookie的关系。当我们利用session来维持用户状态的时候，其实也用到了cookie。

然而Forms身份认证仅仅只是把信息存了cookie，而没有在服务端维护一个对应的session。
不信你可以测试。可以用两种方式都登录，然后清除session就可以测出来了。（怎么清session?重启iis，或者修改下后台代码在重新编译访问）
【说明】用户认证为什么要存cookie？因为HTTP是一个无状态的协议。对于服务器来说，每次请求都是一样的。所以，只能通过每次请求带的cookie来识别用户了。(暂时不考虑其他方式)
自定义的身份认证标识
上面使用的登录很简单，但实际情况往往很复杂。明显正常业务需要存的用户信息会要更多。那么我们是否可以扩展身份标识呢？答案是肯定的。
后台代码：
public void Login3(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了     
    {
        UserInfo user = new UserInfo()
        {
            Name = userName,
            LoginTime = DateTime.Now
        };
        //1、序列化要保存的用户信息
        var data = JsonConvert.SerializeObject(user);

        //2、创建一个FormsAuthenticationTicket，它包含登录名以及额外的用户数据。
        FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(2, userName, DateTime.Now, DateTime.Now.AddDays(1), true, data);

        //3、加密保存
        string cookieValue = FormsAuthentication.Encrypt(ticket);

        // 4. 根据加密结果创建登录Cookie
        HttpCookie cookie = new HttpCookie(FormsAuthentication.FormsCookieName, cookieValue);
        cookie.HttpOnly = true;
        cookie.Secure = FormsAuthentication.RequireSSL;
        cookie.Domain = FormsAuthentication.CookieDomain;
        cookie.Path = FormsAuthentication.FormsCookiePath;

        // 5. 写登录Cookie
        Response.Cookies.Remove(cookie.Name);
        Response.Cookies.Add(cookie);
    }
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
然后在Global.asax的Application_AuthenticateRequest方法：
protected void Application_AuthenticateRequest()
{
    GetUserInfo();
}

//通过coolie解密 读取用户信息到 HttpContext.Current.User
public void GetUserInfo()
{
    // 1. 读登录Cookie
    HttpCookie cookie = Request.Cookies[FormsAuthentication.FormsCookieName];

    try
    {
        UserInfo userData = null;
        // 2. 解密Cookie值，获取FormsAuthenticationTicket对象
        FormsAuthenticationTicket ticket = FormsAuthentication.Decrypt(cookie.Value);

        if (ticket != null && string.IsNullOrEmpty(ticket.UserData) == false)
            // 3. 还原用户数据
            userData = JsonConvert.DeserializeObject<UserInfo>(ticket.UserData);

        if (ticket != null && userData != null)
            // 4. 构造我们的MyFormsPrincipal实例，重新给context.User赋值。
            HttpContext.Current.User = new MyFormsPrincipal<UserInfo>(ticket, userData);
    }
    catch { /* 有异常也不要抛出，防止攻击者试探。 */ }
}
前端代码：
@{
    MyFormsPrincipal<UserInfo> user = Context.User as MyFormsPrincipal<UserInfo>;
    if (user == null)
    {
        <form action="/home/login3">
            <input type="text" name="userName" />
            <input type="submit" value="登录" />
        </form>
    }
    else
    {

        <form action="/home/logout2">
            <div>当前用户已登录，登录名：@Context.User.Identity.Name</div>
            <div>当前用户已登录，登录时间：@user.UserData.LoginTime</div>
            <input type="submit" value="退出" />
        </form>
    }
}
其实整个过程和FormsAuthentication.SetAuthCookie(userName, true); //登录是等效的。只是我们通过扩展，存了我们想要存储的数据。
过程也比较简单：

构造要存储的数据
序列化
把序列化信息放入FormsAuthenticationTicket对象
通过FormsAuthentication.Encrypt加密对象
发送cookie到浏览器

这里稍微复杂点的地方就是解密然后给User赋值HttpContext.Current.User = new MyFormsPrincipal<UserInfo>(ticket, userData);。
MyFormsPrincipal需要实现接口MyFormsPrincipal
public class MyFormsPrincipal<TUserData> : IPrincipal where TUserData : class, new()
{
    private IIdentity _identity;
    private TUserData _userData;

    public MyFormsPrincipal(FormsAuthenticationTicket ticket, TUserData userData)
    {
        if (ticket == null)
            throw new ArgumentNullException("ticket");
        if (userData == null)
            throw new ArgumentNullException("userData");

        _identity = new FormsIdentity(ticket);
        _userData = userData;
    }

    public TUserData UserData
    {
        get { return _userData; }
    }

    public IIdentity Identity
    {
        get { return _identity; }
    }

    public bool IsInRole(string role)//这里暂时不实现
    {
        return false;
    }
}
倒也没有什么特别，就是实例化的时候传入票据和自定义数据就好了。
授权
有了登录一般都离不开授权。微软的东西好就好在，一般都是成套成套的。
[Authorize]
public ActionResult LoginOk()
{
    return View();
}
直接给Action添加一个Authorize特性就好了，这人就会自动检查是否登录。如果没有登录自动跳转到登录页面。登录页面的设置还是在web.config里面
<system.web>
  <authentication mode="Forms" >
    <forms loginUrl="/home/index"></forms>
这种简单的授权验证明显是不够的。很多时候某些页面只有某些人才能访问。比如VIP。那么我们又要扩展了。
//继承 AuthorizeAttribute
public class MyAuthorizeAttribute : AuthorizeAttribute
{
    public override void OnAuthorization(AuthorizationContext filterContext)
    {
        if (filterContext.HttpContext.User.Identity.Name != "农码一生")
        {
            filterContext.HttpContext.Response.Write("您不是vip用户，不能访问机密数据");
            filterContext.HttpContext.Response.End();
            return;
        }
        base.OnAuthorization(filterContext);
    }
}
[MyAuthorize]
public ActionResult LoginVIP()
{
    return View();
}
是的，就是这么简单。说了这么多，来张效果图吧：

 
推荐阅读：

http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html
Demo：
https://github.com/zhaopeiym/BlogDemoCode/tree/master/权限管理/1-Forms身份认证


article  12
title: 浅析C#中单点登录的原理和使用
body: 
什么是单点登录？
我想肯定有一部分人“望文生义”的认为单点登录就是一个用户只能在一处登录，其实这是错误的理解（我记得我第一次也是这么理解的）。
单点登录指的是多个子系统只需要登录一个，其他系统不需要登录了（一个浏览器内）。一个子系统退出，其他子系统也全部是退出状态。
如果你还是不明白，我们举个实际的例子把。比如博客园首页：https://www.cnblogs.com，和博客园的找找看http://zzk.cnblogs.com。这就是两个系统（不同的域名）。如果你登录其中一个，另一个也是登录状态。如果你退出一个，另一个也是退出状态了。
那么这是怎么实现的呢？这就是我们今天要分析的问题了。
单点登录(SSO)原理

首先我们需要一个认证中心(Service)，和两个子系统(Client)。

当浏览器第一次访问Client1时，处于未登录状态 -> 302到认证中心(Service) -> 在Service的登录页面登录(写入Cookie记录登录信息) -> 302到Client1(写入Cookie记录登录信息)
第二次访问Client1 -> 读取Client1中Cookie登录信息 -> Client1为登录状态

第一次访问Client2 -> 读取Client2中Cookie中的登录信息 -> Client2为未登录状态 -> 302到在Service(读取Service中的Cookie为登录状态) -> 302到Client2(写入Cookie记录登录信息)

我们发现在访问Client2的时候，中间时间经过了几次302重定向，并没有输入用户名密码去登录。用户完全感觉不到，直接就是登录状态了。
图解：

手撸一个SSO
环境：.NET Framework 4.5.2
Service：
/// <summary>
/// 登录
/// </summary>
/// <param name="name"></param>
/// <param name="passWord"></param>
/// <param name="backUrl"></param>
/// <returns></returns>
[HttpPost]
public string Login(string name, string passWord, string backUrl)
{
    if (true)//TODO：验证用户名密码登录
    {
        //用Session标识会话是登录状态
        Session["user"] = "XX已经登录";
        //在认证中心 保存客户端Client的登录认证码
        TokenIds.Add(Session.SessionID, Guid.NewGuid());
    }
    else//验证失败重新登录
    {
        return "/Home/Login";
    }
    return backUrl + "?tokenId=" + TokenIds[Session.SessionID];//生成一个tokenId 发放到客户端
}
Client：
public static List<string> Tokens = new List<string>();
public async Task<ActionResult> Index()
{
    var tokenId = Request.QueryString["tokenId"];
    //如果tokenId不为空，则是由Service302过来的。
    if (tokenId != null)
    {
        using (HttpClient http = new HttpClient())
        {
            //验证Tokend是否有效
            var isValid = await http.GetStringAsync("http://localhost:8018/Home/TokenIdIsValid?tokenId=" + tokenId);
            if (bool.Parse(isValid.ToString()))
            {
                if (!Tokens.Contains(tokenId))
                {
                    //记录登录过的Client (主要是为了可以统一登出)
                    Tokens.Add(tokenId);
                }
                Session["token"] = tokenId;
            }
        }
    }
    //判断是否是登录状态
    if (Session["token"] == null || !Tokens.Contains(Session["token"].ToString()))
    {
        return Redirect("http://localhost:8018/Home/Verification?backUrl=http://localhost:26756/Home");
    }
    else
    {
        if (Session["token"] != null)
            Session["token"] = null;
    }
    return View();
}
效果图：

当然，这只是用较少的代码撸了一个较简单的SSO。仅用来理解，勿用于实际应用。
IdentityServer4实现SSO
环境：.NET Core 2.0
上面我们手撸了一个SSO，接下来我们看看.NET里的IdentityServer4怎么来使用SSO。
首先建一个IdentityServer4_SSO_Service(MVC项目)，再建两个IdentityServer4_SSO_Client(MVC项目)
在Service项目中用nuget导入IdentityServer4 2.0.2、IdentityServer4.AspNetIdentity 2.0.0、IdentityServer4.EntityFramework 2.0.0
在Client项目中用nuget导入IdentityModel 2.14.0
然后分别设置Service和Client项目启动端口为 5001(Service)、5002(Client1)、5003(Client2)

在Service中新建一个类Config：
public class Config
{        
    public static IEnumerable<IdentityResource> GetIdentityResources()
        {
            return new List<IdentityResource>
            {
                new IdentityResources.OpenId(),
                new IdentityResources.Profile(),
            };
        }

    public static IEnumerable<ApiResource> GetApiResources()
    {
        return new List<ApiResource>
        {
            new ApiResource("api1", "My API")
        };
    }

    // 可以访问的客户端
    public static IEnumerable<Client> GetClients()
        {           
            return new List<Client>
            {               
                // OpenID Connect hybrid flow and client credentials client (MVC)
                //Client1
                new Client
                {
                    ClientId = "mvc1",
                    ClientName = "MVC Client1",
                    AllowedGrantTypes = GrantTypes.HybridAndClientCredentials,
                    RequireConsent = true,
                    ClientSecrets =
                    {
                        new Secret("secret".Sha256())
                    },
                    RedirectUris = { "http://localhost:5002/signin-oidc" }, //注意端口5002 是我们修改的Client的端口
                    PostLogoutRedirectUris = { "http://localhost:5002/signout-callback-oidc" },
                    AllowedScopes =
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        "api1"
                    },
                    AllowOfflineAccess = true
                },
                 //Client2
                new Client
                {
                    ClientId = "mvc2",
                    ClientName = "MVC Client2",
                    AllowedGrantTypes = GrantTypes.HybridAndClientCredentials,
                    RequireConsent = true,
                    ClientSecrets =
                    {
                        new Secret("secret".Sha256())
                    },
                    RedirectUris = { "http://localhost:5003/signin-oidc" },
                    PostLogoutRedirectUris = { "http://localhost:5003/signout-callback-oidc" },
                    AllowedScopes =
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        "api1"
                    },
                    AllowOfflineAccess = true
                }
            };
        }
}
新增一个ApplicationDbContext类继承于IdentityDbContext：
public class ApplicationDbContext : IdentityDbContext<IdentityUser>
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    } 
    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);
    }
}
在文件appsettings.json中配置数据库连接字符串：
"ConnectionStrings": {
    "DefaultConnection": "Server=(local);Database=IdentityServer4_Demo;Trusted_Connection=True;MultipleActiveResultSets=true"
  }
在文件Startup.cs的ConfigureServices方法中增加:
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<ApplicationDbContext>(options =>
       options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); //数据库连接字符串
    services.AddIdentity<IdentityUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();

    services.AddMvc();

    string connectionString = Configuration.GetConnectionString("DefaultConnection");
    var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name;
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddAspNetIdentity<IdentityUser>() 
        .AddConfigurationStore(options =>
        {
            options.ConfigureDbContext = builder =>
                builder.UseSqlServer(connectionString,
                    sql => sql.MigrationsAssembly(migrationsAssembly));
        })
        .AddOperationalStore(options =>
        {
            options.ConfigureDbContext = builder =>
                builder.UseSqlServer(connectionString,
                    sql => sql.MigrationsAssembly(migrationsAssembly));
            options.EnableTokenCleanup = true;
            options.TokenCleanupInterval = 30;
        });
}
并在Startup.cs文件里新增一个方法InitializeDatabase（初始化数据库）：
/// <summary>
/// 初始数据库
/// </summary>
/// <param name="app"></param>
private void InitializeDatabase(IApplicationBuilder app)
{
    using (var serviceScope = app.ApplicationServices.GetService<IServiceScopeFactory>().CreateScope())
    {
        serviceScope.ServiceProvider.GetRequiredService<ApplicationDbContext>().Database.Migrate();//执行数据库迁移
        serviceScope.ServiceProvider.GetRequiredService<PersistedGrantDbContext>().Database.Migrate();

        var context = serviceScope.ServiceProvider.GetRequiredService<ConfigurationDbContext>();
        context.Database.Migrate();
        if (!context.Clients.Any())
        {
            foreach (var client in Config.GetClients())//循环添加 我们直接添加的 5002、5003 客户端
            {
                context.Clients.Add(client.ToEntity());
            }
            context.SaveChanges();
        } 
        if (!context.IdentityResources.Any())
                {
                    foreach (var resource in Config.GetIdentityResources())
                    {
                        context.IdentityResources.Add(resource.ToEntity());
                    }
                    context.SaveChanges();
                } 
        if (!context.ApiResources.Any())
                {
                    foreach (var resource in Config.GetApiResources())
                    {
                        context.ApiResources.Add(resource.ToEntity());
                    }
                    context.SaveChanges();
                }
    }
}
修改Configure方法：
 public void Configure(IApplicationBuilder app, IHostingEnvironment env)
 {
     //初始化数据
     InitializeDatabase(app);
     if (env.IsDevelopment())
     {
         app.UseDeveloperExceptionPage();
         app.UseBrowserLink();
         app.UseDatabaseErrorPage();
     }
     else
     {
         app.UseExceptionHandler("/Home/Error");
     }
     app.UseStaticFiles();
     app.UseIdentityServer();
     app.UseMvc(routes =>
     {
         routes.MapRoute(
             name: "default",
             template: "{controller=Home}/{action=Index}/{id?}");
     });
 }
然后新建一个AccountController控制器，分别实现注册、登录、登出等。
新建一个ConsentController控制器用于Client回调。
然后在Client的Startup.cs类里修改ConfigureServices方法：
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
    services.AddAuthentication(options =>
    {
        options.DefaultScheme = "Cookies";
        options.DefaultChallengeScheme = "oidc";
    }).AddCookie("Cookies").AddOpenIdConnect("oidc", options =>
    {
        options.SignInScheme = "Cookies";
        options.Authority = "http://localhost:5001";
        options.RequireHttpsMetadata = false;
        options.ClientId = "mvc2";
        options.ClientSecret = "secret";
        options.ResponseType = "code id_token";
        options.SaveTokens = true;
        options.GetClaimsFromUserInfoEndpoint = true;
        options.Scope.Add("api1");
        options.Scope.Add("offline_access");
    });
}

对于Client的身份认证就简单了：
[Authorize]//身份认证
public IActionResult Index()
{
    return View();
}

/// <summary>
/// 登出
/// </summary>
/// <returns></returns>
public async Task<IActionResult> Logout()
{
    await HttpContext.SignOutAsync("Cookies");
    await HttpContext.SignOutAsync("oidc");
    return View("Index");
}
效果图：

 
 
源码地址（demo可配置数据库连接后直接运行）

https://github.com/zhaopeiym/BlogDemoCode/tree/master/sso(%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95)

推荐阅读

http://www.cnblogs.com/ywlaker/p/6113927.html
https://identityserver4.readthedocs.io/en/release


article  13
title: C#单元测试，带你快速入门
body: 
注：本文示例环境

VS2017
XUnit 2.2.0 单元测试框架
xunit.runner.visualstudio 2.2.0 测试运行工具
Moq 4.7.10 模拟框架

为什么要编写单元测试
对于为什么要编写单元测试，我想每个人都有着自己的理由。对于我个人来说，主要是为了方便修改（bug修复）而不引入新的问题。可以放心大胆的重构，我认为重构觉得是提高代码质量和提升个人编码能力的一个非常有用的方式。好比一幅名画一尊雕像，都是作者不断重绘不断打磨出来的，而优秀的代码也需要不断的重构。
当然好处不仅仅如此。TDD驱动，使代码更加注重接口，迫使代码减少耦合，使开发人员一开始就考虑面对各种情况编写代码，一定程度的保证的代码质量，通过测试方法使后续人员快速理解代码...等。
额，至于不写单元测试的原因也有很多。原因无非就两种：懒、不会。当然你还会找更多的理由的。
框架选型
至于框架的选型。其实本人并不了解也没写过单元测试，这算是第一次真正接触吧。在不了解的情况下怎么选型呢？那就是看哪个最火、用的人多就选哪个。起码出了问题也容易同别人交流。

单元测试框架：XUnit 2.2.0。asp.net mvc就是用的这个，此内框架还有：NUnit、MSTest等。
测试运行工具：xunit.runner.visualstudio 2.2.0。类似如：Resharper的xUnit runner插件。
模拟框架：Moq 4.7.10。 asp.net mvc、Orchard使用了。此类框架还有：RhinoMocks、NSubstitute、FakeItEasy等。

基本概念

AAA逻辑顺序

准备（Arrange)对象，创建对象，进行必要的设置


操作（Act）对象


断言（Assert）某件事情是预期的。

Assert(断言)：对方法或属性的运行结果进行检测
Stub(测试存根\桩对象)：用返回指定结果的代码替换方法（去伪造一个方法,阻断对原来方法的调用，为了让测试对象可以正常的执行）
Mock(模拟对象)：一个带有期望方法被调用的存根（可深入的模拟对象之间的交互方式，如：调用了几次、在某种情况下是否会抛出异常。mock是一种功能丰富的stub）
Stub和Mock的定义比较抽象不好理解，延伸阅读1、阅读2、阅读3

好的测试

测试即文档
无限接近言简意赅的自然化语言
测试越简明越好，每个测试只关注一个点。
好的测试足够快,测试易于编写，减少依赖
好的测试应该相互隔离，不依赖于别的测试，不依赖于外部资源
可描述的命名：UnitOfWorkName_ScenarioUnderTest_ExpectedBehavior（命名可团队约定，我甚至觉得中文命名也没什么不可以的）

UnitOfWorkName　　被测试的方法、一组方法或者一组类


Scenario　　测试进行的假设条件，例如“登入失败”，“无效用户”或“密码正确”等


ExpectedBehavior　　在测试场景指定的条件下，你对被测试方法行为的预期　　


基础实践
“废话”说的够多了，下面撸起袖子开干吧。
下面开始准备工作：

vs2017新建一个空项目 UnitTestingDemo
新建类库 TestDemo （用于编写被测试的类）
新建类库 TestDemo.Tests （用于编写单元测试）
对类库 TestDemo.Tests 用nuget 安装XUnit 2.2.0、xunit.runner.visualstudio 2.2.0、Moq 4.7.10。

添加 TestDemo.Tests 对 TestDemo 的引用。

例：
public class Arithmetic
{
    public int Add(int nb1, int nb2)
    {
        return nb1 + nb2;
    }
}
对应的单元测试：（需要导入using Xunit;命名空间。 ）
public class Arithmetic_Tests
{
    [Fact]//需要在测试方法加上特性Fact
    public void Add_Ok()
    {
        Arithmetic arithmetic = new Arithmetic();
        var sum = arithmetic.Add(1, 2);
        
        Assert.True(sum == 3);//断言验证
    }
}
一个简单的测试写好了。由于我们使用的vs2017 它出了一个新的功能“Live Unit Testing”,我们可以启用它进行实时的测试。也就是我们编辑单元测试，然后保存的时候，它会自动生成自动测试，最后得出结果。


我们看到了验证通过的绿色√。
注意到测试代码中的参数和结果都写死了。如果我们要对多种情况进行测试，岂不是需要写多个单元测试方法或者进行多次方法执行和断言。这也太麻烦了。在XUnit框架中为我们提供了Theory特性。使用如下：
例：
[Theory]
[InlineData(2, 3, 5)]
[InlineData(2, 4, 6)]
[InlineData(2, 1, 3)] //对应测试方法的形参
public void Add_Ok_Two(int nb1, int nb2, int result)
{
    Arithmetic arithmetic = new Arithmetic();
    var sum = arithmetic.Add(nb1, nb2);
    Assert.True(sum == result);
}

测试了正确的情况，我们也需要测试错误的情况。达到更好的覆盖率。
例：
[Theory]
[InlineData(2, 3, 0)]
[InlineData(2, 4, 0)]
[InlineData(2, 1, 0)] 
public void Add_No(int nb1, int nb2, int result)
{
    Arithmetic arithmetic = new Arithmetic();
    var sum = arithmetic.Add(nb1, nb2);
    Assert.False(sum == result);
}
有时候我们需要确定异常
例：
public int Divide(int nb1, int nb2)
{
    if (nb2==0)
    {
        throw new Exception("除数不能为零");
    }
    return nb1 / nb2;
}
[Fact]      
public void Divide_Err()
{
    Arithmetic arithmetic = new Arithmetic(); 
    Assert.Throws<Exception>(() => { arithmetic.Divide(4, 0); });//断言 验证异常
}

以上为简单的单元测试。接下来，我们讨论更实际更真实的。
我们一般的项目都离不开数据库操作，下面就来实践下对EF使用的测试：

使用nuget安装 EntityFramework 5.0.0

例：
public class StudentRepositories
{
    //...
    public void Add(Student model)
    {
        db.Set<Student>().Add(model);
        db.SaveChanges();
    }
}
[Fact]
public void Add_Ok()
{
    StudentRepositories r = new StudentRepositories();
    Student student = new Student()
    {
        Id = 1,
        Name = "张三"
    };
    r.Add(student);

    var model = r.Students.Where(t => t.Name == "张三").FirstOrDefault();
    Assert.True(model != null);           
}
我们可以看到我们操作的是EF连接的实际库。（注意：要改成专用的测试库）
我们会发现，每测试一次都会产生对应的垃圾数据，为了避免对测试的无干扰性。我们需要对每次测试后清除垃圾数据。
//注意：测试类要继承IDisposable接口
public void Dispose()
{
 StudentRepositories r = new StudentRepositories();
 var models = r.Students.ToList();
 foreach (var item in models)
 {
     r.Delete(item.Id);
 }
}
这样每执行一个测试方法就会对应执行一次Dispose，可用来清除垃圾数据。
我们知道对数据库的操作是比较耗时的，而单元测试的要求是尽可能的减少测试方法的执行时间。因为单元测试执行的比较频繁。基于前面已经对数据库的实际操作已经测试过了，所以我们在后续的上层操作使用Stub(存根)来模拟，而不再对数据库进行实际操作。
例：
我们定义一个接口IStudentRepositories 并在StudentRepositories 继承。
 public interface IStudentRepositories
 {
     void Add(Student model);
 }
 public class StudentRepositories: IStudentRepositories
 {
    //省略。。。 （还是原来的实现）
 }   
public class StudentService
{
    IStudentRepositories studentRepositories;
    public StudentService(IStudentRepositories studentRepositories)
    {
        this.studentRepositories = studentRepositories;
    }
    public bool Create(Student student)
    {
        studentRepositories.Add(student);

        return true;
    }
}
新建一个类，用来测试。这个Create会使用仓储操作数据库。这里不希望实际操作数据库，以达到快速测试执行。
[Fact]
public void Create_Ok()
{
    IStudentRepositories studentRepositories = new StubStudentRepositories();
    StudentService service = new StudentService(studentRepositories);
    var isCreateOk = service.Create(null);
    Assert.True(isCreateOk);
}

public class StubStudentRepositories : IStudentRepositories
{
    public void Add(Student model)
    {
    }
}

图解：

每次做类似的操作都要手动建议StubStudentRepositories存根，着实麻烦。好在Mock框架（Moq）可以自动帮我们完成这个步骤。
例：
[Fact]
public void Create_Mock_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    StudentService service = new StudentService(studentRepositories.Object);
    var isCreateOk = service.Create(null);
    Assert.True(isCreateOk);
}
相比上面的示例，是不是简化多了。起码代码看起来清晰了，可以更加注重测试逻辑。

下面接着来看另外的情况，并且已经通过了测试
public class Notiy
{
    public bool Info(string messg)
    {
        //发送消息、邮件发送、短信发送。。。
        //.........
        if (string.IsNullOrWhiteSpace(messg))
        {
            return false;
        }
        return true;
    }
}
public class Notiy_Tests
{
    [Fact]
    public void Info_Ok()
    {
        Notiy notiy = new Notiy();
        var isNotiyOk = notiy.Info("消息发送成功");
        Assert.True(isNotiyOk);
    }
}
现在我们接着前面的Create方法加入消息发送逻辑。
public bool Create(Student student)
{
    studentRepositories.Add(student);

    var isNotiyOk = notiy.Info("" + student.Name);//消息通知

    //其他一些逻辑
    return isNotiyOk;
}
[Fact]
public void Create_Mock_Notiy_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    StudentService service = new StudentService(studentRepositories.Object, notiy.Object);
    var isCreateOk = service.Create(new Student());
    Assert.True(isCreateOk);
}
而前面我们已经对Notiy进行过测试了，接下来我们不希望在对Notiy进行耗时操作。当然，我们可以通过上面的Mock框架来模拟。这次和上面不同，某些情况我们不需要或不想写对应的接口怎么来模拟？那就使用另外一种方式把要测试的方法virtual。
例：
public virtual bool Info(string messg)
{
    //发送消息、邮件发送、短信发送。。。
    //.........
    if (string.IsNullOrWhiteSpace(messg))
    {
        return false;
    }
    return true;
}
测试如下
[Fact]
public void Create_Mock_Notiy_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    notiy.Setup(f => f.Info(It.IsAny<string>())).Returns(true);//【1】
    StudentService service = new StudentService(studentRepositories.Object, notiy.Object);
    var isCreateOk = service.CreateAndNotiy(new Student());
    Assert.True(isCreateOk);
}
我们发现了标注【1】处的不同，这个代码的意思是，执行模拟的Info方法返回值为true。参数It.IsAny() 是任意字符串的意思。
当然你也可以对不同参数给不同的返回值：
notiy.Setup(f => f.Info("")).Returns(false);
notiy.Setup(f => f.Info("消息通知")).Returns(true);
有时候我们还需要对private方法进行测试

使用nuget 安装 MSTest.TestAdapter 1.1.17
使用nuget 安装 MSTest.TestFramework 1.1.17

例：
private bool XXXInit()
{
    return true;
}
[Fact]
public void XXXInit_Ok()
{
    var studentRepositories = new StudentService();
    var obj = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject(studentRepositories);
    Assert.True((bool)obj.Invoke("XXXInit"));
}
如果方法有参数，接着Invoke后面传入即可。
好了，就说这么多吧。只能说测试的内容还真多，想要一篇文章说完是不可能的。但希望已经带你入门了。
附录
xUnit(2.0) 断言 (来源)

Assert.Equal() 验证两个参数是否相等，支持字符串等常见类型。同时有泛型方法可用，当比较泛型类型对象时使用默认的IEqualityComparer实现，也有重载支持传入IEqualityComparer
Assert.NotEqual() 与上面的相反
Assert.Same() 验证两个对象是否同一实例，即判断引用类型对象是否同一引用
Assert.NotSame() 与上面的相反
Assert.Contains() 验证一个对象是否包含在序列中，验证一个字符串为另一个字符串的一部分
Assert.DoesNotContain() 与上面的相反
Assert.Matches() 验证字符串匹配给定的正则表达式
Assert.DoesNotMatch() 与上面的相反
Assert.StartsWith() 验证字符串以指定字符串开头。可以传入参数指定字符串比较方式
Assert.EndsWith() 验证字符串以指定字符串结尾
Assert.Empty() 验证集合为空
Assert.NotEmpty() 与上面的相反
Assert.Single() 验证集合只有一个元素
Assert.InRange() 验证值在一个范围之内，泛型方法，泛型类型需要实现IComparable，或传入IComparer
Assert.NotInRange() 与上面的相反
Assert.Null() 验证对象为空
Assert.NotNull() 与上面的相反
Assert.StrictEqual() 判断两个对象严格相等，使用默认的IEqualityComparer对象
Assert.NotStrictEqual() 与上面相反
Assert.IsType()/Assert.IsType() 验证对象是某个类型（不能是继承关系）
Assert.IsNotType()/Assert.IsNotType() 与上面的相反
Assert.IsAssignableFrom()/Assert.IsAssignableFrom() 验证某个对象是指定类型或指定类型的子类
Assert.Subset() 验证一个集合是另一个集合的子集
Assert.ProperSubset() 验证一个集合是另一个集合的真子集
Assert.ProperSuperset() 验证一个集合是另一个集合的真超集
Assert.Collection() 验证第一个参数集合中所有项都可以在第二个参数传入的Action序列中相应位置的Action上执行而不抛出异常。
Assert.All() 验证第一个参数集合中的所有项都可以传入第二个Action类型的参数而不抛出异常。与Collection()类似，区别在于这里Action只有一个而不是序列。
Assert.PropertyChanged() 验证执行第三个参数Action使被测试INotifyPropertyChanged对象触发了PropertyChanged时间，且属性名为第二个参数传入的名称。
Assert.Throws()/Assert.Throws()Assert.ThrowsAsync()/Assert.ThrowsAsync() 验证测试代码抛出指定异常（不能是指定异常的子类）如果测试代码返回Task，应该使用异步方法
Assert.ThrowsAny() 验证测试代码抛出指定异常或指定异常的子类
Assert.ThrowsAnyAsync() 如果测试代码返回Task，应该使用异步方法

Moq(4.7.10) It参数约束

Is：匹配确定的给定类型
IsAny：匹配给定的任何值
IsIn: 匹配指定序列中存在的任何值
IsNotIn: 匹配指定序列中未找到的任何值
IsNotNull: 找任何值的给定值类型，除了空
IsInRange：匹配给定类型的范围
IsRegex：正则匹配

相关资料

Moq（Mock框架）：

http://www.cnblogs.com/haogj/archive/2011/07/22/2113496.html


http://www.cnblogs.com/jams742003/archive/2010/03/02/1676215.html

NSubstitute（Mock框架）：http://www.cnblogs.com/gaochundong/archive/2013/05/22/nsubstitute_manual.html
Shouldly（方便断言书写）：http://www.cnblogs.com/defzhu/p/4841289.html
Effort.EF6：通过nuget获取，使得创建一个伪造的、供EF容易使用的内存数据库成为可能。
netDumbster：通过nuget获取netDumbster组件，该组件提供了SimpleSmtpServer对象用于模拟邮件发送环境
HttpSimulator：通过nuget获取，通过使用HttpSimulator对象发起Http请求，在其生命周期内HttContext对象为可用状态
相关书籍：《单元测试之道》、《C#测试驱动开发》、《测试驱动开发》、《单元测试艺术》

相关推荐

http://www.cnblogs.com/easygame/p/5199785.html

http://www.cnblogs.com/edisonchou/p/5447812.html
http://www.cnblogs.com/lsxqw2004/p/4793623.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/UnitTestingDemo


article  14
title: 再讲IQueryable<T>，揭开表达式树的神秘面纱
body: 
接上篇《先说IEnumerable，我们每天用的foreach你真的懂它吗？》
最近园子里定制自己的orm那是一个风生水起，感觉不整个自己的orm都不好意思继续混博客园了（开个玩笑）。那么在此之前我们有必要仔细了解下 IQueryable<T> ，于是就有了此文。
什么是树？
什么是树？这个问题好像有点白痴。树不就是树嘛。看图：

我们从最下面的主干开始往上看，主枝-分支-分支....可以说是无限分支下去。我们倒过来看就是这样：

平时我们用得最多的树结构数据就是XML了，节点下面可以无限添加子节点。我们想想平时还用过什么树结构数据，比如：菜单无限分级、评论区的楼层。
这和我们今天讲的有毛关系啊。... 我们今天主要就是来分析表达式树的。、
lambda表达式和表达式树的区别：
Lambda表达式：

Func<Student, bool> func = t => t.Name == "农码一生";

表达式树： 

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生"; 

 咋一看，没啥区别啊。表达式只是用Expression包了一下而已。那你错了，这只是Microsoft给我们展示的障眼法，我们看编译后的C#代码：

第一个lambda表达式编译成了匿名函数，第二个表达式树编译成一了一堆我们不认识的东西，远比我们原来写的lambda复杂得多。
结论：

我们平时使用的表达式树，是编写的lambda表达式然后编译成的表达式树，也就是说平时一般情况使用的表达式树都是编译器帮我们完成的。（当然，我们可以可以手动的主动的去创表达式树。只是太麻烦，不是必要情况没有谁愿意去干这个苦活呢）

我们来看看表达式树到底有什么神奇的地方：

有没有看出点感觉来？Body里面有Right、Left，Right里面又有Right、Left，它们的类型都是继承自 Expression 。这种节点下面有节点，可以无限附加下去的数据结构我们称为树结构数据。也就是我们的表达式树。
补：上面的 Student 实体类：


public class Student
{
    public string Name { get; set; }

    public int Age { get; set; }

    public string Address { get; set; }

    public string Sex { get; set; }
}

View Code
解析表达式树
上面我们看到了所谓的表达式树，其他也没有想象的那么复杂嘛。不就是一个树结构数据嘛。如果我们要实现自己的orm，免不了要解析表达式树。一般说到解析树结构数据都会用到递归算法。下面我们开始解析表达式树。
先定义解析方法：

//表达式解析
public static class AnalysisExpression
{
    public static void VisitExpression(Expression expression)
    {
        switch (expression.NodeType)
        {
            case ExpressionType.Call://执行方法
                MethodCallExpression method = expression as MethodCallExpression;
                Console.WriteLine("方法名:" + method.Method.Name);
                for (int i = 0; i < method.Arguments.Count; i++)
                    VisitExpression(method.Arguments[i]);
                break;
            case ExpressionType.Lambda://lambda表达式
                LambdaExpression lambda = expression as LambdaExpression;
                VisitExpression(lambda.Body);
                break;
            case ExpressionType.Equal://相等比较
            case ExpressionType.AndAlso://and条件运算
                BinaryExpression binary = expression as BinaryExpression;
                Console.WriteLine("运算符:" + expression.NodeType.ToString());
                VisitExpression(binary.Left);
                VisitExpression(binary.Right);
                break;
            case ExpressionType.Constant://常量值
                ConstantExpression constant = expression as ConstantExpression;
                Console.WriteLine("常量值:" + constant.Value.ToString());
                break;
            case ExpressionType.MemberAccess:
                MemberExpression Member = expression as MemberExpression;
                Console.WriteLine("字段名称:{0}，类型:{1}", Member.Member.Name, Member.Type.ToString());
                break;
            default:
                Console.Write("UnKnow");
                break;
        }
    }

}

调用解析方法：

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生" && t.Sex == "男";
AnalysisExpression.VisitExpression(expression);

我们来看看执行过程：

一层一层的往子节点递归，直到遍历完所有的节点。最后打印效果如下：

基本上我们想要的元素和值都取到了，接着怎么组装就看你自己的心情了。是拼成sql，还是生成url，请随意！
实现自己的IQueryable<T>、IQueryProvider
仅仅解析了表达式树就可以捣鼓自己的orm了？不行，起码也要基于 IQueryable<T> 接口来编码吧。
接着我们自定义个类 MyQueryable<T> 继承接口 IQueryable<T> ：

 public class MyQueryable<T> : IQueryable<T>
 {
     public IEnumerator<T> GetEnumerator()
     {
         throw new NotImplementedException();
     }
     IEnumerator IEnumerable.GetEnumerator()
     {
         throw new NotImplementedException();
     }
     public Type ElementType
     {
         get { throw new NotImplementedException(); }
     }
     public Expression Expression
     {
         get { throw new NotImplementedException(); }
     }
     public IQueryProvider Provider
     {
         get { throw new NotImplementedException(); }
     }
 }

我们看到其中有个接口属性 IQueryProvider ，这个接口的作用大着呢，主要作用是在执行查询操作符的时候重新创建 IQueryable<T> 并且最后遍历的时候执行sql远程取值。我们还看见了 Expression  属性。
现在我们明白了 IQueryable<T> 和 Expression （表达式树）的关系了吧：

 IQueryable<T> 最主要的作用就是用来存储 Expression（表达式树）

下面我们也自定义现实了 IQueryProvider 接口的类 MyQueryProvider ：

public class MyQueryProvider : IQueryProvider
{
    public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
    {
        throw new NotImplementedException();
    }
    public IQueryable CreateQuery(Expression expression)
    {
        throw new NotImplementedException();
    }
    public TResult Execute<TResult>(Expression expression)
    {
        throw new NotImplementedException();
    }
    public object Execute(Expression expression)
    {
        throw new NotImplementedException();
    }
}

上面全是自动生成的伪代码，下面我们来填充具体的实现：


    public class MyQueryProvider : IQueryProvider
    {
        public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
        {
            return new MyQueryable<TElement>(expression);
        }

        public IQueryable CreateQuery(Expression expression)
        {
            throw new NotImplementedException();
        }

        public TResult Execute<TResult>(Expression expression)
        {
            return default(TResult);
        }

        public object Execute(Expression expression)
        {
            return new List<object>();
        } 
    }  
    public class MyQueryable<T> : IQueryable<T>
    {
        public MyQueryable()
        {
            _provider = new MyQueryProvider();
            _expression = Expression.Constant(this);
        }

        public MyQueryable(Expression expression)
        {
            _provider = new MyQueryProvider();
            _expression = expression;
        }
        public Type ElementType
        {
            get { return typeof(T); }
        }

        private Expression _expression;
        public Expression Expression
        {
            get { return _expression; }
        }

        private IQueryProvider _provider;
        public IQueryProvider Provider
        {
            get { return _provider; }
        }

        public IEnumerator GetEnumerator()
        {
            return (Provider.Execute(Expression) as IEnumerable).GetEnumerator();
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            var result = _provider.Execute<List<T>>(_expression);
            if (result == null)
                yield break;
            foreach (var item in result)
            {
                yield return item;
            }
        }
    }

View Code
执行代码：

 var aa = new MyQueryable<Student>();
 var bb = aa.Where(t => t.Name == "农码一生");
 var cc = bb.Where(t => t.Sex == "男");
 var dd = cc.AsEnumerable();
 var ee = cc.ToList(); 

接着我们看看执行过程：

结论：

每次在执行 Where 查询操作符的时候 IQueryProvider 会为我们创建一个新的 IQueryable<T> 
调用 AsEnumerable() 方法的时候并不会去实际取值（只是得到一个IEnumerable）[注意：在EF里面查询不要先取IEnumerable后滤筛，因为AsEnumerable()会生成查询全表的sql]
执行 ToList() 方法时才去真正调用迭代器 GetEnumerator() 取值
真正取值的时候，会去执行 IQueryProvider 中的 Execute 方法。（就是在调用这个方法的时候解析表达式数，然后执行取得结果）

我们看到真正应该办实事的 Execute  我们却让他返回默认值了。

现在估计有人不爽了，你到是具体实现下 Execute 。好吧！（其实通过上面说的解析表达式树，你可以自己在这里做想做的任何事了。）
首先为了简单起见，我们用一个集合做为数据源：

//构造Student数组
public static List<Student> StudentArrary = new List<Student>()
{
        new Student(){Name="农码一生", Age=26, Sex="男", Address="长沙"},
        new Student(){Name="小明", Age=23, Sex="男", Address="岳阳"},
        new Student(){Name="嗨-妹子", Age=25, Sex="女", Address="四川"}
};

然后，重新写一个VisitExpression2方法：（和之前的区别： 现在目的是取表达式树中的表达式，而不是重新组装成sql或别的）

public static void VisitExpression2(Expression expression, ref List<LambdaExpression> lambdaOut)
{
    if (lambdaOut == null)
        lambdaOut = new List<LambdaExpression>();
    switch (expression.NodeType)
    {
        case ExpressionType.Call://执行方法
            MethodCallExpression method = expression as MethodCallExpression;
            Console.WriteLine("方法名:" + method.Method.Name);
            for (int i = 0; i < method.Arguments.Count; i++)
                VisitExpression2(method.Arguments[i], ref  lambdaOut);
            break;
        case ExpressionType.Lambda://lambda表达式
            LambdaExpression lambda = expression as LambdaExpression;
            lambdaOut.Add(lambda);
            VisitExpression2(lambda.Body, ref  lambdaOut);
            break;
        case ExpressionType.Equal://相等比较
        case ExpressionType.AndAlso://and条件运算
            BinaryExpression binary = expression as BinaryExpression;
            Console.WriteLine("运算符:" + expression.NodeType.ToString());
            VisitExpression2(binary.Left, ref  lambdaOut);
            VisitExpression2(binary.Right, ref  lambdaOut);
            break;
        case ExpressionType.Constant://常量值
            ConstantExpression constant = expression as ConstantExpression;
            Console.WriteLine("常量值:" + constant.Value.ToString());
            break;
        case ExpressionType.MemberAccess:
            MemberExpression Member = expression as MemberExpression;
            Console.WriteLine("字段名称:{0}，类型:{1}", Member.Member.Name, Member.Type.ToString());
            break;
        case ExpressionType.Quote:
            UnaryExpression Unary = expression as UnaryExpression;
            VisitExpression2(Unary.Operand, ref  lambdaOut);
            break;
        default:
            Console.Write("UnKnow");
            break;
    }
}

然后重新实现方法 Execute ：

public TResult Execute<TResult>(Expression expression)
{
    List<LambdaExpression> lambda = null;
    AnalysisExpression.VisitExpression2(expression, ref lambda);//解析取得表达式数中的表达式
    IEnumerable<Student> enumerable = null;
    for (int i = 0; i < lambda.Count; i++)
    {
        //把LambdaExpression转成Expression<Func<Student, bool>>类型
        //通过方法Compile()转成委托方法
        Func<Student, bool> func = (lambda[i] as Expression<Func<Student, bool>>).Compile(); 
        if (enumerable == null)
            enumerable = Program.StudentArrary.Where(func);//取得IEnumerable
        else
            enumerable = enumerable.Where(func);
    }
    dynamic obj = enumerable.ToList();//（注意：这个方法的整个处理过程，你可以换成解析sql执行数据库查询，或者生成url然后请求获取数据。）
    return (TResult)obj;
}

执行过程：

个人对 IQueryable 延迟加载的理解：

前段部分的查询操作符只是把逻辑分解存入表达式树，并没有远程执行sql。
foreache执行的是 IEnumerable<T> ，然而 IEnumerable<T> 同样具有延迟加载的特性。每次迭代的时候才真正的取数据。且在使用导航属性的时候会再次查询数据库。(下次说延迟加载不要忘记了 IEnumerable 的功劳哦！)

小知识：
表达式树转成Lambda表达式：

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生";
Func<Student, bool> func = expression.Compile();

总结：
表达式树的分析就告一段落了，其中还有很多细节或重要的没有分析到。下次有新的心得再来总结。
感觉表达式树就是先把表达式打散存在树结构里（一般打散的过程是编译器完成），然后可以根据不同的数据源或接口重新组装成自己想要的任何形式，这也让我们实现自己的orm成为了可能。
今天主要是对表达式树的解析、和实现自己的IQueryable<T>、IQueryProvider做了一个记录和总结，其中不定有错误的结论或说法，轻点拍！
demo下载：http://pan.baidu.com/s/1nvAksgL 
本文以同步至索引目录：《C#基础知识巩固》
 
推荐阅读：
http://www.cnblogs.com/jesse2013/p/expressiontree-part1.html
http://www.cnblogs.com/jesse2013/p/expressiontree-part2.html
http://www.cnblogs.com/jesse2013/p/expressiontree-Linq-to-cnblogs.html
园友@风口上的猪推荐：
http://www.cnblogs.com/Ninputer/archive/2009/09/08/expression_tree3.htmlhttp://blog.zhaojie.me/2009/03/expression-cache-1.html
 
article  15
title: 面向对象编程思想(2)--策略模式
body: 
定义
策略模式
官方定义：定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。
个人理解：选择执行多个规则中的某个规则。
C#实现
需求1: 开发一个商场收银系统v1.0
三下五除二搞定

代码实现：
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额

var money = price * number;//本次计算金额
labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1},金额：{2}", price, number, money + "\r\n");

系统简单、方便、实用、性能好。...几个月过去，马上要国庆长假，老板为了促销决定全场8.8折。
需求2： 加入打折功能
因为项目工期紧，三下五除二又搞定
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额
var discount = 0.88;//折扣(新增代码)

var money = price * number * discount;//本次计算金额
labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，折扣：{2},实际金额：{2}", price, number, discount, money + "\r\n");

很是自豪，我开发效率就是这么高。老板也甚是高兴。
...转眼假期就要过去了，打折的活动也要取消了。但是，由于这次的促销效果收益还不错。老板决定继续打折活动，折扣率要成为9.8折，且只是部分商品。不打折的商品则实行满300返40，满600返100。
不对劲啊，又的改代码。到了明年是不是又要8.8？老板的心思猜不透，但程序可以写得更灵活。所以我们要好好构思下。让系统可以选择优惠策略。
需求3： 修改打折，并加入返现功能

代码实现如下
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额            
var money = price * number;//本次计算金额
switch (cmBstrategy.Text)//下拉框
{

    case "8.8折":
        money *= 0.88;
        break;
    case "9.8折":
        money *= 0.98;
        break;
    case "满300返40":
        if (money >= 300)
        {
            money -= 40;
        }
        break;
    case "满600返100":
        if (money >= 600)
        {
            money -= 100;
        }
        break;
}

labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，促销：{2},实际金额：{3}", price, number, cmBstrategy.Text, money + "\r\n");
现在我们的收银员可以灵活切换优惠活动，且保留的原有的优惠策略。不过我们从代码层面考虑的话，还有多处不足。

switch条件分支语句难以阅读和维护。
如果我们需要修改新增优惠策略的话，需在界面代码里面修改。

根据面向对象的思想，应该封装变化。于是，我们的策略模式可以登场了。
代码重构 使用策略模式实现以上需求
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额      
 
var context = new Context(cmBstrategy.Text);//新增代码
var money = context.Calculation(price, number);//新增代码

labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，促销：{2},实际金额：{3}", price, number, cmBstrategy.Text, money + "\r\n");

我们发现中间那段条件分支不见了，多了一个Context类。
public class Context
{
    //策略抽象类
    private AmountCalculation amountCalculation;

    public Context(string type)
    {
        switch (type)
        {
            case "8.8折":
                amountCalculation = new Rebate(0.88);
                break;
            case "9.8折":
                amountCalculation = new Rebate(0.98);
                break;
            case "满300返40":
                amountCalculation = new Cashback(300, 40);
                break;
            case "满600返100":
                amountCalculation = new Cashback(600, 100);
                break;
        }
    }
    //计算金额
    public double Calculation(double price, double number)
    {
        return amountCalculation.Calculation(price, number);
    }
}
里面有类Rebate折扣计算、Cashback返现计算。
//折扣计算
public class Rebate : AmountCalculation
{
    private double discountRate;
    public Rebate(double discountRate)
    {
        this.discountRate = discountRate;
    }

    public override double Calculation(double price, double number)
    {
        return price * number * discountRate;
    }
}
// 返现
public class Cashback : AmountCalculation
{
    //满多少
    private double exceed;
    //返多少
    private double retreat;
    public Cashback(double exceed, double retreat)
    {
        this.exceed = exceed;
        this.retreat = retreat;
    }
    public override double Calculation(double price, double number)
    {
        var momoney = price * number;
        if (momoney >= exceed)
        {
            return momoney - retreat;
        }
        return momoney;
    }
}
看到这里，是不是明白了策略模式呢？
如果现在老板再需要我们价格折扣或是返现的活动，相比之前需要在长段的界面逻辑代码里面修改，现在要方便得多了。
第一、先在界面添加一个活动如加一个7.8折，然后界面代码就不用动了。
第二、在Context类里面加一个7.8折
switch (type)
{
    //新增
    case "7.8折":
        amountCalculation = new Rebate(0.78);
        break;
JS实现
上面用C#实现了策略模式，接下来我们尝试使用js来实现。还是借用用上面的商场活动业务。
js不同于传统的面向对象，无类、不需要实现抽象类。
//策略计算
var strategies = {
    //返现  exceed：满多少  retreat:返多少  momoney：应付金额
    cashBack: function (exceed, retreat, momoney) {
        if (momoney >= exceed) {
            return (momoney - retreat).toFixed(2);
        }
        return momoney;//返现后实付金额
    },
    //打折 discountRate：折扣率  momoney：应付金额
    rebate: function (discountRate, momoney) {
        return (discountRate * momoney).toFixed(2);//折扣后实付金额
    }
}
//上下文
var context = {
    "7.8折": function (price, number) {
        var momoney = price * number;
        return strategies.rebate(0.78, momoney);
    },
    "9.8折": function (price, number) {
        var momoney = price * number;
        return strategies.rebate(0.98, momoney);
    },
    "满300返40": function (price, number) {
        var momoney = price * number;
        return strategies.cashBack(300, 40, momoney);
    },
    "满600返100": function (price, number) {
        var momoney = price * number;
        return strategies.cashBack(600, 100, momoney);
    }
}
//计算结果
var calculateBonus = function (level, price, number) {
    return context[level](price, number);
};
//调用
console.log(calculateBonus('7.8折', 12, 3));//计算
console.log(calculateBonus('满600返100', 12, 3));//计算
console.log(calculateBonus('满300返40', 2, 23));//计算
console.log(calculateBonus('9.8折', 2, 33));//计算
结果如下：

相对于面向对象语言的实现要更加的清晰明了。
那么js可以模拟面向对象的实现吗？答案是肯定的。
首先定义返现实现类：
//返现  exceed：满多少  retreat:返多少
var CashBack = function (exceed, retreat) {
    this.exceed = exceed;
    this.retreat = retreat;
};
//计算方法
CashBack.prototype.calculate = function (price, number) {
    var momoney = price * number;
    if (momoney >= this.exceed) {
        return (momoney - this.retreat).toFixed(2);
    }
    return momoney;//返现后实付金额
}
打折类
//打折 discountRate：折扣率  momoney：应付金额
var Rebate = function (discountRate) {
    this.discountRate = discountRate;
};
//计算方法
Rebate.prototype.calculate = function (price, number) {
    return (price * number * this.discountRate).toFixed(2);//折扣后实付金额
}
策略上下文
//上下文
var Context = function (type) {
    this.type = type; 
}
Context.prototype.calculation = function (price, number) {
    var AmountCalculation;
    switch (this.type) {
        case "7.8折":
            AmountCalculation = new Rebate(0.78);
            break;
        case "9.8折":
            AmountCalculation = new Rebate(0.98);
            break;
        case "满300返40":
            AmountCalculation = new CashBack(300, 40);
            break;
        case "满600返100":
            AmountCalculation = new CashBack(600, 100);
            break;
    }
    return AmountCalculation.calculate(price, number);
}
调用如下：
//调用
var context = new Context("7.8折");  
console.log(context.calculation(12, 3));
var context = new Context("9.8折");  
console.log(context.calculation(12, 3));//计算
var context = new Context("满300返40");  
console.log(context.calculation(300, 2));//计算
var context = new Context("满600返100");  
console.log(context.calculation(300, 3));//计算

虽然对于js语言特性直接实现策略模式来说，面向对象的代码量比较多。可是对于我们后端人员new一个对象的使用方式应该更习惯。
 
策略模式场景

排序算法的选择冒泡排序、选择排序、快速排序、插入排序
压缩算法的选择zip、rar、rar5...
旅游交通工具的选择飞机、火车、汽车...
 

总结
策略模式通过Context上下文对具体策略进行封装，供高层直接调用而不用关系策略的具体实现。然后Context本身通过不同情况实例不同的抽象实现类（具体策略类），来执行具体策略。从而实现了具体策略的自由切换，易于新策略的扩展。
本文已同步至索引目录：《设计模式学习》
本文demo：https://github.com/zhaopeiym/BlogDemoCode

article  16
title: 面向对象编程思想(1)--单例模式
body: 
世界上本来没有设计模式。用的人多了，也就成了设计模式。所以，我们不是严格按照它的定义去执行，可以根据自己的实际场景、需求去变通。领悟了其中的思想，实现属于自己的设计模式。
你肯定有过这样的体会。某某时候，听人说起**模式。这么牛逼，回去得看看。结果仔细一看原来自己早就是这么用了，只是不知道它还有个这么高大上的名字。当然，专业的名字方便我们业内交流和教学，对技术的发展和传播起着重要的作用。
废话不多说，和我一起来学习这些高大上的术语吧。本系列《设计模式学习》，通过对传统面向对象编程语言C#和函数为第一等的元素的javascript语言来对比学习加深对设计模式的领悟和运用。
定义
单例模式
个人理解：只能存在一个实例
官方解释：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
C#代码示例
示例1
public static class Singleton
{
   //TODO
}
表激动，它确实不是我们平时使用的单例模式。它只是个静态对象。但是，我觉得也是可以当成单例来使用的。
当然，肯定有它的不足，不然也不会去搞个单例模式了。

致命的缺点，不能继承类也不能实现接口。

静态类中所有方法、字段必须是静态的。
你无法控制它的初始化。

静态类我们一般都是用来编写和业务无关的基础方法、扩展方法。而单例类是一个实例类，一般和业务相关。

示例2
public class Singleton
{
    public static Singleton singleton = new Singleton();   
}
Console.WriteLine(Singleton.singleton.Equals(Singleton.singleton));//true
其实它是个假单例
Singleton s1 = new Singleton();
Singleton s2 = new Singleton();
Console.WriteLine(s1.Equals(s2));//false
且有缺点

在类被加载的时候就自动初始化了singleton
singleton应该被定义为只读属性

示例3
public class Singleton
{
    public static readonly Singleton singleton = new Singleton();//自读字段
    private Singleton()//禁止初始化
    {
    }
}
这是一个比较简单的单例，但是自动化初始变量还是存在
示例4
public class Singleton
{
    public static Singleton singleton = null;

    public static Singleton GetSingleton()
    {
        if (singleton == null)
        {
            singleton = new Singleton();
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
如此一来，我们就可以在调用GetSingleton方法的时候再去实例话了。注意：实例化之后singleton变量值不能再被GC回收了，因为它是个静态变量。
如此就算完事了吗？不，如果多线程同时执行的时候还是会出现多个实例。
public class Singleton
{
    public static Singleton singleton = null;

    public static Singleton GetSingleton()
    {
        if (singleton == null) //线程二执行到这里singleton == null为true，会继续下面实例Singleton
        {
           //线程一执行到这里
            Thread.Sleep(1000);//假设这还有段耗时逻辑（也可以理解并发极限）
            singleton = new Singleton();
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
所以还需要继续改进
示例5
public class Singleton
{
    public static Singleton singleton = null;
    private static object obj = new object();

    public static Singleton GetSingleton()
    {
        if (singleton == null) //下面有锁了为什么还要判断，因为锁会阻塞线程。而singleton被实例化后这个判断永远为false，不在需要锁。
        {
            lock (obj)
            {
                //这里代码只可能存在一个线程同时到达
                if (singleton == null)
                {
                    Thread.Sleep(1000);
                    singleton = new Singleton();
                } 
            } 
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
这就是我们常见的单例类代码了。当然你也可以改成读取属性的方式。但区别不大。
public class Singleton
{
    private static Singleton singleton = null;
    private static object obj = new object(); 
    public static Singleton Instance
    {
        get
        {
            if (singleton == null)
            {
                lock (obj)
                {
                    if (singleton == null)
                    {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        } 
    }
    private Singleton()//禁止初始化
    {
    }
}
C#使用场景
上面用了那么多的笔墨分析单例模式的使用，可是我们在什么场景下使用单例呢？
最典型的就是配置文件的读取，通常我们的配置文件是在程序第一次启动的时候读取，运行中是不允许修改配置文件的。
public class ConfigInfo
{
    private static ConfigInfo singleton = null;
    private static object obj = new object();
    public static ConfigInfo Instance
    {
        get
        {
            if (singleton == null)
            {
                lock (obj)
                {
                    if (singleton == null)
                    {
                        singleton = new ConfigInfo(); 
                        //从配置文件读取并赋值
                        singleton.Email = "zhaopeiym@163.com";
                        singleton.EmailUser = "农码一生";
                        singleton.EmailPass = "***********";
                    }
                }
            }
            return singleton;
        }
    }

    public string Email { get; private set; }
    public string EmailUser { get; private set; }
    public string EmailPass { get; private set; } 

    private ConfigInfo()//禁止初始化
    {
    }
}
调用
var emailInfo = ConfigInfo.Instance;
EmailSend(emailInfo.Email,emailInfo.EmailUser,emailInfo.EmailPass);
好了，C#中的单例模式大概就这样了。
JS代码示例
js和C#是不同的，一个是"无类"语言，一个是传统的面向对象语言。而在js中的单例就比较简单了。比如我们熟悉的window对象。
那么我们怎么在js中实现自己的单例模式呢？方法很多，先来个简单的：
示例1
var Singleton = {
    name: "农码一生",
    getName: function () {
        return this.name;
    }  
}
这就是一个最简单的单例，通过字面量创建一个对象。看着是不是非常像C#中的静态类？但是，它不存在静态类中的缺点。
继承毫无压力：
var Person = {
    age: 27
}

var Me = Person;
Me.name = "农码一生";
Me.getName = function () {
    return this.name;
}
Me.getAge = function () {
    return this.age;
}
虽然如此，但它并不完美。按理说字段不应该被外界随意修改的。可是js“无类”，更别说私有字段了。幸运的是js中有无处不在的闭包。
示例2
var Singleton = (function () {
    var name = "农码一生";   
    return {
        getName: function () {
            return name;
        }
    }
})();
如此一来，我们就实现了一个单例模式。经过前面对C#单例的分析，我们希望在使用的时候才去实例话对象怎么办？（且不要小看这个惰性加载，在实际开发中作用可大着呢。）
示例3
var Singleton = (function () {

    var Person = function () {
        this.name = "农码一生";
    }
    Person.prototype.getName = function () {
        return this.name;
    };
    var instance;
    return {
        getInstance: function () {
            if (!instance) {
                instance = new Person();
            }
            return instance;
        }
    }
})();

var person1 = Singleton.getInstance();
var person2 = Singleton.getInstance();
console.log(person1 === person2);//true
这算是js中比较标准的单例模式了。可能有同学会问，之前C#的时候我记得加了lock锁的啊。这里怎么就算比较标准了呢。不要忘记，==js天生的单线程，后台天生的多线程==。这就是区别。
为了职责的单一，我应该改写成
示例4
var Person = function () {
    this.name = "农码一生";
}
Person.prototype.getName = function () {
    return this.name;
};
    
var Singleton = (function () {
    var instance;
    return {
        getInstance: function () {
            return instance ||  (instance = new Person(););//简化if判断
        }
    }
})();
我们很多时候都会使用到单例，那我们可否把一个对象变成单例的过程抽象出来呢。如下：
示例5
//通用的创建单例对象的方法
var getSingle = function (obj) {
    var instance;
    return function () {
        return instance || (instance = new obj());
    }
};

var PersonA = function () {
    this.name = "农码一生";
}

var PersonB = function () {
    this.name = "农码爱妹子";
} 

var singlePersonA = getSingle(PersonA);//获取PersonA的单例
var singlePersonB = getSingle(PersonB);//获取PersonB的单例
var a1 = singlePersonA();
var a2 = singlePersonA();
var a3 = singlePersonB();
var a4 = singlePersonB();
console.log(a1 === a2);//true
console.log(a3 === a4);//true
console.log(a1 === a3);//false 
有没有头晕晕的，习惯就好了。你会说，我直接用最开始的全局变量字面量对象得了，可你不要忘记会造成变量名的污染。
JS使用场景
我们在做Tab也切换的时候就可以用到单例模式。在此，我们做个非单例和单例的比较
示例6非单例：
//获取tab1的html数据
var getTab1Html = function () {
    this.url = "/tab/tab1.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
}

var getTab2Html = function () {
    this.url = "/tab/tab2.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
} 

//点击tab1的时候加载tab1的数据
$("#tab1").on("click", function () {
    getTab1Html();
})
$("#tab2").on("click", function () {
    getTab2Html();
})
我们发现没点击一次tab的时候会请求一次后台数据，然后加载页面。这是不是有点傻。正确的姿势应该是第一次点击的时候加载，后面不在请求加载。那么我们就可以使用单例模式了。
示例7单例：
//获取tab1的html数据
var getTab1Html = function () {
    this.url = "/tab/tab1.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
}

var getTab2Html = function () {
    this.url = "/tab/tab2.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
} 

var loadTab1 = getSingle(getTab1Html);
var loadTab2 = getSingle(getTab2Html);

//点击tab1的时候加载tab1的数据
$("#tab1").on("click", function () {
    loadTab1();
})
$("#tab2").on("click", function () {
    loadTab2();
})

此时，我们无论点击多少此tab。它也只会在第一次点击的时候请求加载页面数据了。
 
注意：

JS中不建议使用全局变量来达到单例的效果

其一，会引起变量名的全局污染


其二，不能惰性加载。

C#中不建议使用静态类来达到单例的效果

其一，不能继承类和接口


其二，内部变量和方法必须静态。

单例模式中实例变量要慎用。因为一个单例很可能被多处操作（修改了变量），从而影响的预期效果。
 

设计模式之所以能成为设计模式，也是在不断尝试、改进后得到的最佳实践而已。所以，我们不需要生搬硬套，适合的才是最好的。在此，关于单例模式的学习到此结束。谢谢您的阅读。
本文已同步至索引目录：《设计模式学习》
本文demo：https://github.com/zhaopeiym/BlogDemoCode

article  17
title: C#异步的世界【上】
body: 
新进阶的程序员可能对async、await用得比较多，却对之前的异步了解甚少。本人就是此类，因此打算回顾学习下异步的进化史。 
本文主要是回顾async异步模式之前的异步，下篇文章再来重点分析async异步模式。
APM
APM 异步编程模型，Asynchronous Programming Model
早在C#1的时候就有了APM。虽然不是很熟悉，但是多少还是见过的。就是那些类是BeginXXX和EndXXX的方法，且BeginXXX返回值是IAsyncResult接口。
在正式写APM示例之前我们先给出一段同步代码：

//1、同步方法
private void button1_Click(object sender, EventArgs e)
{          
    Debug.WriteLine("【Debug】线程ID:" + Thread.CurrentThread.ManagedThreadId);

    var request = WebRequest.Create("https://github.com/");//为了更好的演示效果，我们使用网速比较慢的外网
    request.GetResponse();//发送请求    

    Debug.WriteLine("【Debug】线程ID:" + Thread.CurrentThread.ManagedThreadId);
    label1.Text = "执行完毕！";
}

【说明】为了更好的演示异步效果，这里我们使用winform程序来做示例。（因为winform始终都需要UI线程渲染界面，如果被UI线程占用则会出现“假死”状态）
【效果图】

看图得知：

我们在执行方法的时候页面出现了“假死”，拖不动了。
我们看到打印结果，方法调用前和调用后线程ID都是9（也就是同一个线程）

下面我们再来演示对应的异步方法：（BeginGetResponse、EndGetResponse所谓的APM异步模型）

private void button2_Click(object sender, EventArgs e)
{
    //1、APM 异步编程模型，Asynchronous Programming Model
    //C#1[基于IAsyncResult接口实现BeginXXX和EndXXX的方法]             
    Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);

    var request = WebRequest.Create("https://github.com/");
    request.BeginGetResponse(new AsyncCallback(t =>//执行完成后的回调
    {
        var response = request.EndGetResponse(t);
        var stream = response.GetResponseStream();//获取返回数据流 

        using (StreamReader reader = new StreamReader(stream))
        {
            StringBuilder sb = new StringBuilder();
            while (!reader.EndOfStream)
            {
                var content = reader.ReadLine();
                sb.Append(content);
            }
            Debug.WriteLine("【Debug】" + sb.ToString().Trim().Substring(0, 100) + "...");//只取返回内容的前100个字符 
            Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            label1.Invoke((Action)(() => { label1.Text = "执行完毕！"; }));//这里跨线程访问UI需要做处理
        }
    }), null);

    Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId); 
}

【效果图】
 
看图得知：

启用异步方法并没有是UI界面卡死
异步方法启动了另外一个ID为12的线程

上面代码执行顺序：

前面我们说过，APM的BebinXXX必须返回IAsyncResult接口。那么接下来我们分析IAsyncResult接口：
首先我们看：

确实返回的是IAsyncResult接口。那IAsyncResult到底长的什么样子？：

并没有想象中的那么复杂嘛。我们是否可以尝试这实现这个接口，然后显示自己的异步方法呢？
首先定一个类MyWebRequest，然后继承IAsyncResult：（下面是基本的伪代码实现）

public class MyWebRequest : IAsyncResult
{
    public object AsyncState
    {
        get { throw new NotImplementedException(); }
    }

    public WaitHandle AsyncWaitHandle
    {
        get { throw new NotImplementedException(); }
    }

    public bool CompletedSynchronously
    {
        get { throw new NotImplementedException(); }
    }

    public bool IsCompleted
    {
        get { throw new NotImplementedException(); }
    }
}

这样肯定是不能用的，起码也得有个存回调函数的属性吧，下面我们稍微改造下：

然后我们可以自定义APM异步模型了：（成对的Begin、End）

public IAsyncResult MyBeginXX(AsyncCallback callback)
{
    var asyncResult = new MyWebRequest(callback, null);
    var request = WebRequest.Create("https://github.com/");
    new Thread(() =>  //重新启用一个线程
    {
        using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream()))
        {
            var str = sr.ReadToEnd();
            asyncResult.SetComplete(str);//设置异步结果
        }

    }).Start();
    return asyncResult;//返回一个IAsyncResult
}

public string MyEndXX(IAsyncResult asyncResult)
{
    MyWebRequest result = asyncResult as MyWebRequest;
    return result.Result;
}

调用如下:

 private void button4_Click(object sender, EventArgs e)
 {
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
     MyBeginXX(new AsyncCallback(t =>
     {
         var result = MyEndXX(t);
         Debug.WriteLine("【Debug】" + result.Trim().Substring(0, 100) + "...");
         Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
     }));
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
 }

效果图：

我们看到自己实现的效果基本上和系统提供的差不多。

启用异步方法并没有是UI界面卡死
异步方法启动了另外一个ID为11的线程

【总结】
个人觉得APM异步模式就是启用另外一个线程执行耗时任务，然后通过回调函数执行后续操作。
APM还可以通过其他方式获取值，如：

while (!asyncResult.IsCompleted)//循环，直到异步执行完成 (轮询方式)
{
    Thread.Sleep(100);
}
var stream2 = request.EndGetResponse(asyncResult).GetResponseStream();

或

asyncResult.AsyncWaitHandle.WaitOne();//阻止线程，直到异步完成 （阻塞等待）
var stream2 = request.EndGetResponse(asyncResult).GetResponseStream();

 
补充：如果是普通方法，我们也可以通过委托异步：（BeginInvoke、EndInvoke）

 public void MyAction()
 {
     var func = new Func<string, string>(t =>
     {
         Thread.Sleep(2000);
         return "name:" + t + DateTime.Now.ToString();
     });
 
     var asyncResult = func.BeginInvoke("张三", t =>
     {
         string str = func.EndInvoke(t);
         Debug.WriteLine(str);
     }, null); 
 }

EAP
EAP 基于事件的异步模式，Event-based Asynchronous Pattern
此模式在C#2的时候随之而来。
先来看个EAP的例子：

 private void button3_Click(object sender, EventArgs e)
 {            
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);

     BackgroundWorker worker = new BackgroundWorker();
     worker.DoWork += new DoWorkEventHandler((s1, s2) =>
     {
         Thread.Sleep(2000);
         Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
     });//注册事件来实现异步
     worker.RunWorkerAsync(this);
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
 }

 
【效果图】（同样不会阻塞UI界面）

【特征】

通过事件的方式注册回调函数
通过 XXXAsync方法来执行异步调用

例子很简单，但是和APM模式相比，是不是没有那么清晰透明。为什么可以这样实现？事件的注册是在干嘛？为什么执行RunWorkerAsync会触发注册的函数？
感觉自己又想多了...
我们试着反编译看看源码：

 只想说，这么玩，有意思吗？
TAP
TAP 基于任务的异步模式，Task-based Asynchronous Pattern
到目前为止，我们觉得上面的APM、EAP异步模式好用吗？好像没有发现什么问题。再仔细想想...如果我们有多个异步方法需要按先后顺序执行，并且需要(在主进程)得到所有返回值。
首先定义三个委托：

public Func<string, string> func1()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "name:" + t;
    });
}
public Func<string, string> func2()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "age:" + t;
    });
}
public Func<string, string> func3()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "sex:" + t;
    });
}

然后按照一定顺序执行：

public void MyAction()
{
    string str1 = string.Empty, str2 = string.Empty, str3 = string.Empty;
    IAsyncResult asyncResult1 = null, asyncResult2 = null, asyncResult3 = null;
    asyncResult1 = func1().BeginInvoke("张三", t =>
    {
        str1 = func1().EndInvoke(t);
        Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
        asyncResult2 = func2().BeginInvoke("26", a =>
        {
            str2 = func2().EndInvoke(a);
            Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            asyncResult3 = func3().BeginInvoke("男", s =>
            {
                str3 = func3().EndInvoke(s);
                Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            }, null);
        }, null);
    }, null);

    asyncResult1.AsyncWaitHandle.WaitOne();
    asyncResult2.AsyncWaitHandle.WaitOne();
    asyncResult3.AsyncWaitHandle.WaitOne();
    Debug.WriteLine(str1 + str2 + str3);
} 

除了难看、难读一点好像也没什么 。不过真的是这样吗？

asyncResult2是null?由此可见在完成第一个异步操作之前没有对asyncResult2进行赋值，asyncResult2执行异步等待的时候报异常。那么如此我们就无法控制三个异步函数，按照一定顺序执行完成后再拿到返回值。（理论上还是有其他办法的，只是会然代码更加复杂）
 
是的，现在该我们的TAP登场了。

只需要调用Task类的静态方法Run，即可轻轻松松使用异步。
获取返回值：

var task1 = Task<string>.Run(() =>
{
    Thread.Sleep(1500);
    Console.WriteLine("【Debug】task1 线程ID:" + Thread.CurrentThread.ManagedThreadId);
    return "张三";
});
//其他逻辑            
task1.Wait();
var value = task1.Result;//获取返回值
Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);

现在我们处理上面多个异步按序执行：

Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);
string str1 = string.Empty, str2 = string.Empty, str3 = string.Empty;
var task1 = Task.Run(() =>
{
    Thread.Sleep(500);
    str1 = "姓名：张三,";
    Console.WriteLine("【Debug】task1 线程ID:" + Thread.CurrentThread.ManagedThreadId);
}).ContinueWith(t =>
{
    Thread.Sleep(500);
    str2 = "年龄：25,";
    Console.WriteLine("【Debug】task2 线程ID:" + Thread.CurrentThread.ManagedThreadId);
}).ContinueWith(t =>
{
    Thread.Sleep(500);
    str3 = "爱好：妹子";
    Console.WriteLine("【Debug】task3 线程ID:" + Thread.CurrentThread.ManagedThreadId);
});

Thread.Sleep(2500);//其他逻辑代码

task1.Wait();

Debug.WriteLine(str1 + str2 + str3);
Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);

[效果图]

我们看到，结果都得到了，且是异步按序执行的。且代码的逻辑思路非常清晰。如果你感受还不是很大，那么你现象如果是100个异步方法需要异步按序执行呢？用APM的异步回调，那至少也得异步回调嵌套100次。那代码的复杂度可想而知。
 
延伸思考


WaitOne完成等待的原理


异步为什么会提升性能


线程的使用数量和CPU的使用率有必然的联系吗


 
问题1：WaitOne完成等待的原理
在此之前，我们先来简单的了解下多线程信号控制AutoResetEvent类。

var _asyncWaitHandle = new AutoResetEvent(false);
_asyncWaitHandle.WaitOne();

此代码会在 WaitOne 的地方会一直等待下去。除非有另外一个线程执行 AutoResetEvent 的set方法。

var _asyncWaitHandle = new AutoResetEvent(false);
_asyncWaitHandle.Set();
_asyncWaitHandle.WaitOne();

如此，到了 WaitOne 就可以直接执行下去。没有有任何等待。
现在我们对APM 异步编程模型中的 WaitOne 等待是不是知道了点什么呢。我们回头来实现之前自定义异步方法的异步等待。

public class MyWebRequest : IAsyncResult
{
    //异步回调函数（委托）
    private AsyncCallback _asyncCallback;
    private AutoResetEvent _asyncWaitHandle;
    public MyWebRequest(AsyncCallback asyncCallback, object state)
    {
        _asyncCallback = asyncCallback;
        _asyncWaitHandle = new AutoResetEvent(false);
    }
    //设置结果
    public void SetComplete(string result)
    {
        Result = result;
        IsCompleted = true;
        _asyncWaitHandle.Set();
        if (_asyncCallback != null)
        {
            _asyncCallback(this);
        }
    }
    //异步请求返回值
    public string Result { get; set; }
    //获取用户定义的对象，它限定或包含关于异步操作的信息。
    public object AsyncState
    {
        get { throw new NotImplementedException(); }
    }
    // 获取用于等待异步操作完成的 System.Threading.WaitHandle。
    public WaitHandle AsyncWaitHandle
    {
        //get { throw new NotImplementedException(); }

        get { return _asyncWaitHandle; }
    }
    //获取一个值，该值指示异步操作是否同步完成。
    public bool CompletedSynchronously
    {
        get { throw new NotImplementedException(); }
    }
    //获取一个值，该值指示异步操作是否已完成。
    public bool IsCompleted
    {
        get;
        private set;
    }
}

红色代码就是新增的异步等待。
【执行步骤】

 
问题2：异步为什么会提升性能
比如同步代码：

Thread.Sleep(10000);//假设这是个访问数据库的方法
Thread.Sleep(10000);//假设这是个访问FQ网站的方法

这个代码需要20秒。
如果是异步：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
});
Thread.Sleep(10000);//假设这是个访问FQ网站的方法
task.Wait();

如此就只要10秒了。这样就节约了10秒。
如果是：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
}); 
task.Wait();

异步执行中间没有耗时的代码那么这样的异步将是没有意思的。
或者：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
}); 
task.Wait();
Thread.Sleep(10000);//假设这是个访问FQ网站的方法

把耗时任务放在异步等待后，那这样的代码也是不会有性能提升的。
还有一种情况：
如果是单核CPU进行高密集运算操作，那么异步也是没有意义的。(因为运算是非常耗CPU,而网络请求等待不耗CPU)
 
问题3：线程的使用数量和CPU的使用率有必然的联系吗
答案是否。
还是拿单核做假设。
情况1：

long num = 0;
while (true)
{
    num += new Random().Next(-100,100);
    //Thread.Sleep(100);
}

单核下，我们只启动一个线程，就可以让你CPU爆满。

启动八次，八进程CPU基本爆满。
情况2：


一千多个线程，而CPU的使用率竟然是0。由此，我们得到了之前的结论，线程的使用数量和CPU的使用率没有必然的联系。
虽然如此，但是也不能毫无节制的开启线程。因为：

开启一个新的线程的过程是比较耗资源的。（可是使用线程池，来降低开启新线程所消耗的资源）
多线程的切换也是需要时间的。
每个线程占用了一定的内存保存线程上下文信息。

 
demo：http://pan.baidu.com/s/1slOxgnF
本文已同步至索引目录：《C#基础知识巩固》
对于异步编程了解不深，文中极有可能多处错误描述和观点。
感谢广大园友的指正。
本着相互讨论的目的，绝无想要误导大家的意思。
 
【推荐】
http://www.cnblogs.com/wisdomqq/archive/2012/03/26/2412349.html
article  18
title: 农码一生博文索引
body: 
《.NET Core》

ASP.NET Core 快速入门【第一弹-环境篇】
ASP.NET Core 快速入门【第二弹-实战篇】

《Linux学习》

Linux学习(1)-常用快捷键、文件管理和查询

《C#基础知识巩固》

特性是什么东东
什么是反射、反射可以做些什么
依赖注入是什么
可空类型Nullable<T>到底是什么鬼
谈扩展方法的理解
你必须知道的EF知识和经验【推荐】
你知道C#中的Lambda表达式的演化过程吗 
Linq表达式、Lambda表达式你更喜欢哪个 
先说IEnumerable，我们每天用的foreach你真的懂它吗【推荐】
再讲IQueryable<T>，揭开表达式树的神秘面纱【推荐】
那些年搞不懂的术语、概念：协变、逆变、不可变
C#异步的世界【上】
C#异步的世界【下】【推荐】
C#单元测试，带你快速入门
权限管理学习 一、ASP.NET Forms身份认证
文件下载之断点续传（客户端与服务端的实现）
文件各种上传，离不开的表单

 
《一步步学习javascript基础篇》


一步步学习javascript基础篇（1）：基本概念


一步步学习javascript基础篇（2）：作用域和作用域链


一步步学习javascript基础篇（3）：Object、Function等引用类型


一步步学习javascript基础篇（4）：面向对象设计之创建对象（工厂、原型和构造函数等模式）


一步步学习javascript基础篇（5）：面向对象设计之对象继承（原型链继承）


一步步学习javascript基础篇（6）：函数表达式之【闭包】


一步步学习javascript基础篇（7）：BOM和DOM


一步步学习javascript基础篇（8）：事件【推荐】


一步步学习javascript基础篇（9）：ajax请求的回退


 
《一步步开发自己的博客 .NET版》

一步步开发自己的博客 .NET版（1、基本显示）
一步步搭建自己的博客 .NET版（2、评论功能）
一步步开发自己的博客 .NET版（3、注册登录功能）
一步步开发自己的博客 .NET版（4、文章发布功能）百度编辑器
一步步开发自己的博客 .NET版（5、Lucenne.Net 和 必应站内搜索）
一步步开发自己的博客 .NET版（6、响应式布局 和 自定义样式）【推荐】
一步步开发自己的博客 番外篇（7、异步记录日志 和 文章阅读量统计）
一步步开发自己的博客 番外篇（8、第三方登录及问题记录）
一步步开发自己的博客 .NET版（9、从model first替换成code first 问题记录）
一步步开发自己的博客 .NET版（10、前端对话框和消息框的实现）
一步步开发自己的博客 .NET版（11、Web.config文件的读取和修改）

 
《设计模式学习》
 

面向对象编程思想(前传)--你必须知道的javascript
面向对象编程思想--单例模式 [创建型]
面向对象编程思想--工厂模式 [创建型]
面向对象编程思想--组合模式 [结构型]
面向对象编程思想--适配器模式 [结构型]
面向对象编程思想--装饰模式 [结构型]
面向对象编程思想--享元模式 [结构型]
面向对象编程思想--代理模式 [结构型]
面向对象编程思想--策略模式 [行为型]
面向对象编程思想--观察者模式 [行为型]
面向对象编程思想--模板方法模式 [行为型]
面向对象编程思想--命令模式 [行为型]
面向对象编程思想--状态模式 [行为型]
面向对象编程思想--责任链模式 [行为型]
面向对象编程思想--中介者模式 [行为型]
面向对象编程思想--迭代器模式 [行为型]


 
《一些没有分类的文章》

我们为什么要坚持写博客【推荐】
各大招聘网站信息实时查询浏览
各大招聘网站信息实时查询浏览【二】

 
《推荐书单》

深入理解C#
大话设计模式
.net之美
你必须知道的.net
JavaScript高级程序设计
JavaScript设计模式与开发实践

 
article  19
title: C#异步的世界【下】
body: 
 
接上篇：《C#异步的世界【上】》
上篇主要分析了async\await之前的一些异步模式，今天说异步的主要是指C#5的async\await异步。在此为了方便的表述，我们称async\await之前的异步为“旧异步”，async\await为“新异步”。
新异步的使用
只能说新异步的使用太简单（如果仅仅只是说使用）
方法加上async修饰符，然后使用await关键字执行异步方法，即可。对就是如此简单。像使用同步方法逻辑一样使用异步。

 public async Task<int> Test()
 {
     var num1 = await GetNumber(1);
     var num2 = await GetNumber(num1);
     var task =  GetNumber(num2);
     //或者
     var num3 = await task;
     return num1 + num2 + num3;
 }

新异步的优势
在此之前已经有了多种异步模式，为什么还要引入和学习新的async\await异步呢？当然它肯定是有其独特的优势。
我们分两个方面来分析：WinForm、WPF等单线程UI程序和Web后台服务程序。
对于WinForm、WPF等单线程UI程序
代码1（旧异步）

private void button1_Click(object sender, EventArgs e)
{
    var request = WebRequest.Create("https://github.com/");
    request.BeginGetResponse(new AsyncCallback(t =>
    {
        //（1）处理请求结果的逻辑必须写这里
        label1.Invoke((Action)(() => { label1.Text = "[旧异步]执行完毕！"; }));//（2）这里跨线程访问UI需要做处理      
    }), null);
}

代码2（同步）

private void button3_Click(object sender, EventArgs e)
{
    HttpClient http = new HttpClient();
    var htmlStr = http.GetStringAsync("https://github.com/").Result;
    //（1）处理请求结果的逻辑可以写这里
    label1.Text = "[同步]执行完毕！";//（2）不在需要做跨线程UI处理了
}

代码3（新异步）

 private async void button2_Click(object sender, EventArgs e)
 {
     HttpClient http = new HttpClient();
     var htmlStr = await http.GetStringAsync("https://github.com/");
     //（1）处理请求结果的逻辑可以写这里
     label1.Text = "[新异步]执行完毕！";//（2）不在需要做跨线程UI处理了
 }

新异步的优势：

没有了烦人的回调处理
不会像同步代码一样阻塞UI界面（造成假死）
不在像旧异步处理后访问UI不在需要做跨线程处理
像使用同步代码一样使用异步（超清晰的逻辑）

 是的，说得再多还不如看看实际效果图来得实际：（新旧异步UI线程没有阻塞，同步阻塞了UI线程）

【思考】：旧的异步模式是开启了一个新的线程去执行，不会阻塞UI线程。这点很好理解。可是，新的异步看上去和同步区别不大，为什么也不会阻塞界面呢？
【原因】：新异步，在执行await表达式前都是使用UI线程，await表达式后会启用新的线程去执行异步，直到异步执行完成并返回结果，然后再回到UI线程（据说使用了SynchronizationContext）。所以，await是没有阻塞UI线程的，也就不会造成界面的假死。
【注意】：我们在演示同步代码的时候使用了Result。然，在UI单线程程序中使用Result来使异步代码当同步代码使用是一件很危险的事（起码对于不太了解新异步的同学来说是这样）。至于具体原因稍候再分析（哎呀，别跑啊）。
对于Web后台服务程序
也许对于后台程序的影响没有单线程程序那么直观，但其价值也是非常大的。且很多人对新异步存在误解。
【误解】：新异步可以提升Web程序的性能。
【正解】：异步不会提升单次请求结果的时间，但是可以提高Web程序的吞吐量。
1、为什么不会提升单次请求结果的时间？
其实我们从上面示例代码（虽然是UI程序的代码）也可以看出。
 
2、为什么可以提高Web程序的吞吐量？
那什么是吞吐量呢，也就是本来只能十个人同时访问的网站现在可以二十个人同时访问了。也就是常说的并发量。
还是用上面的代码来解释。[代码2] 阻塞了UI线程等待请求结果，所以UI线程被占用，而[代码3]使用了新的线程请求，所以UI线程没有被占用，而可以继续响应UI界面。
那问题来了，我们的Web程序天生就是多线程的，且web线程都是跑的线程池线程（使用线程池线程是为了避免不断创建、销毁线程所造成的资源成本浪费）,而线程池线程可使用线程数量是一定的，尽管可以设置，但它还是会在一定范围内。如此一来，我们web线程是珍贵的（物以稀为贵），不能滥用。用完了，那么其他用户请求的时候就无法处理直接503了。
那什么算是滥用呢？比如：文件读取、URL请求、数据库访问等IO请求。如果用web线程来做这个耗时的IO操作那么就会阻塞web线程，而web线程阻塞得多了web线程池线程就不够用了。也就达到了web程序最大访问数。
此时我们的新异步横空出世，解放了那些原本处理IO请求而阻塞的web线程（想偷懒？没门，干活了。）。通过异步方式使用相对廉价的线程（非web线程池线程）来处理IO操作，这样web线程池线程就可以解放出来处理更多的请求了。
不信？下面我们来测试下：
【测试步骤】:
1、新建一个web api项目 
2、新建一个数据访问类，分别提供同步、异步方法(在方法逻辑执行前后读取时间、线程id、web线程池线程使用数)

public class GetDataHelper
{
    /// <summary>
    /// 同步方法获取数据
    /// </summary>
    /// <returns></returns>
    public string GetData()
    {
        var beginInfo = GetBeginThreadInfo();
        using (HttpClient http = new HttpClient())
        {
            http.GetStringAsync("https://github.com/").Wait();//注意：这里是同步阻塞
        }
        return beginInfo + GetEndThreadInfo();
    }

    /// <summary>
    /// 异步方法获取数据
    /// </summary>
    /// <returns></returns>
    public async Task<string> GetDataAsync()
    {
        var beginInfo = GetBeginThreadInfo();
        using (HttpClient http = new HttpClient())
        {
            await http.GetStringAsync("https://github.com/");//注意：这里是异步等待
        }
        return beginInfo + GetEndThreadInfo();
    }

    public string GetBeginThreadInfo()
    {
        int t1, t2, t3;
        ThreadPool.GetAvailableThreads(out t1, out t3);
        ThreadPool.GetMaxThreads(out t2, out t3);
        return string.Format("开始:{0:mm:ss,ffff} 线程Id:{1} Web线程数:{2}",
                                DateTime.Now,
                                Thread.CurrentThread.ManagedThreadId,                                  
                                t2 - t1);
    }

    public string GetEndThreadInfo()
    {
        int t1, t2, t3;
        ThreadPool.GetAvailableThreads(out t1, out t3);
        ThreadPool.GetMaxThreads(out t2, out t3);
        return string.Format(" 结束:{0:mm:ss,ffff} 线程Id:{1} Web线程数:{2}",
                                DateTime.Now,
                                Thread.CurrentThread.ManagedThreadId,
                                t2 - t1);
    }
}

3、新建一个web api控制器

[HttpGet]
public async Task<string> Get(string str)
{
    GetDataHelper sqlHelper = new GetDataHelper();
    switch (str)
    {
        case "异步处理"://
            return await sqlHelper.GetDataAsync();
        case "同步处理"://
            return sqlHelper.GetData();
    }
    return "参数不正确";           
}       

4、发布web api程序，部署到本地iis(同步链接：http://localhost:803/api/Home?str=同步处理  异步链接：http://localhost:803/api/Home?str=异步处理) 
5、接着上面的winform程序里面测试请求：(同时发起10个请求)


private void button6_Click(object sender, EventArgs e)
{
    textBox1.Text = "";
    label1.Text = "";
    Task.Run(() =>
    {
        TestResultUrl("http://localhost:803/api/Home?str=同步处理");
    });
}

private void button5_Click(object sender, EventArgs e)
{
    textBox1.Text = "";
    label1.Text = "";
    Task.Run(() =>
    {
        TestResultUrl("http://localhost:803/api/Home?str=异步处理");
    });
}

public void TestResultUrl(string url)
{
    int resultEnd = 0;
    HttpClient http = new HttpClient();

    int number = 10;
    for (int i = 0; i < number; i++)
    {
        new Thread(async () =>
        {
            var resultStr = await http.GetStringAsync(url);
            label1.Invoke((Action)(() =>
            {
                textBox1.AppendText(resultStr.Replace(" ", "\r\t") + "\r\n");
                if (++resultEnd >= number)
                {
                    label1.Text = "全部执行完毕";
                }
            }));

        }).Start();
    }
}

View Code
6、重启iis，并用浏览器访问一次要请求的链接地址（预热）
7、启动winform程序，点击“访问同步实现的Web”：


8、重复6，然后重新启动winform程序点击“访问异步实现的Web”

看到这些数据有什么感想？
数据和我们前面的【正解】完全吻合。仔细观察，每个单次请求用时基本上相差不大。 但是步骤7"同步实现"最高投入web线程数是10,而步骤8“异步实现”最高投入web线程数是3。
也就是说“异步实现”使用更少的web线程完成了同样的请求数量，如此一来我们就有更多剩余的web线程去处理更多用户发起的请求。
接着我们还发现同步实现请求前后的线程ID是一致的，而异步实现前后线程ID不一定一致。再次证明执行await异步前释放了主线程。
【结论】：

使用新异步可以提升Web服务程序的吞吐量
对于客户端来说，web服务的异步并不会提高客户端的单次访问速度。
执行新异步前会释放web线程，而等待异步执行完成后又回到了web线程上。从而提高web线程的利用率。

【图解】：

Result的死锁陷阱
我们在分析UI单线程程序的时候说过，要慎用异步的Result属性。下面我们来分析：

private void button4_Click(object sender, EventArgs e)
{
    label1.Text = GetUlrString("https://github.com/").Result;
}

public async Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url);
    }
}

代码 GetUlrString("https://github.com/").Result 的Result属性会阻塞(占用)UI线程，而执行到GetUlrString方法的 await异步的时候又要释放UI线程。此时矛盾就来了，由于线程资源的抢占导致死锁。
且Result属性和.Wait()方法一样会阻塞线程。此等问题在Web服务程序里面一样存在。（区别：UI单次线程程序和web服务程序都会释放主线程，不同的是Web服务线程不一定会回到原来的主线程，而UI程序一定会回到原来的UI线程）
我们前面说过，.net为什么会这么智能的自动释放主线程然后等待异步执行完毕后又回到主线程是因为SynchronizationContext的功劳。
但这里有个例外，那就是控制台程序里面是没有SynchronizationContext的。所以这段代码放在控制台里面运行是没有问题的。

static void Main(string[] args)
{
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
    GetUlrString("https://github.com/").Wait();
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
    Console.ReadKey();
}

public async static Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
        return await http.GetStringAsync(url);
    }
}

打印出来的都是同一个线程ID
使用AsyncHelper在同步代码里面调用异步
但可是，可但是，我们必须在同步方法里面执行异步怎办？办法肯定是有的
我们首先定义一个AsyncHelper静态类：

static class AsyncHelper
{
    private static readonly TaskFactory _myTaskFactory = new TaskFactory(CancellationToken.None,
        TaskCreationOptions.None, TaskContinuationOptions.None, TaskScheduler.Default);

    public static TResult RunSync<TResult>(Func<Task<TResult>> func)
    {
        return _myTaskFactory.StartNew(func).Unwrap().GetAwaiter().GetResult();
    }

    public static void RunSync(Func<Task> func)
    {
        _myTaskFactory.StartNew(func).Unwrap().GetAwaiter().GetResult();
    }
}

然后调用异步：

private void button7_Click(object sender, EventArgs e)
{
    label1.Text = AsyncHelper.RunSync(() => GetUlrString("https://github.com/"));
}

这样就不会死锁了。
ConfigureAwait
除了AsyncHelper我们还可以使用Task的ConfigureAwait方法来避免死锁

private void button7_Click(object sender, EventArgs e)
{
    label1.Text = GetUlrString("https://github.com/").Result;
}

public async Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url).ConfigureAwait(false);
    }
}

ConfigureAwait的作用：使当前async方法的await后续操作不需要恢复到主线程（不需要保存线程上下文）。

异常处理
关于新异步里面抛出异常的正确姿势。我们先来看下面一段代码：

private async void button8_Click(object sender, EventArgs e)
{
    Task<string> task = GetUlrStringErr(null);
    Thread.Sleep(1000);//一段逻辑。。。。
    textBox1.Text = await task;
}

public async Task<string> GetUlrStringErr(string url)
{
    if (string.IsNullOrWhiteSpace(url))
    {
        throw new Exception("url不能为空");
    }
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url);
    }
}

调试执行执行流程：

在执行完118行的时候竟然没有把异常抛出来？这不是逆天了吗。非得在等待await执行的时候才报错，显然119行的逻辑执行是没有什么意义的。让我们把异常提前抛出：

提取一个方法来做验证，这样就能及时的抛出异常了。有朋友会说这样的太坑爹了吧，一个验证还非得另外写个方法。接下来我们提供一个没有这么坑爹的方式：

在异步函数里面用匿名异步函数进行包装，同样可以实现及时验证。
感觉也不比前种方式好多少...可是能怎么办呢。
异步的实现
上面简单分析了新异步能力和属性。接下来让我们继续揭秘异步的本质，神秘的外套下面究竟是怎么实现的。
首先我们编写一个用来反编译的示例：

class MyAsyncTest
{
    public async Task<string> GetUrlStringAsync(HttpClient http, string url, int time)
    {
        await Task.Delay(time);
        return await http.GetStringAsync(url);
    }
}

反编译代码：
点击看大图
为了方便阅读，我们把编译器自动命名的类型重命名。
 GetUrlStringAsync 方法变成了如此模样：

public Task<string> GetUrlStringAsync(HttpClient http, string url, int time)
{
    GetUrlStringAsyncdStateMachine stateMachine = new GetUrlStringAsyncdStateMachine()
    {
        _this = this,
        http = http,
        url = url,
        time = time,
        _builder = AsyncTaskMethodBuilder<string>.Create(),
        _state = -1
    };
    stateMachine._builder.Start(ref stateMachine);
    return stateMachine._builder.Task;
}

方法签名完全一致，只是里面的内容变成了一个状态机 GetUrlStringAsyncdStateMachine  的调用。此状态机就是编译器自动创建的。下面来看看神秘的状态机是什么鬼：

private sealed class GetUrlStringAsyncdStateMachine : IAsyncStateMachine
{
    public int _state;
    public MyAsyncTest _this;
    private string _str1;
    public AsyncTaskMethodBuilder<string> _builder;
    private TaskAwaiter taskAwaiter1;
    private TaskAwaiter<string> taskAwaiter2;    //异步方法的三个形参都到这里来了
    public HttpClient http;
    public int time;
    public string url;

    private void MoveNext()
    {
        string str;
        int num = this._state;
        try
        {
            TaskAwaiter awaiter;
            MyAsyncTest.GetUrlStringAsyncdStateMachine d__;
            string str2;
            switch (num)
            {
                case 0:
                    break;

                case 1:
                    goto Label_00CD;

                default:                    //这里是异步方法 await Task.Delay(time);的具体实现
                    awaiter = Task.Delay(this.time).GetAwaiter();
                    if (awaiter.IsCompleted)
                    {
                        goto Label_0077;
                    }
                    this._state = num = 0;
                    this.taskAwaiter1 = awaiter;
                    d__ = this;
                    this._builder.AwaitUnsafeOnCompleted<TaskAwaiter, MyAsyncTest.GetUrlStringAsyncdStateMachine>(ref awaiter, ref d__);
                    return;
            }
            awaiter = this.taskAwaiter1;
            this.taskAwaiter1 = new TaskAwaiter();
            this._state = num = -1;
        Label_0077:
            awaiter.GetResult();
            awaiter = new TaskAwaiter();            //这里是异步方法await http.GetStringAsync(url);的具体实现
            TaskAwaiter<string> awaiter2 = this.http.GetStringAsync(this.url).GetAwaiter();
            if (awaiter2.IsCompleted)
            {
                goto Label_00EA;
            }
            this._state = num = 1;
            this.taskAwaiter2 = awaiter2;
            d__ = this;
            this._builder.AwaitUnsafeOnCompleted<TaskAwaiter<string>, MyAsyncTest.GetUrlStringAsyncdStateMachine>(ref awaiter2, ref d__);
            return;
        Label_00CD:
            awaiter2 = this.taskAwaiter2;
            this.taskAwaiter2 = new TaskAwaiter<string>();
            this._state = num = -1;
        Label_00EA:
            str2 = awaiter2.GetResult();
            awaiter2 = new TaskAwaiter<string>();
            this._str1 = str2;
            str = this._str1;
        }
        catch (Exception exception)
        {
            this._state = -2;
            this._builder.SetException(exception);
            return;
        }
        this._state = -2;
        this._builder.SetResult(str);
    }

    [DebuggerHidden]
    private void SetStateMachine(IAsyncStateMachine stateMachine)
    {
    }

}

明显多个异步等待执行的时候就是在不断调用状态机中的MoveNext()方法。经验来至我们之前分析过的IEumerable,不过今天的这个明显复杂度要高于以前的那个。猜测是如此，我们还是来验证下事实：
在起始方法 GetUrlStringAsync 第一次启动状态机 stateMachine._builder.Start(ref stateMachine); 

 确实是调用了 MoveNext 。因为_state的初始值是-1，所以执行到了下面的位置：

绕了一圈又回到了 MoveNext 。由此，我们可以现象成多个异步调用就是在不断执行MoveNext直到结束。
说了这么久有什么意思呢，似乎忘记了我们的目的是要通过之前编写的测试代码来分析异步的执行逻辑的。
再次贴出之前的测试代码，以免忘记了。

反编译后代码执行逻辑图：

当然这只是可能性较大的执行流程，但也有 awaiter.Iscompleted 为 true 的情况。其他可能的留着大家自己去琢磨吧。 
 
本文已同步至索引目录：《C#基础知识巩固》
本文demo：https://github.com/zhaopeiym/BlogDemoCode
 
【推荐】
http://www.cnblogs.com/wisdomqq/archive/2012/03/29/2417723.html
 
article  20
title: 那些年搞不懂的术语、概念：协变、逆变、不变体
body: 
简述什么是协变性、逆变性、不变性

协变性，如：string->object （子类到父类的转换）
逆变性，如：object->string （父类到子类的转换）
不变性，基于上面两种情况，不可变。具体下面再做分析。

泛型委托的可变性
先使用框架定义的泛型委托Func和Action做例子（不了解的请戳）
协变：(string->object)

Func<string> func1 = () => "农码一生";
Func<object> func2 = func1;

逆变：(object->string)

Action<object> func3 = t => { };
Action<string> func4 = func3;

上面代码没有任何问题。
接着我们自己定义委托试试：

我X，看人不来哦。为什么自定义的委托却不能协变呢。
我看看系统定义的Func到底和我们自定义的有什么不同：

public delegate TResult Func<out TResult>();

多了一个out，什么鬼:

out：对于泛型类型参数，out 关键字指定该类型参数是协变的。 可以在泛型接口和委托中使用 out 关键字。（来源）
in：对于泛型类型参数，in 关键字指定该类型参数是逆变的。 可以在泛型接口和委托中使用 in 关键字。（来源）

那么我们可以修改自定义委托：

完美！
那如果我们要实现逆变性呢：

直接逆变是不可行的，我们需要修改泛型类型参数：

我们发现整个委托参数都变了。本来的返回值，改成输入参数才行。
结论：

in->输入参数->可逆变（父类到子类的转变[如 object->string]）
out->返回值->可协变（子类到父类的转变[如 string->object]）

 
假设：如果泛型参数中既存在in又存在out改如何：

delegate Tout MyFunc<in Tin, out Tout>(Tin obj);


MyFunc<object, string> str1 = t => "农码一生";
MyFunc<string, string> str2 = str1;//第一个泛型的逆变（object->string）
MyFunc<object, object> str3 = str1;//第二个泛型的协变（string->object）
MyFunc<string, object> str4 = str1;//第一个泛型的逆变和第二个泛型的协变

以上都是没有问题的。 
然后我们看看编译后的C#代码：

结论：

所谓的逆变其实只是编译后进行了强制类型转换而已。

以上代码也可以直接写成：

//delegate Tout MyFunc<in Tin, out Tout>(Tin obj);
MyFunc<string, string> str5 = t => "农码一生";
MyFunc<object, object> str6 = t => "农码一生";
MyFunc<string, object> str7 = t => "农码一生";

泛型接口的可变性
接着看框架默认接口：
协变：(子类->父类)

IEnumerable<string> list = new List<string>();
IEnumerable<object> list2 = list;

逆变：（父类-> 子类）

IComparable<object> list3 = null;
IComparable<string> list4 = list3;

接下来我们试试自定泛型接口：
首先定义测试类型、接口：

// 人
public class People
{ }
//老师(继承People[人])
public class Teacher : People
{ }
//运动
public interface IMotion<T>
{ }
//跑步
public class Run<T> : IMotion<T>
{ }

然后我们测试协变性：

同样我们需要把接口 interface IMotion<T> 定义为 interface IMotion<out T> 

//运动
public interface IMotion<out T>{}


IMotion<Teacher> x = new Run<Teacher>();
IMotion<People> y = x;

如果我们要测试逆变性，则需要把 interface IMotion<T>  定义为 interface IMotion<in T> 

//运动
public interface IMotion<in T>{}


IMotion<People> x2 = new Run<People>();
IMotion<Teacher> y2 = x2;

泛型接口的逆变，编译后同样进行了强制转换：

当然，我们也可以直接写成：

IMotion<Teacher> y3 = new Run<People>();

不变性
从上面我们知道逆变性的代码编译后都会进行强制转换。假设：那我们不用out、in直接手动强制转换是否可以？：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People { }
//运动
public interface IMotion<T> { }
//跑步
public class Run<T> : IMotion<T> { }


//协变
IMotion<Teacher> x = new Run<Teacher>();
IMotion<People> y = (IMotion<People>)x;

//逆变
IMotion<People> x2 = new Run<People>();
IMotion<Teacher> y2 = (IMotion<Teacher>)x2;
IMotion<Teacher> y3 = (IMotion<Teacher>)new Run<People>();

天才的我发现编译成功了，没有任何问题！且还可以同时协变、逆变？？不对，真的天才了吗？我们运行试试：


看来我还是太单纯了，如果真的这么容易绕过去，Microsoft又何必去搞个out、in关键字。
对于同一个泛型参数，我们既想有协变性又想逆变性，咋办？答案是不可行。这就会出现第三种情况，既不可以协变又不可以逆变。称为不变性。
如（我们在IMotion定义两个方法）：

//运动
public interface IMotion<T>
{
    T Show();
    void Match(T t);
}

上面我们测试过，代码直接强制转换是不能实现协变、逆变的。那么我们只能通过out、in来实现。如果现在我们在泛型参数添加out或in属性会如何？：


我们发现out和in都不能用。在用out时，有个传入参数为泛型 void Match(T t) 的方法。使用in时，有个返回参数为泛型 T Show() 的方法。现在就出现了是矛更锋利，还是盾更坚硬的问题了。
最后结果是：都不能用，既不能协变，也不能逆变。此为不变体。
小知识：
C#4.0之前 IEnumerable<T> 、 IComparable<T> 、 IQueryable<T> 等接口都不支持可变性，在4.0及之后才支持。因为4.0之前定义的泛型接口没有添加out、in关键字，有兴趣可以切换版本看看。
延伸思考
为什么in[输入参数]就只能逆变？分析如下：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People
{
    //薪水
    public decimal Salary { get; set; }
}

//运动
public interface IMotion<in T>
{
    void Match(T t);
}
//跑步
public class Run<T> : IMotion<T>
{
    public void Match(T t)
    {
        //假设中间有很多逻辑.....       
    }
}


为什么out[返回值]只能协变？分析如下：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People
{
    //薪水
    public decimal Salary { get; set; }
}

//运动
public interface IMotion<out T>
{
    T Show();
    //void Match(T t);
}
//跑步
public class Run<T> : IMotion<T>
{
    public T Show()
    {
        return default(T);
    }
    //public void Match(T t)
    //{
    //    //假设中间有很多逻辑.....         
    //}
}


这里有两个关键点：

传入参数（in）是把参数当成父类来用，显然可以逆变（子类当成父类来用[里氏替换原则]），但是却不可以把父类当子类来用（如：子类存在有而父类没有的方法或属性）。
返回值（out）返回值类型用父类来接收，显然可以协变（父类可以接收一切子类），但却不可用子类接收父类数据（如：父类代表的对象不能强制转给子类[string str = (string)objcet]）。

。。。是不是有点越想越头晕，想不明白就慢慢想。自己动动手。
如果实在想的头大，就把它当成是乌龟的屁股（龟腚\规定）吧，知道是C#做的一种安全限制！
总结
关于泛型接口、泛型委托的可变性：

协变 -> 比较和谐正常的变化 -> 子类转父类 [如 string转object] -> 必须有out标识 [返回值]
逆变 -> 逆天的变化 -> 父类转子类 [如object转string] -> 必须有in标识 [传入参数]  （父亲变儿子，越活越年轻，还不够逆天吗？）
所谓的逆变，会在编译后的C#代码中进行强制类型转换。
示例：


IEnumerable<string> list = new List<string>();  IEnumerable<object> list2 = list; //协变IEnumerable<object> list2 = new List<string>();  //(也可以直接写成这样)


IComparable<object> list3 = null;IComparable<string> list4 = list3; //逆变  编译后 [ IComparable<string> list4 = (IComparable<string>) list3;]



注意：

不支持类的类型参数的可变性
只有泛型接口和泛型委托可以拥有可变的类型参数（out、in）
可变性只支持引用转换。（不能用于值类型）
类型参数使用了 out 或者 ref 将禁止可变性

 
好了，今天就到这里。没啥高深的技术知识，主要为理解协变、逆变、不变体等术语和概念。
本文已同步至索引目录：《C#基础知识巩固》
 
同类文章推荐：
http://www.cnblogs.com/haoyifei/p/5760959.html
http://www.cnblogs.com/LoveJenny/archive/2012/03/13/2392747.html
http://www.cnblogs.com/Ninputer/archive/2008/11/22/generic_covariant.html
 
article  21
title: 面向对象编程思想(前传)--你必须知道的javascript
body: 
在写面向对象编程思想-设计模式中的js部分的时候发现很多基础知识不了解的话，是很难真正理解和读懂js面向对象的代码。为此，在这里先快速补上。然后继续我们的面向对象编程思想-设计模式。
什么是鸭子类型
javascript是一门典型的动态类型语言，也就弱类型语言。
那什么是鸭子类型：【如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子】
var 鸭子 = {
    走路: function () { },
    咕咕咕: function () { }
}

var 鹦鹉 = {
    走路: function () { },
    咕咕咕: function () { }
}
这只鹦鹉同样有“走路”和“咕咕咕”的方法，那在js的世界里就可以把它当成鸭子。
可以这样调用：
var 鸭子们 = [];
鸭子们.push(鸭子);
鸭子们.push(鹦鹉);

for (var i = 0; i < 鸭子们.length; i++) {
    鸭子们[i].走路();
}
所以js的世界没有抽象和接口，但可以约定“我们都是鸭子”。
javascript的面向对象
javascript不仅是直译式脚本语言、动态类型、弱类型语言、函数为一等公民的语言，它还是基于原型的面向对象语言。面向对象三大特性：封装、继承、多态，下面我们用js分别实现。
封装
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();

虽然老的js语法没有提供private等关键字，但是我们可以利用闭包来实现私有字段，达到封装的目的。
继承

字面量表示：
var Person = {
name: "农码一生",
getName: function () {
    console.log(this.name);
}
};
var obj = Person;
obj.getName();

函数构造器：

var Person = function () {
    this.name = "农码一生";    
}
Person.prototype.getName = function () {
    console.log(this.name);
}

var obj = function () { };
obj.prototype = new Person();//obj继承于Person

var o = new obj();
o.getName();//直接调用原型中的getName（类似于C#中的调用父类方法）

多态
对于多态，其实上面的鸭子类型已经表现的很清楚了。
var 鸭子们 = [];
鸭子们.push(鸭子);
鸭子们.push(鹦鹉);

for (var i = 0; i < 鸭子们.length; i++) {
    鸭子们[i].走路();//对于鹦鹉来说，它可能是跳着走。对于鸭子来说，它可能左右摇摆着走。这就是多态的表现。
}
对于鹦鹉来说，它可能是跳着走。对于鸭子来说，它可能左右摇摆着走。这就是多态的表现。
原型
什么是原型？在js中是没有类的，那它怎么创建对象。在C#中我们可以通过new关键字实例化一个对象，在js中我们用new关键字构造一个原型对象。C#中一切对象继承于Object，js中一切对象的原型是Object。
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
};
console.log(Person.prototype);

我们很多时候给一个对象添加方法的时候就是写在原型上，这是为什么？直接写在对象里会有问题吗？下面我们试试：
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
    this.getInfo = function () {
        console.log("name:" + this.name + ",sex:" + this.sex);
    }
};

好像并看不出什么问题。其实不然...

我们发现，每次构造出来的对象中的方法都会去开辟一个空间。但是对象的方法都是一样的，完全没有必要。 我们可以把方法放入原型。

这样一来，不过我们构造多少对象，其方法都是公用的（单例的）。
可是为什么会这样呢？
首先，想想原型这个词，很形象，原本的模型。我们来看一个继承的例子：
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
    this.getInfo = function () {
        console.log("name:" + this.name + ",sex:" + this.sex);
    }
};
var Student = function () { };
Student.prototype = new Person();//继承
var s1 = new Student();
var s2 = new Student();
console.log(s1.getInfo === s2.getInfo);

虽然getInfo在Person里面是直接实现的，但是到了Student的原型(prototype)里面就是一个Person对象的单例了。也就是说无论构造多少个Student对象其中的getInfo方法都是同一个。
但是，构造多个Person就有多个getInfo方法。所以，我们应该把getInfo方法放入Person的原型中。
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";   
};
Person.prototype.getInfo = function () {
    console.log("name:" + this.name + ",sex:" + this.sex);
};
我们仔细推敲下这句话“把getInfo方法放入Person的原型中”，Person的原型是Object，那也就是说getInfo方法放到Object里面去了？
是的，不信请看：

如果原型和原型的原型都实现了同样的方法呢？我们来猜猜下面会打印哪个版本
var Person = function () {
    this.name = "农码一生"; 
};
var Student = function () { }; 
Student.prototype = new Person();//继承
var stu = new Student();

Student.prototype.getName = function () {
    console.log("我的名字:" + this.name);
}
Person.prototype.getName = function () {
    console.log("My name is:" + this.name);
}

stu.getName();

如果注释掉中文版呢？

有没有觉得特神奇，具体原因我们用图来回答：

从另个一角度说，如果对象实现了原型中已有的方法那就等效于C#中虚方法重写了。
this指向
var name = "张三";
var obj = {
    name:"李四",
    getName: function(){
        console.log(this.name);
    }
}

obj.getName();

这个结果大家应该没什么疑问。
接着看下面的：
window.name = "张三";
var obj = {
    name:"李四",
    getName: function(){
        console.log(this.name);
    }
} 
//obj.getName();
window.func = obj.getName;
window.func();

晕了没有？没关系，告诉大家一个简单实用的方法：方法是被谁“.”出来的，this就指向的谁。
call
"方法是被谁“.”出来的，this就指向的谁"，这个口诀不一定适用所有方法。为什么这么说呢？请看下面：
window.name = "张三";
var obj = {
    name: "李四",
    getName: function () {
        console.log(this.name);
    }
}
//obj.getName();
window.func = obj.getName;
window.func.call(obj);

虽然还是window点的，但this已经指向了obj。
因为call可以改变this执行。
这个特性非常有用。比如，我们要编写一个下拉选中事件。
function func() {
    console.log("我点击了" + $(this).find("option:selected").text());
}

$("#element1").change(function () {
    func.call(this);
});
$("#element2").change(function () {
    func.call(this);
});
在写func方法的时候不用考虑具体是那个下拉框元素。
apply
apply和call区别不大。
function func(age, sex) {
    console.log("name:" + this.name + ",age:" + age + ",sex:" + sex);
}

var obj = {
    name: "晓梅"
}

func.call(obj, "18", "妹子");
func.apply(obj,["18","小美女"]);

call和apply第一个参数都是this指向的对象。call第二个和以后的参数对应方法func的参数。而apply的第二个参数是个数组，包含方法的所有参数。
band
function func(age, sex) {
    console.log("name:" + this.name + ",age:" + age + ",sex:" + sex);
}

var obj = {
    name: "晓梅"
}
var func1 = func.bind(obj, "18", "妹子");
func1();
和apply、call的区别是，只是改变this指向并不执行。且参数传入方式和call一样。
js中的闭包
什么是闭包？我的理解是存在不能被回收的变量就是闭包。
最常见最大的一个闭包就是全局变量，定义了就不会被销毁，除非自动设为null。
而我们平时说的和使用的闭包却非如此，但同样会产生不会被销毁的变量。比如我们之前说的私有变量示例：
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();
之所以说它是闭包，那是因为sex这个字段是永远不会被销毁。你想想，如果被销毁了，那我们调用getInfo的时候岂不是找不到sex字段了。所以不是不会销毁，而是不能销毁。
闭包的作用不仅仅是私有化。我们再来一例：
for (var i = 0; i < 10; i++) {
    var t = setTimeout(function () {
        console.log(i);
    }, 100);
}

并不是我们想象的那样打印0到9。
因为计时器还没开始循环就执行完了。而此时变量i已经是10。
我们可以通过闭包为每次循环保存一个闭包变量。
for (var i = 0; i < 10; i++) {
    (function (i) {
        var t = setTimeout(function () {
            console.log(i);
        }, 100);
    })(i);
}

什么是高阶函数
“高阶函数”名字特牛逼。其实我们在js中经常使用。
还是私有变量的例子：
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();

当函数做被return时，那么就是高阶函数。

var getInfo = function (callback) {
    $.ajax('url', function (data) {
        if (typeof callback === 'function') {
            callback(data);
        }
    });
}
getInfo(function (data) {
    alert(data.userName);
});

getInfo在执行的时候，传入的参数是个函数。

当函数被当成参数传递时，那么这也是高阶函数。

 
本文已同步至索引目录：《设计模式学习》
【demo】：https://github.com/zhaopeiym/BlogDemoCode
【推荐】：深入理解javascript原型和闭包系列
 

生命在于运动，静止是[ ]。


article  22
title: UML类图学习
body: 

下载Visio 地址

下载完毕，自行安装。至于破解，生在天朝的你必有的技能。
右键，新建 Microsoft Visio 绘图（我安装的是2013）
双击打开


现在我们就可以使用UML类图了。

最常用也就这几种了。
斜体【抽象类】
+公有（pubic）-私有（private）
《》【接口】
虚线空间三级【实现接口】
虚线箭头【依赖关系】
实线空心三角箭头【继承关系】

还有一些

其实很简单，Visio上都有明确的提示。画几次就熟悉了。
 

另外，vs中可以自动为已有的类创建UML类图。



效果还不错。
可能有人会说，vs17的查看类图取消了。
no，这么好的功能怎么会取消呢。那是因为你安装的时候没有安装这个组件。

怪不得17的安装速度要比之前的vs快那么多，好多东西都没有默认安装了。


article  23
title: 一步步学习javascript基础篇（9）：ajax请求的回退
body: 
需求1：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）

ajax异步请求没问题，问题一般出在刷新url后请求的数据没了，这就是因为url没有记录参数。如果我们改变给url添加参数，这样就改变了url，也就会重新请求整个url。这样一来就没有了ajax的优势和作用了。那么，我们应该怎么保持参数而又不重新请求url呢？做过单页面SPA (Single-page Application)的都知道，我们可以使用描点来实现(因为修改描点的时候，不会发送url的重新请求)。
如，博客园的分页就是如此
 
demo1：

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <style type="text/css">
        ul {
            list-style: none;
        }

            ul li {
                float: left;
                margin-left: 10px;
            }
    </style>
</head>
<body>
    <div style="color: red; margin-left: 50px; ">demo1（默认的回退效果）</div>
    <div>
        <ul>
            <li><a href="#tab1">tab1</a></li>
            <li><a href="#tab2">tab2</a></li>
            <li><a href="#tab3">tab3</a></li>
            <li><a href="#tab4">tab4</a></li>
            <li><a href="#tab5">tab5</a></li>
        </ul>

    </div>
    <input style="margin-left:15px" type="button" value="回退" onclick="history.go(-1)" />
    <a href="home.html">主页</a> 
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })
        $("ul").click(function (e) {

            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {//ajax的get请求
                //请求发送成功后修改页面元素内容
                $(".content").html("我是" + value);
            }, "text");
        });
    </script>
</body>
</html>

 
效果图：

我们认真看上面的gif动态图，会发现点击tab的ajax异步加载完全没问题，只是我们点击回退的时候 虽然url的描点变了，可是内容没变。（博客园的分页回退就是这个效果）这肯定是不太好的效果。（对history.go()不太了解的请戳）
 
需求2：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”页面要可以回到“主页”

通过观察上面的gif动图，我们发现回退的顺序正是，url的改变记录顺序。那我们在每次点击一个ajax请求累加一次计数，这样是不是就可以一次性退回“主页”呢？
demo2：

<input style="margin-left:15px" type="button" value="回退" onclick="go()" />
    <a href="home.html">主页</a>
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        var num = -1;
        $("ul").click(function (e) {
            num--;
            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
            }, "text");
        });

        function go() {
            history.go(num)
        }
    </script>

 
效果图：

ok，效果是我们要的。可是需求又说了，感觉这样还是不太好，回退应该是返回上一次的点击效果。
 
需求3：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果

拿到需求开始头痛了，怎么回退到上一次点击效果呢？有没有什么回退事件呢？还好H5给我们准备了 window.onpopstate url监听事件。
demo3:

<input style="margin-left:15px" type="button" value="回退" onclick="history.go(-1)" />
    <a href="home.html">主页</a>
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {         

            if (e.target.localName != "a") return;//如果点击的不是a标签直接返回

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
            }, "text");
        });

        if (history.pushState) {            
            window.onpopstate = function () {
                var hash = window.location.hash;
                $("ul").find("a[href='" + hash + "']").click();
            }
        } 
    </script>

效果图：

乍一看，好像很完美了（url和内容同时发生了对应的改变）。其实不然。我们debugger调试一看便知。

仔细看上图，你会发现  $("ul").click( a标签出现了两次点击事件（这明显是有瑕疵的），首先直接点击a标签触发，然后改变了url导致触发onpopstate事件，然后在onpopstate事件里面又一次点击a标签，最后导致了两次执行a标签点击事件。

那么如何，避免执行两次a标签的点击事件呢？思路肯定是怎样在修改url的时候不触发onpopstate事件，只有在前进和回退的时候触发。这里就要用到 history.pushState 了。
 
需求4：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果（但是不能执行多余代码）


 <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {
            debugger
            e.preventDefault();//不要执行与事件关联的默认动作

            if (e.target.localName != "a") return;//如果点击的不是a标签直接返回

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
                if (e && e.clientX) //用来判断是否是鼠标点击触发
                    history.pushState(null, value, location.href.split("#")[0] + value);//塞入历史记录，并改变当前url
            }, "text");
        });

        if (history.pushState) {
            window.onpopstate = function () {
                debugger;
                var hash = window.location.hash;
                $("ul").find("a[href='" + hash + "']").click();
                debugger
            }
        }
    </script>

（这需要注意  if (e && e.clientX) //用来判断是否是鼠标点击触发 如果没有这句，那么每次触发onpopstate 的时候往历史记录里面塞进去一条，那样就死循环出不来了。）
效果图：

明显可以看出只执行了一次a标签的点击事件，且回退功能也是正常。按道理，现在已经是完美了。不过，我们回过头来想想，我们为什么一定要使用锚点来记录参数呢。以前是因为修改锚点不会重新请求url而巧用了锚点。现在我们通过history.pushState把url塞入历史记录的时候，也改变了当前url且也没有对url发送请求，那我们是不是没有必要使用锚点了呢？答案是确定的。
 
需求4：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果（不使用描点）

其实，直接把上面代码修改部分就可以了。
demo4：

 <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = location.href.split("?")[1];
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {
            e.preventDefault();//不要执行与事件关联的默认动作

            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            if (e && e.clientX) //用来判断是否是鼠标点击触发
                history.pushState(null, null, location.href.split("?")[0] + "?" + value);//塞入历史记录，并改变当前url
            $.get("temp.html", value, function (obj) {
                document.title = value;
                $(".content").html("我是" + value);
            }, "text");
        });

        if (history.pushState) {
            window.addEventListener("popstate", function () {
                var hash = location.href.split("?")[1];
                $("ul").find("a[href='" + hash + "']").click();
            });
        }
    </script>

 
效果图：

 
完整演示地址：http://hi.haojima.net/demo/history/home.html
 

以上内容都是胡说八道。
好了，关于ajax回退效果就分析到这里了。感谢您的阅读，希望对您有一点点作用。
文章首链：http://www.cnblogs.com/zhaopei/p/5637889.html

 
article  24
title: 五、谈扩展方法的理解
body: 
为什么要用扩展方法
在说什么是扩展方法之前我们先来说说为什么要用扩展方法。
首先我们定义一个 Person 类：

public class Person
{
    /// <summary>
    /// 出生日期
    /// </summary>
    public DateTime BirthTime { get; set; }
    /// <summary>
    /// 死亡日期
    /// </summary>
    public DateTime? DeathTime { get; set; }
    //、、、、、、
}

加入这个类来自第三方的dll引用，且现在我们需要添加一个方法 GetAge 获取年龄。你可能会想到自己定一个子类继承：

public class MyPerson : Person
{
    public int GetAge()
    {
        if (DeathTime.HasValue)
            return (DeathTime.Value - BirthTime).Days / 365;
        else
            return (DateTime.Now - BirthTime).Days / 365;
    }
}

是的，这样可以实现我们的需求。不过实现新增的方法就去继承真的是最合适的吗（暂且不说）？ 如果上面定义的密封类呢？ public sealed class Person ，这个时候是不能继承的，我们只能另想办法。
随意写个静态类：

public static class ExtensionClass
{
    public static int GetAge(Person person)
    {
        if (person.DeathTime.HasValue)
            return (person.DeathTime.Value - person.BirthTime).Days / 365;
        else
            return (DateTime.Now - person.BirthTime).Days / 365;
    }

然后调用  age = ExtensionClass.GetAge(p); ，是的看似不错。可是这和我们说的扩展方法有什么关系呢？下面就是见证奇迹的时候了。

其他的任何地方都不变，唯一变化的是在参数前面加里this关键字。对，是的，仅仅如此它就变成了我们今天要讲的扩展方法。
调用如：  var age = p.GetAge(); 相比上面的 age = ExtensionClass.GetAge(p); 更简单明了。
这里我们说的是在需要扩展密封类的方法时，我们可以使用到扩展方法。还有一种情况就是，在需要扩展接口的时候时候我们更加需要。比如，需要扩展IList的排序。我们要么写个扩展方法，要么是继承实现接口（会强制要求实现接口下的所有方法）。我想你心中已经有了答案选择哪种方式。
扩展方法到底是什么
我们看到上面使用的扩展方法，有没有感觉很神奇。仅仅多添加了一个this关键字就直接可以当成扩展方法使用了。那扩展方法到底是什么东东，看了上面代码好像和静态方法有着说不清道不明的关系。下面我们继续分析：
分别定义一个静态方法和一个扩展方法

 public static class ExtensionClass
 {
     public static int GetAge2(Person person)
     {
         if (person.DeathTime.HasValue)
             return (person.DeathTime.Value - person.BirthTime).Days / 365;
         else
             return (DateTime.Now - person.BirthTime).Days / 365;
     }

     public static int GetAge(this Person person)
     {
         if (person.DeathTime.HasValue)
             return (person.DeathTime.Value - person.BirthTime).Days / 365;
         else
             return (DateTime.Now - person.BirthTime).Days / 365;
     }

分别调用：

var p = new Person() { BirthTime = DateTime.Parse("1990-07-19") };
var age = p.GetAge();
age = ExtensionClass.GetAge2(p);

编译后的IL代码：

我们看到反编译成IL之后发现两者并无不同。所以，我理解成（扩展方法本质上就是静态方法，之所以出现扩展方法是C#以另外一种形式表现静态方法而已。只有有何妙用下面会继续讲解）。且 编译后同样带上了静态类名。
扩展方法可以做些什么

把已有的静态方法转成扩展方法：如：


public static bool IsNullOrEmpty(this string str)
{
    return string.IsNullOrEmpty(str);
}

调用： 

string str = null;
var isNull = str.IsNullOrEmpty();

 感觉相比期静态方法调用要优雅，更接近我们的自然语言。

 可以编写很多的帮助类，如（以string为例）：



/// <summary>
        /// 转DateTime 
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static DateTime? MyToDateTime(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return null;
            else
                return DateTime.Parse(str);
        }

        /// <summary>
        /// 转double
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static double MyToDouble(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return -1;
            else
                return double.Parse(str);
        }

        /// <summary>
        /// 转int
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static int MyToInt(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return -1;
            else
                return int.Parse(str);
        }

        /// <summary>
        /// 指示指定的字符串是 null 还是 System.String.Empty 字符串。
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsNullOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str);
        }

        /// <summary>
        /// 如果字符串为null，则返回空字符串。（否则返回原字符串）
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static string GetValueOrEmpty(this string str)
        {
            if (str.IsNullOrEmpty())
                return string.Empty;
            return str;
        }

View Code
上面所有的都只是扩展方法的附加用处，扩展方法真正的威力是为Linq服务的（主要体现于IEnumerable和IQueryable），实现链式编程。下面我们自己来实现所谓的链式编程：
初始化 Person 集合。

List<Person> persons = new List<Person>() 
{
     new Person(){ BirthTime=DateTime.Parse("1990-01-19")},
     new Person(){ BirthTime=DateTime.Parse("1993-04-17")},
     new Person(){ BirthTime=DateTime.Parse("1992-07-19"), DeathTime=DateTime.Parse("2010-08-18")},
     new Person(){ BirthTime=DateTime.Parse("1990-03-14")},
     new Person(){ BirthTime=DateTime.Parse("1991-08-15")},
     new Person(){ BirthTime=DateTime.Parse("1993-07-29")},
     new Person(){ BirthTime=DateTime.Parse("1991-06-19")}
};

需求：1.查询活人。2.按出生日期排序

public static class ExtensionClass
    {
        /// <summary>
        /// 按条件查询
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyWhere<T>(this IList<T> list, Func<T, bool> func)
        {
            List<T> newList = new List<T>();
            foreach (var item in list)
            {
                if (func(item))
                    newList.Add(item);
            }
            return newList;
        }

        /// <summary>
        /// 升序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderBy<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = i + 1; j < list.Count(); j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks > 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
        /// <summary>
        /// 降序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderByDescending<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = 1; j < list.Count() - i; j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks < 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
    }

调用：（这里仅仅为了演示，所以不要讨论实现是否合理、算法是否高效。）

var newPersons = persons.MyWhere(t => t.DeathTime == null).MyOrderByDescending(t => t.BirthTime);
foreach (var item in newPersons)
{
    Console.WriteLine(item.BirthTime);
}

就是如此简单的实现了所谓的函数式编程。结果图如下：

这样一句代码搞定所有逻辑，像自然语言般的流畅。其实.net为IEnumerable实现了这样的扩展，如：

执行结构和上面一模一样。
 
其实扩展方法也可以当成静态方法来使用：

 var p1 = ExtensionClass.MyWhere(persons, t => t.DeathTime == null);
 var p2 = ExtensionClass.MyOrderByDescending(p1, t => t.BirthTime);
 var p3 = ExtensionClass.MyOrderBy(p2, t => t.BirthTime);

（不信？继续看，有图有真相）
 
C#代码：
 
反编译C#的代码：（你是不是看到了，编译后直接就是使用的扩展方法的形式。）

反编译的IL代码：

虽然编译后的代码是一样的，但是做为程序员的我们更喜欢哪种方式呢？
 
总结：
我们在对扩展方法的怎么使用疑惑或者忘记了规则的时候，我们不用去查找资料说：

第一个参数是要扩展或者要操作的类型,这称为"被扩展的类型"
为了指定扩展方法,要在被扩展的类型名称前面附加this修饰符
要将方法作为一个扩展方法来访问,要用using指令导入扩展类型的命名空间,或者使扩展类型和调用代码在同一个命名空间中.

我们只需记住，当你不知道怎么编写或使用扩展方法时，你先把它当成静态方法编写或使用。如果可行，一般都可以转成扩展方法的形式。
 
全部代码：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using System.Data.Entity.Utilities;
using System.Diagnostics.CodeAnalysis;
using NPOI.HSSF.UserModel;
using NPOI.SS.UserModel;
using System.IO;

namespace test
{


    class Program
    {
        static void Main(string[] args)
        {
            /*             
             * 1.工具类
             * 2.链式编程
             */
            string str = null;
            var isNull = str.IsNullOrEmpty();

            var p = new Person() { BirthTime = DateTime.Parse("1990-07-19") };
            var age = p.GetAge();
            age = ExtensionClass.GetAge2(p);

            List<Person> persons = new List<Person>() 
            {
                 new Person(){ BirthTime=DateTime.Parse("1990-01-19")},
                 new Person(){ BirthTime=DateTime.Parse("1993-04-17")},
                 new Person(){ BirthTime=DateTime.Parse("1992-07-19"), DeathTime=DateTime.Parse("2010-08-18")},
                 new Person(){ BirthTime=DateTime.Parse("1990-03-14")},
                 new Person(){ BirthTime=DateTime.Parse("1991-08-15")},
                 new Person(){ BirthTime=DateTime.Parse("1993-07-29")},
                 new Person(){ BirthTime=DateTime.Parse("1991-06-19")}
            };

            var newPersons = persons.MyWhere(t => t.DeathTime == null).MyOrderByDescending(t => t.BirthTime);


            var p1 = ExtensionClass.MyWhere(persons, t => t.DeathTime == null);
            var p2 = ExtensionClass.MyOrderByDescending(p1, t => t.BirthTime);
            var p3 = ExtensionClass.MyOrderBy(p2, t => t.BirthTime);

            foreach (var item in newPersons)
            {
                Console.WriteLine(item.BirthTime);
            }
            Console.ReadKey();
        }
    }

    public sealed class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BirthTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public DateTime? DeathTime { get; set; }
    }

    //public class MyPerson : Person
    //{
    //    public int GetAge()
    //    {
    //        if (DeathTime.HasValue)
    //            return (DeathTime.Value - BirthTime).Days / 365;
    //        else
    //            return (DateTime.Now - BirthTime).Days / 365;
    //    }
    //}
    public static class ExtensionClass
    {
        /// <summary>
        /// 按条件查询
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyWhere<T>(this IList<T> list, Func<T, bool> func)
        {
            List<T> newList = new List<T>();
            foreach (var item in list)
            {
                if (func(item))
                    newList.Add(item);
            }
            return newList;
        }

        /// <summary>
        /// 升序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderBy<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = i + 1; j < list.Count(); j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks > 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
        /// <summary>
        /// 降序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderByDescending<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = 1; j < list.Count() - i; j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks < 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }

        public static int GetAge2(Person person)
        {
            if (person.DeathTime.HasValue)
                return (person.DeathTime.Value - person.BirthTime).Days / 365;
            else
                return (DateTime.Now - person.BirthTime).Days / 365;
        }

        public static int GetAge(this Person person)
        {
            if (person.DeathTime.HasValue)
                return (person.DeathTime.Value - person.BirthTime).Days / 365;
            else
                return (DateTime.Now - person.BirthTime).Days / 365;
        }

        public static bool IsNullOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str);
        }
    } 
}

View Code
 
本文以同步至《C#基础知识巩固系列》
article  25
title: 一步步开发自己的博客 .NET版（10、前端对话框和消息框的实现）
body: 
关于前端对话框、消息框的优秀插件多不胜数。造轮子是为了更好的使用轮子，并不是说自己造的轮子肯定好。所以，这个博客系统基本上都是自己实现的，包括日志记录、响应式布局、评论功能等等一些本可以使用插件的。好了，废话不多时。我们来实现自己的对话框和消息框。
对话框
要求：可拖动、点击按钮后可回调

画一个简单的模型框


<div class="hi-dialog-box clearfix">
        <div class="hi-dialog-title">系统提示</div>
        <div class="hi-dialog-content">
        </div>
        <div class="hi-dialog-foot">
            <input type="button" class="hi-dialog-determine" value="确定" />
            <input type="button" class="hi-dialog-cancel" value="取消" />
        </div>
</div>

 

添上基本的样式



 div.hi-dialog-box {
            border: 1px #808080 solid;
            width: 350px;
            height: 200px;                    
            border-radius: 3px;
        }

            div.hi-dialog-box div.hi-dialog-title {
                border: 1px #808080 solid;
                margin: 1px;
                padding: 1px;
                background-color: #dedcdc;
                height: 14%;
                cursor: move;
                font-size: 20px;
            }

            div.hi-dialog-box div.hi-dialog-content {
                height: 65%;
                margin: 5px;            
            }

            div.hi-dialog-box div.hi-dialog-foot {
                margin: 1px;
                padding: 1px;
                height: 14%;
            }

                div.hi-dialog-box div.hi-dialog-foot input {
                    float: right;
                    margin-left: 5px;
                    font-size: 16px;
                }

View Code
效果图：

是不是像那么回事了，不过现在还不能拖动。拖动，说白了就是在鼠标移动的时候不停的修改绝对定位。
首先修改以下样式：

用js代码实现拖动效果：

//鼠标按下时
        $("div.hi-dialog-title").mousedown(function (event) {
            $("html").unbind();//首先清除事件方法
            var click_clientX = event.clientX;//记录鼠标按下时相对当前窗口的 x 坐标
            var click_clientY = event.clientY;//记录鼠标按下时相对当前窗口的 y 坐标
            //取的对话框容器
            var dialogBox = $(this).closest("div.hi-dialog-box");
            //记录对话框容器当前位置
            var dialogBoxX = parseInt($(dialogBox).css("left"));
            var dialogBoxY = parseInt($(dialogBox).css("top"));
            //鼠标移动时
            $("html").mousemove(dialog_mousemove = function (event) {
                //鼠标按下后移动量加上原来的位置
                var top = event.clientY - click_clientY + dialogBoxY;
                var left = event.clientX - click_clientX + dialogBoxX;
                //修改对话框位置（这里就实现了移动效果了）
                $(dialogBox).css({ "left": left, "top": top });
            });
            //鼠标按键松开时
            $("html").mouseup(function () {
                //清除鼠标移动事件
                $("html").unbind("mousemove", dialog_mousemove);
            });
        });

如果使用jquery.min.js，拖动一句代码搞定： $("div.hi-dialog-title").draggable(); 
 
以上js代码就实现了对话框的拖动效果。首先，只有当鼠标在对话框标题区域按下鼠标才可以拖动，然后鼠标移动的的时候实时计算和改变容器的位置，最后如果鼠标按键松开这清除鼠标移动事件。


点击按钮后可回调

很多时候，我们点击确定或取消的时候我们需要执行回调（比如“您是否删除”，点击了确定后肯定需要做删除操作）。

如此，我们点击确定的时候会自动关闭对话框并可以执行自己需要执行的一些操作。可以，有同学会说，你这算什么狗屁对话框啊，html代码全都需要直接编码。是的，这只是简单的说下思路，下面我们来简单整理下。

效果图：

全部代码：（当然，这只是简单实现。还有很多需要继续细化的效果，如：背景遮罩、如果实现点击多次对话框）


  1 <!DOCTYPE html>
  2 <html xmlns="http://www.w3.org/1999/xhtml">
  3 <head>
  4     <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  5     <title></title>
  6     <style type="text/css">
  7         * {
  8             box-sizing: border-box;
  9         }
 10 
 11         .clearfix:after {
 12             content: ' ';
 13             display: table;
 14             clear: both;
 15         }
 16 
 17         .clearfix {
 18             *zoom: 1;
 19         }
 20 
 21         div.hi-dialog-box {
 22             border: 1px #808080 solid;
 23             width: 350px;
 24             height: 200px;
 25             position: absolute;
 26             top: 200px;
 27             left: 40%;
 28             border-radius: 3px;
 29         }
 30 
 31             div.hi-dialog-box div.hi-dialog-title {
 32                 border: 1px #808080 solid;
 33                 margin: 1px;
 34                 padding: 1px;
 35                 background-color: #dedcdc;
 36                 height: 14%;
 37                 cursor: move;
 38                 font-size: 20px;
 39             }
 40 
 41             div.hi-dialog-box div.hi-dialog-content {
 42                 height: 65%;
 43                 margin: 5px;
 44                 overflow: auto;
 45             }
 46 
 47             div.hi-dialog-box div.hi-dialog-foot {
 48                 margin: 1px;
 49                 padding: 1px;
 50                 height: 14%;
 51             }
 52 
 53                 div.hi-dialog-box div.hi-dialog-foot input {
 54                     float: right;
 55                     margin-left: 5px;
 56                     font-size: 16px;
 57                 }
 58     </style>
 59 </head>
 60 <body>
 61     <input value="对话框（确定）" onclick="click1();" type="button" />
 62     <input value="对话框（确定、取消）" onclick="click2();" type="button" />
 63     <div class="messg" style="margin: 10px; color: red; font-size: 23px"></div>
 64 
 65     <script src="../../Scripts/jquery-1.8.2.js"></script>
 66     <script type="text/javascript">
 67         var hiDialog = {
 68             init: function (title, messg, determineCallback, cancelCallback) {
 69 
 70                 title = title || "系统提示";
 71                 var determine = "", cancel = "";
 72                 if (typeof (determineCallback) == "function")
 73                     determine = '<input type="button" class="hi-dialog-determine" value="确定" />';
 74                 if (typeof (cancelCallback) == "function")
 75                     cancel = '<input type="button" class="hi-dialog-cancel" value="取消" />';
 76 
 77                 if (!$("div.hi-dialog-box").length) {
 78                     var hi_dialog_box = '<div class="hi-dialog-box clearfix">\
 79                                     <div class="hi-dialog-title"></div>\
 80                                     <div class="hi-dialog-content">\
 81                                     </div>\
 82                                     <div class="hi-dialog-foot">\
 83                                     </div>\
 84                                 </div>';
 85                     $("body").append(hi_dialog_box);
 86                 }
 87 
 88                 var $box = $("div.hi-dialog-box");
 89                 $box.find("div.hi-dialog-title").html(title);
 90                 $box.find("div.hi-dialog-content").html(messg);
 91                 $box.find("div.hi-dialog-foot").html(determine + cancel);
 92                 $("div.hi-dialog-box").show();
 93 
 94                 $box.find(".hi-dialog-determine").click(function () {
 95                     determineCallback();
 96                     hiDialog.close();
 97                 });
 98                 $box.find(".hi-dialog-cancel").click(function () {
 99                     cancelCallback();
100                     hiDialog.close();
101                 });
102 
103                 //鼠标按下时
104                 $("div.hi-dialog-title").mousedown(function (event) {
105                     $("html").unbind();
106                     var click_clientX = event.clientX;
107                     var click_clientY = event.clientY;
108                     var dialogBox = $(this).closest("div.hi-dialog-box");
109                     var dialogBoxX = parseInt($(dialogBox).css("left"));
110                     var dialogBoxY = parseInt($(dialogBox).css("top"));
111                     //鼠标移动时
112                     $("html").mousemove(dialog_mousemove = function (event) {
113                         var top = event.clientY - click_clientY + dialogBoxY;
114                         var left = event.clientX - click_clientX + dialogBoxX;
115                         $(dialogBox).css({ "left": left, "top": top });
116                     });
117                     //鼠标按键松开时
118                     $("html").mouseup(function () {
119                         $("html").unbind("mousemove", dialog_mousemove);
120                     });
121                 });
122             },
123             close: function () {
124                 $("div.hi-dialog-box").hide();
125             }
126         }
127     </script>
128     <script type="text/javascript">
129         function click1() {
130             hiDialog.init("系统提示！", "测试", function () {
131                 //点击确定后的回调执行
132                 $(".messg").text("点击了确定");
133             });
134         }
135 
136         function click2() {
137             hiDialog.init("系统对话框~~", "什么乱七八糟的啊...", function () {
138                 $(".messg").text("点击了确定~~~");
139             }, function () {
140                 $(".messg").text("点击了取消~~");
141             });
142         }
143     </script>
144 </body>
145 </html>

View Code
 
消息框
要求：自动定时关闭消息框、有消息分类（如：警告、错误、成功等）

画一个简单的模型框


<div class="hi-message-box">
        <img class="hi-message-type" src="" />
        <span class="hi-message-messg">你不爱我了~~</span>
    </div>

 

添上基本样式


<style type="text/css">
        div.hi-message-box {
            padding: 10px;
            padding-top: 15px;
            padding-bottom: 20px;
            background-color: #aee0c1;         
            min-width: 200px;
            max-width: 500px;
            font-size: 19px;
            border-radius: 3px;
        }
 </style>

 
效果图：

看上去是不是很简单呢？下面我们给它加上定时关闭消息功能。

定时关闭消息（表骂我，就是这么简单。我也想写复杂的。）


 setTimeout(function () {
            $("div.hi-message-box").fadeOut("slow");
}, 1200);

 
效果图：


加上消息类型（其实就是根据参数加不同的图片而已）


 setTimeout(function () {
            $("div.hi-message-box").fadeOut("slow");
        }, 1200);
  var $box = $("div.hi-message-box");
  $box.find("img.hi-message-type").attr("src", "imgs/Warning_24px.png")

 
 效果图：

加上图标是不是更像那么回事了？
如上，我们同样需要稍微整理下实现代码：

效果图：

全部代码：（同样，消息框也只是进行了简单实现。还有太多没有考虑，如（参数定位消息框位置、设置定时关闭时间、多次触发消息框））


 1 <!DOCTYPE html>
 2 <html xmlns="http://www.w3.org/1999/xhtml">
 3 <head>
 4     <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 5     <title></title>
 6     <style type="text/css">
 7         * {
 8             box-sizing: border-box;
 9         }
10 
11         .clearfix:after {
12             content: ' ';
13             display: table;
14             clear: both;
15         }
16 
17         .clearfix {
18             *zoom: 1;
19         }
20 
21         div.hi-message-box {
22             padding: 10px;
23             padding-top: 15px;
24             padding-bottom: 20px;
25             background-color: #aee0c1;
26             position: absolute;
27             min-width: 200px;
28             max-width: 500px;
29             font-size: 19px;
30             border-radius: 3px;
31             top:200px;
32             left:45%;
33         }
34 
35             div.hi-message-box img {
36                 vertical-align: bottom;
37             }
38     </style>
39 </head>
40 <body>
41     <input type="button" onclick="success();" value="成功消息" />
42     <input type="button" onclick="error();" value="失败消息" />
43     <input type="button" onclick="warn();" value="警告消息" />
44     <script src="../../Scripts/jquery-1.8.2.js"></script>
45     <script type="text/javascript">
46         var hiMessageBox = {
47             init: function (type, messg) {
48                 var hiMessageBox = '<div class="hi-message-box">\
49                                     <img class="hi-message-type" src="" />\
50                                     <span class="hi-message-messg"></span>\
51                                 </div>';
52 
53 
54                 if (!$("div.hi-message-box").length) {
55                     $("body").append(hiMessageBox);
56                 }
57                 var $box = $("div.hi-message-box");
58                 $box.find(".hi-message-messg").text(messg);
59                 switch (type) {
60                     case 0://success 成功
61                         $box.find("img.hi-message-type").attr("src", "imgs/Tick_24px.png")
62                         break;
63                     case 1://warn 警告
64                         $box.find("img.hi-message-type").attr("src", "imgs/Warning_24px.png")
65                         break;
66                     case 2://
67                         $box.find("img.hi-message-type").attr("src", "imgs/Delete_24px.png")
68                         break;
69                 }
70                 $("div.hi-message-box").fadeIn("slow")
71                 setTimeout(function () {
72                     $("div.hi-message-box").fadeOut("slow");
73                 }, 1200);
74             },
75             success: function (messg) {
76                 this.init(0, messg); 
77             },
78             warn: function (messg) {
79                 this.init(1, messg);
80             },
81             error: function (messg) {
82                 this.init(2, messg);
83             }
84         };      
85     </script>
86     <script type="text/javascript">
87         function success() {
88             hiMessageBox.success("成功");
89         }
90         function error() {
91             hiMessageBox.error("失败");
92         }
93         function warn() {
94             hiMessageBox.warn("警告");
95         }
96     </script>
97 </body>
98 </html>

View Code
 
演示地址：对话框演示地址  消息框演示地址
 

《一步步搭建自己的博客》
关于简单实现自己的对话框和消息框就到这里了。感谢您的阅读，希望对您有一点点作用。
文章首链：http://www.cnblogs.com/zhaopei/p/MessageBox_DialogBox.html

 
article  26
title: 四、可空类型Nullable<T>到底是什么鬼
body: 
值类型为什么不可以为空
首先我们都知道引用类型默认值都是null，而值类型的默认值都有非null。

为什么引用类型可以为空？因为引用类型变量都是保存一个对象的地址引用（就像一个url对应一个页面）,而引用类型值为null的时候是变量值指向了一个空引用（如同一个空的url）

那为什么值不能有空值呢？其实很简单，因为如int值范围是-2147483648到2147483647。其中根本就没有给null值留那么一个位置。

我们为什么需要用到可空类型
举个栗子吧，我们定义一个人（Person），它有三个属性出生日期（BeginTime）、死亡日期（EndTime）、年龄（Age）。
如果这个人还健在人世，请问怎么给死亡日期赋值？有人很聪明说“为空啊”。是的，这就是我们的需求。
微软在C#2.0的时候就为我们引入了可null值类型（ System.Nullable<T> ），那么下面来定义Person类。

 1 public class Person
 2 {
 3     /// <summary>
 4     /// 出生日期
 5     /// </summary>
 6     public DateTime BeginTime { get; set; }
 7     /// <summary>
 8     /// 死亡日期
 9     /// </summary>
10     public System.Nullable<DateTime> EndTiem { get; set; }
11     public int Age
12     {
13         get
14         {
15             if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
16             {
17                 return (EndTiem.Value - BeginTime).Days;
18             }
19             else//还没挂
20             {
21                 return (DateTime.Now - BeginTime).Days;
22             }
23         }
24     }
25 }

 
这样，我们就可以很容易获得一个人的年龄了。

static void Main(string[] args)
{
    Person p1 = new Person()
    {
        BeginTime = DateTime.Parse("1990-07-19")
    };

    Person p2 = new Person()
    {
        BeginTime = DateTime.Parse("1893-12-26"),
        EndTiem = DateTime.Parse("1976-09-09")
    };

    Console.WriteLine("我今年" + p1.Age + "岁。");
    Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");

    Console.ReadKey();
}

可空类型的实现
我们前面用到了 System.Nullable<DateTime> 来表示可空时间类型，其实平时我们用得更多的是 DateTime? 直接在类型T后面加一个问号，这两种是等效的。多亏了微软的语法糖。
我们来看看 System.Nullable<T> 到底是何物。

搜噶，原来是一个结构。还看到了我们属性的 HasValue和Value属性。原来竟这般简单。一个结构两个属性，一个存值，一个存是否有值。那么下面我们也来试试吧。

不好意思，让大家失望了。前面我们就说过了，值类型是不可以赋值null的(结构也是值类型)。
怎么办！怎么办！不对啊，微软自己也是定义的结构，它怎么可以直接赋值null呢。（奇怪，奇怪，毕竟是人家微软自己搞得，可能得到了特殊的待遇吧）
可是，这样就让我们止步了吗？NO!我们都知道，看微软的IL（中间语言）的时候，就像脱了它的衣服一样，很多时候不明白的地方都可以看个究竟，下面我们就去脱衣服。
首先，我们用几种不同的方式给可空类型赋值。

static void Main(string[] args)
{

    System.Nullable<int> number1 = null;

    System.Nullable<int> number2 = new System.Nullable<int>();

    System.Nullable<int> number3 = 23;

    System.Nullable<int> number4 = new System.Nullable<int>(88);

    Console.ReadKey();
}    

 
然后用reflector看编译后的IL。

原来如此，可空类型的赋值直接等效于构造实例。赋null时其实就是调用空构造函数，有值时就就把值传入带参数的构造函数。(柳暗花明又一村。如此，我们是否可以接着上面截图中的 MyNullable<T> 继续模拟可空类型呢？且继续往下看。)

public struct MyNullable<T> where T : struct
{
    //错误    1    结构不能包含显式的无参数构造函数 
    //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
    //public MyNullable()
    //{
    //    this._hasValue = false;
    //}
    public MyNullable(T value)//有参构造函数
    {
        this._hasValue = true;
        this._value = value;
    }

    private bool _hasValue;

    public bool HasValue//是否不为空
    {
        get { return _hasValue; }
    }

    private T _value;
    public T Value//值
    {
        get
        {
            if (!this._hasValue)//如没有值，还访问就抛出异常
            {
                throw new Exception(" 可为空的对象必须具有一个值");
            }
            return _value;
        }
    }
}

 
哟西，基本上已经模拟出了可空类型出来的。（但是我们还是不能直接赋值，只能通过构造函数的方式来使用自定义的可空类型）。
全部代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 可空类型
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //}
        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new Exception(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))//这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");

            Console.ReadKey();
        }

    }
}

View Code
 
和系统的可空类型得出了相同的结果。

总结

可空类型是结构（也就是值类型）
所以可空类型的null值和引用类型的null是不一样的。（可空类型的并不是引用类型的null，而是用结构的另一种表示方式来表示null）


 

有同学问，怎么样才可以做到直接赋值呢？这个我也没有什么好的办法，或许需要编译器的支持。
以上内容都是胡说八道。希望能对您有那么一点点用处，感谢阅读。
（首发链接：http://www.cnblogs.com/zhaopei/p/5537759.html ）

 
 

 
============== 2016-06-05更新==============
上面我们提出了疑问“怎么样才可以做到直接赋值呢”，本来我是没有好的解决办法。这里要感谢我们的园友@冲杀给我提供了好的解决方案。
implicit（关键字用于声明隐式的用户定义类型转换运算符。）

public static implicit operator MyNullable<T>(T value)
{
       return new MyNullable<T>(value);
}

只需要在 struct MyNullable<T> 中添加以上代码，就可以直接赋值了。（作用等效于是直接重写了“=”赋值符号）


完整代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace test
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //} 

        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new InvalidOperationException(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }

        public static implicit operator MyNullable<T>(T value)
        {
            return new MyNullable<T>(value);
        } 
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = DateTime.Parse("1976-09-09") 
                //new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))
                //这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。"); 

            Console.ReadKey();
        }

    }
}

View Code
 
如此，我们已经完成了自定义可空类型的直接赋值。但只是部分，如果想要赋值null呢？

同样还是出现了最开始的编译错误。我们想到既然上面的值赋值可以重新（隐式转换）,那null应该也可以啊（null是引用类型的一个特定值）。
再加一个重载：

//隐式转换
public static implicit operator MyNullable<T>(string value)
{
    if (value == null)
        return new MyNullable<T>();
    throw new Exception("赋值右边不能为字符串");
    //这里不知道是否可以在编译期间抛出错误(或者怎样限制只能传null)
}

 
如此可以满足我们的需求了（并无异常）。

可惜美中不足，如果给 p2.EndTiem 赋值一个非空字符串时，要运行时才会报错（而系统的可空类型会在编译期就报错）。不知道大神们可有解！！
虽然如此，能做到直接赋值还是让我小小激动了一把。为此，特意查了下关键字 implicit operator ，又是让我小小激动了一把，我们不仅可以“重写”赋值，我们还可以“重写”+ - * / % & | ^ << >> == != > < >= <=等运算符。
下面我们先来“重写”下自定义可空类型的比较（==）运算符。

//"重写"比较运算符
public static bool operator ==(MyNullable<T> operand, MyNullable<T> operand2)
{
    if (!operand.HasValue && !operand2.HasValue)
    {
        return true;
    }
    else if (operand.HasValue && operand2.HasValue)
    {
        if (operand2.Value.Equals(operand.Value))
        {
            return true;
        }
    }
    return false;
}

//"重写"比较运算符
public static bool operator !=(MyNullable<T> operand, MyNullable<T> operand2)
{
    return !(operand == operand2);
}

 

Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
Console.WriteLine("p1.EndTiem == DateTime.Parse(1976-09-09)," + (p1.EndTiem == DateTime.Parse("1976-09-09")).ToString());
Console.WriteLine("p2.EndTiem == DateTime.Parse(1976-09-09)," + (p2.EndTiem == DateTime.Parse("1976-09-09")).ToString());

p1.EndTiem = DateTime.Parse("2016-06-06");
p2.EndTiem = null;
Console.WriteLine();
Console.WriteLine("赋值 p1.EndTiem = DateTime.Parse(2016-06-06)  p2.EndTiem = null 后：");
Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
Console.WriteLine("p1.EndTiem == DateTime.Parse(2016-06-06)," + (p1.EndTiem == DateTime.Parse("2016-06-06")).ToString());
Console.WriteLine("p2.EndTiem == DateTime.Parse(2016-06-06)," + (p2.EndTiem == DateTime.Parse("2016-06-06")).ToString());


结果完全符合！
完整代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace test
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //} 

        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new InvalidOperationException(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }

        //隐式转换
        public static implicit operator MyNullable<T>(T value)
        {
            return new MyNullable<T>(value);
        }

        //隐式转换
        public static implicit operator MyNullable<T>(string value)
        {
            if (value == null)
                return new MyNullable<T>();
            throw new Exception("赋值右边不能为字符串");
            //这里不知道是否可以在编译期间抛出错误(或者怎样限制只能传null)
        }

        //"重写"比较运算符
        public static bool operator ==(MyNullable<T> operand, MyNullable<T> operand2)
        {
            if (!operand.HasValue && !operand2.HasValue)
            {
                return true;
            }
            else if (operand.HasValue && operand2.HasValue)
            {
                if (operand2.Value.Equals(operand.Value))
                {
                    return true;
                }
            }
            return false;
        }

        //"重写"比较运算符
        public static bool operator !=(MyNullable<T> operand, MyNullable<T> operand2)
        {
            return !(operand == operand2);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = DateTime.Parse("1976-09-09")
                //new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))
                //这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");
            Console.WriteLine();

            Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
            Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
            Console.WriteLine("p1.EndTiem == DateTime.Parse(1976-09-09)," + (p1.EndTiem == DateTime.Parse("1976-09-09")).ToString());
            Console.WriteLine("p2.EndTiem == DateTime.Parse(1976-09-09)," + (p2.EndTiem == DateTime.Parse("1976-09-09")).ToString());

            p1.EndTiem = DateTime.Parse("2016-06-06");
            p2.EndTiem = null;
            Console.WriteLine();
            Console.WriteLine("赋值 p1.EndTiem = DateTime.Parse(2016-06-06)  p2.EndTiem = null 后：");
            Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
            Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
            Console.WriteLine("p1.EndTiem == DateTime.Parse(2016-06-06)," + (p1.EndTiem == DateTime.Parse("2016-06-06")).ToString());
            Console.WriteLine("p2.EndTiem == DateTime.Parse(2016-06-06)," + (p2.EndTiem == DateTime.Parse("2016-06-06")).ToString());     

            Console.ReadKey();
        }

    }
}

View Code
 
 
转换关键字：operator、explicit与implicit解析资料：http://www.cnblogs.com/hunts/archive/2007/01/17/operator_explicit_implicit.html
大家还可以玩出更多的花样！！！
 
本文已同步至《C#基础知识巩固系列》
article  27
title: 一步步开发自己的博客 .NET版（11、Web.config文件的读取和修改）
body: 
Web.config的读取
对于Web.config的读取大家都很属性了。平时我们用得比较多的就是appSettings节点下配置。如：

我们对应的代码是：

= ConfigurationManager.AppSettings[“OAuth_QQ_ClientId”]; 
= ConfigurationManager.AppSettings[“OAuth_QQ_CallbackUrl”];
= ConfigurationManager.AppSettings[“OAuth_QQ_ClientScrert”];
= ConfigurationManager.AppSettings[“OAuth_Sina_ClientId”];
= ConfigurationManager.AppSettings[“OAuth_Sina_ClientScrert”];
= ConfigurationManager.AppSettings[“OAuth_Sina_CallbackUrl”];
........

 是的，很简单、很方便、很清晰。可以总感觉缺少那么一点“面向对象”的感觉。少还无所谓，如果几十个上百个呢？我们是不是可以考虑分类定义，如下：

 <!--自定义配置-->
  <customCon>
    <!--邮件配置-->
    <mail mailPwd="" mailHost="" mailFrom="" />
    <!--QQ登陆-->
    <oAuthQQ OAuth_QQ_ClientId="" OAuth_QQ_ClientScrert="" OAuth_QQ_CallbackUrl="haojima.net/hi_login.html" />
    <!--新浪登录-->
    <oAuthSina OAuth_Sina_ClientId="" OAuth_Sina_ClientScrert="" OAuth_Sina_CallbackUrl="haojima.net/hi_login.html" />
  </customCon>

 可是，你会发现 customCon 编辑器不认，因为这是我自己定义的一个，那如何是好？如下：（申明自定义标签）

如此，是不是感觉分类更清楚了？可是问题又来了，那我们怎么读取自定义标签里面的值呢？
首先：（注意：需要继承ConfigurationSection）

/// <summary>
    /// 自定义配置
    /// </summary>
    public class CustomCon : ConfigurationSection
    {
        /// <summary>
        /// 邮箱设置
        /// </summary>
        [ConfigurationProperty("mail", IsRequired = true)]
        public MailElement Mail
        {
            get { return (MailElement)this["mail"]; }
        }

        /// <summary>
        /// qq登录
        /// </summary>
        [ConfigurationProperty("oAuthQQ", IsRequired = true)]
        public OAuthQQElement OAuthQQ
        {
            get { return (OAuthQQElement)this["oAuthQQ"]; }
        }

        /// <summary>
        /// 新浪登录
        /// </summary>
        [ConfigurationProperty("oAuthSina", IsRequired = true)]
        public OAuthSinaElement OAuthSina
        {
            get { return (OAuthSinaElement)this["oAuthSina"]; }
        }
    } 

然后MailElement、OAuthQQElement、OAuthSinaElement 分别具体定义：


 #region MailElement(邮箱)
    public class MailElement : ConfigurationElement
    {
        /// <summary>
        /// 发件人密码
        /// </summary>
        [ConfigurationProperty("mailPwd", IsRequired = true)]
        public string Pwd
        {
            get { return this["mailPwd"].ToString(); }
            set { this["mailPwd"] = value; }
        }

        /// <summary>
        /// SMTP邮件服务器
        /// </summary>
        [ConfigurationProperty("mailHost", IsRequired = true)]
        public string Host
        {
            get { return this["mailHost"].ToString(); }
            set { this["mailHost"] = value; }
        }

        /// <summary>
        ///发件人邮箱
        /// </summary>
        [ConfigurationProperty("mailFrom", IsRequired = true)]
        public string From
        {
            get { return this["mailFrom"].ToString(); }
            set { this["mailFrom"] = value; }
        }
    }
    #endregion

    #region OAuthQQElement（QQ）
    public class OAuthQQElement : ConfigurationElement
    {

        [ConfigurationProperty("OAuth_QQ_ClientId", IsRequired = true)]
        public string ClientId
        {
            get { return this["OAuth_QQ_ClientId"].ToString(); }
            set { this["OAuth_QQ_ClientId"] = value; }
        }


        [ConfigurationProperty("OAuth_QQ_ClientScrert", IsRequired = true)]
        public string ClientScrert
        {
            get { return this["OAuth_QQ_ClientScrert"].ToString(); }
            set { this["OAuth_QQ_ClientScrert"] = value; }
        }


        [ConfigurationProperty("OAuth_QQ_CallbackUrl", IsRequired = true)]
        public string CallbackUrl
        {
            get { return this["OAuth_QQ_CallbackUrl"].ToString(); }
            set { this["OAuth_QQ_CallbackUrl"] = value; }
        }
    }
    #endregion

    #region OAuthSinaElement(新浪)
    public class OAuthSinaElement : ConfigurationElement
    {

        [ConfigurationProperty("OAuth_Sina_ClientId", IsRequired = true)]
        public string ClientId
        {
            get { return this["OAuth_Sina_ClientId"].ToString(); }
            set { this["OAuth_Sina_ClientId"] = value; }
        }


        [ConfigurationProperty("OAuth_Sina_ClientScrert", IsRequired = true)]
        public string ClientScrert
        {
            get { return this["OAuth_Sina_ClientScrert"].ToString(); }
            set { this["OAuth_Sina_ClientScrert"] = value; }
        }


        [ConfigurationProperty("OAuth_Sina_CallbackUrl", IsRequired = true)]
        public string CallbackUrl
        {
            get { return this["OAuth_Sina_CallbackUrl"].ToString(); }
            set { this["OAuth_Sina_CallbackUrl"] = value; }
        }
    }
    #endregion

View Code
到现在为止，我们在代码层面已经建立和config一一对应的关联了。下面我们来取值：

 CustomCon custom = (CustomCon)ConfigurationManager.GetSection("customCon");
 var url = custom.OAuthQQ.CallbackUrl;//获取值
 var id = custom.OAuthQQ.ClientId;//获取值
 //、、、、、

如此是不是甚爽，比原先的 appSettings 更有“对象”的感觉了吧。且，当你配置过多的时候分类也更加清晰！
Web.config的写入
 对于Web.config的写入需求一般很少，多数都只是读取。那为什么我这里要说写入呢？因为好多人问我“这个博客系统的数据库在哪里？”，每次都解释的'不亦乐乎',"这个是coder first根据代码生成数据库"，后来次数多了实在受不了了。考虑着，是否可以做个引导页面，初次使用的时候提示设置数据库和邮箱什么的（这样的话对于没有编程基础的人搭建自己的博客系统也降低了门槛）。

第一次启动程序的时候检查数据库连接，没有就进入引导页面，设置。（这个过程都不用去编辑Web.config文件了）
好了，看了上面的效果图我们继续来看是怎么把数据写入到Web.config文件的吧。
其实很简单，稍微改下上面代码:

改成通过 WebConfigurationManager.OpenWebConfiguration 来读取代码就可以编辑了。不过不要忘了 config.Save(); 才会真正更新到Web.config里面去。
到这里还只能修改我们自定义的节点数据。我们最最主要的是想更新数据库连接，请看下面对数据库连接的操作：

/// <summary>
/// 修改数据库连接
/// </summary>
/// <param name="key"></param>
/// <param name="connectionString"></param>
/// <param name="providerName"></param>
public static void SetConnectionString(string key, string connectionString, string providerName = "System.Data.SqlClient")
{
    ConnectionStringsSection connectionSetting = (ConnectionStringsSection)config.GetSection("connectionStrings");
    if (connectionSetting.ConnectionStrings[key] == null)//如果不存在此节点,则添加  
    {
        ConnectionStringSettings connectionStringSettings = new ConnectionStringSettings(key, connectionString, providerName);
        connectionSetting.ConnectionStrings.Add(connectionStringSettings);
    }
    else//如果存在此节点,则修改  
    {
        connectionSetting.ConnectionStrings[key].ConnectionString = connectionString;
        connectionSetting.ConnectionStrings[key].ProviderName = providerName;
    }
    config.Save();
}

其实，细看和我们上面的代码大同小异。（只是把我们自定义的类改成了 ConnectionStringsSection .net默认的连接对象） 
 

《一步步搭建自己的博客》
好了，以上都是胡说八道。
主要是说下思路，大家自由发挥。感谢您的阅读，希望对您有一点点作用！
文章首链：http://www.cnblogs.com/zhaopei/p/5677053.html

 
article  28
title: 你必须知道的EF知识和经验
body: 
注意：以下内容如果没有特别申明，默认使用的EF6.0版本，code first模式。
推荐MiniProfiler插件
工欲善其事，必先利其器。
我们使用EF和在很大程度提高了开发速度，不过随之带来的是很多性能低下的写法和生成不太高效的sql。
虽然我们可以使用SQL Server Profiler来监控执行的sql，不过个人觉得实属麻烦，每次需要打开、过滤、清除、关闭。
在这里强烈推荐一个插件MiniProfiler。实时监控页面请求对应执行的sql语句、执行时间。简单、方便、针对性强。
如图：(具体使用和介绍请移步)

数据准备
新建实体：Score（成绩分数表）、Student（学生表）、Teacher（老师表）

后面会给出demo代码下载链接
foreach循环的陷进 
1.关于延迟加载

请看上图红框。为什么StudentId有值，而Studet为null？因为使用code first，需要设置导航属性为virtual，才会加载延迟加载数据。

2.关于在循环中访问导航属性的异常处理（接着上面,加上virtual后会报以下异常）
"已有打开的与此 Command 相关联的 DataReader，必须首先将它关闭。"

解决方案：

方案1、设定ConnectionString加上MultipleActiveResultSets=true,但只适用于SQL 2005以后的版本
方案2、或者先读出放置在List中

3.以上两点仅为热身，我们说的陷阱才刚刚开始！

然后我们点击打开MiniProfiler工具（不要被吓到）


解决方案：使用Include显示连接查询（注意:需要手动导入using System.Data.Entity 不然Include只能传表名字符串）。

再看MiniProfiler的监控（瞬间101条sql变成了1条，这其中的性能可想而知。）

AutoMapper工具
上面我们通过Include显示的执行表的连接查询显然是不错的，但还不够。如果我们只需要查询数据的某些字段呢，上面查询所有字段岂不是很浪费内存存储空间和应用程序与数据库数据传输带宽。
我们可以：

对应监控到的sql：

我们看到生成的sql，查询的字段少了很多。只有我们显示列出来字段的和一个StudentId，StudentId用来连接查询条件的。
是的，这样的方式很不错。可是有没有什么更好的方案或方式呢？答案是肯定的。（不然，也不会在这里屁话了。）如果表字段非常多，我们需要使用的字段也非常多，导航属性也非常多的时候，这样的手动映射就显得不那么好看了。那么接下来我们开始介绍使用AutoMapper来完成映射：
注意：首先需要NuGet下载AutoMapper。（然后导入命名空间 using AutoMapper; using AutoMapper.QueryableExtensions;）


我们看到上面查询语句没有一个个的手动映射，而映射都是独立配置了。其中CreateMap应该是要写到Global.asax文件里面的。（其实也就是分离了映射部分，清晰了查询语句。细心的同学可能注意到了，这种方式还免去了主动Include）

我们看到了生成的sql和前面有些许不同，但只生成了一条sql，并且结果也是正确的。(其实就是多了一条CASE WHEN ([Extent2].[Id] IS NOT NULL) THEN 1 END AS [C1]。看起来这条语句并没有什么实际意义，然而这是AutoMapper生成的sql，同时我也表示不理解为什么和EF生成的不同)
这样做的好处？

避免在循环中访问导航属性多次执行sql语句。
避免了查询语句中太多的手动映射，影响代码的阅读。

关于AutoMapper的其他一些资料：
http://www.cnblogs.com/xishuai/p/3712361.html
http://www.cnblogs.com/xishuai/p/3700052.html
http://www.cnblogs.com/farb/p/AutoMapperContent.html
联表查询统计
要求：查询前100个学生考试类型（“模拟考试”、“正式考试”）、考试次数、语文平均分、学生姓名，且考试次数大于等于3次。（按考试类型分类统计）
代码如下：

看到这样的代码，我第一反应是惨了。又在循环执行sql了。监控如下：

其实，我们只需要稍微改动就把101条sql变成1条，如下：

马上变1条。

我们打开查看详细的sql语句

发现这仅仅只是查询结果集合而已，其中的按考试类型来统计是程序拿到所有数据后在计算的（而不是在数据库内计算，然后直接返回结果），这样同样是浪费了数据库查询数据传输。
关于连接查询分组统计我们可以使用SelectMany，如下：

监控sql如下：（是不是简洁多了呢？）

关于SelectMany资料：
http://www.cnblogs.com/lifepoem/archive/2011/11/18/2253579.html
http://www.cnblogs.com/heyuquan/p/Linq-to-Objects.html
性能提升之AsNonUnicode

监控到的sql

我们看到EF正常情况生成的sql会在前面带上“N”，如果我们加上DbFunctions.AsNonUnicode生成的sql是没有“N”的，当你发现带上“N”的sql比没有带“N”的 sql查询速度慢很多的时候那就知道该怎么办。
（以前用oracle的时候带不带“N”查询效率差别特别明显，今天用sql server测试并没有发现什么差别。还有我发现EF6会根据数据库中是nvarchar的时候才会生成带“N”的sql，oracle数据库没测试，有兴趣的同学可以测试下）
性能提升之AsNoTracking

我们看生成的sql

sql是生成的一模一样，但是执行时间却是4.8倍。原因仅仅只是第一条EF语句多加了一个AsNoTracking。
注意：

AsNoTracking干什么的呢？无跟踪查询而已，也就是说查询出来的对象不能直接做修改。所以，我们在做数据集合查询显示，而又不需要对集合修改并更新到数据库的时候，一定不要忘记加上AsNoTracking。
如果查询过程做了select映射就不需要加AsNoTracking。如：db.Students.Where(t=>t.Name.Contains("张三")).select(t=>new (t.Name,t.Age)).ToList();

多字段组合排序（字符串）
要求：查询名字里面带有“张三”的学生，先按名字排序，再按年龄排序。


咦，不对啊。按名字排序被年龄排序覆盖了。我们应该用ThenBy来组合排序。


不错不错，正是我们想要的效果。如果你不想用ThenBy，且都是升序的话，我们也可以：


生成的sql是一样的。与OrderBy、ThenBy对应的降序有OrderByDescending、ThenByDescending。
看似好像很完美了。其实不然，我们大多数情况排序是动态的。比如，我们会更加前端页面不同的操作要求不同字段的不同排序。那我们后台应该怎么做呢？

当然，这样完成是没问题的，只要你愿意。可以这么多可能的判断有没有感觉非常SB？是的，我们当然有更好的解决方案。要是OrderBy可以直接传字符串？？？
解决方案：

guget下载System.Linq.Dynamic 
导入System.Linq.Dynamic命名空间
编写OrderBy的扩展方法


然后上面又长又臭的代码可以写成：

我们看下生成的sql：

和我们想要的效果完全符合，是不是感觉美美哒！！
【注意】：传入的排序字段后面要加排序关键字 asc或desc
lamdba条件组合
要求：根据不同情况查询，可能情况

查询name=“张三” 的所有学生
查询name=“张三” 或者 age=18的所有学生

实现代码：

是不是味到了同样的臭味。下面我们来灵活组装Lamdba条件。
解决方案：

这段代码我也是从网上偷的，具体链接找不到了。
然后我们的代码可以写成：

有没有美美哒一点。然后我们看看生成的sql是否正确：

EF的预热
http://www.cnblogs.com/dudu/p/entity-framework-warm-up.html
count(*)被你用坏了吗（Any的用法）
要求：查询是否存在名字为“张三”的学生。（你的代码会怎样写呢？）

第一种？第二种？第三种？呵呵，我以前就是使用的第一种，然后有人说“你count被你用坏了”，后来我想了想了怎么就被我用坏了呢？直到对比了这三个语句的性能后我知道了。

性能之差竟有三百多倍，count确实被我用坏了。（我想，不止被我一个人用坏了吧。）
我们看到上面的Any干嘛的？官方解释是：

我反复阅读这个中文解释，一直无法理解。甚至早有人也提出过同样的疑问《实在看不懂MSDN关于 Any 的解释》
所以我个人理解也是“确定集合中是否有元素满足某一条件”。我们来看看any其他用法：
要求：查询教过“张三”或“李四”的老师
实现代码：

两种方式，以前我会习惯写第一种。当然我们看看生成过的sql和执行效率之后，看法改变了。

效率之差竟有近六倍。
我们再对比下count：


得出奇怪的结论：

在导航属性里面使用count和使用any性能区别不大，反而FirstOrDefault() != null的方式性能最差。
在直接属性判断里面any和FirstOrDefault() != null性能区别不大，count性能要差的多。
所以，不管是直接属性还是导航属性我们都用any来判断是否存在是最稳当的。

透明标识符
假如由于各种原因我们需要写下面这样逻辑的语句

我们可以写成这样更好

看生成的sql就知道了

第二种方式生成的sql要干净得多，性能也更好。
EntityFramework.Extended
这里推荐下插件EntityFramework.Extended，看了下，很不错。
最大的亮点就是可以直接批量修改、删除，不用像EF默认的需要先做查询操作。
至于官方EF为什么没有提供这样的支持就不知道了。不过使用EntityFramework.Extended需要注意以下几点：

只支持sql server
批量修改、删除时不能实现事务（也就是出了异常不能回滚）
没有联级删除
不能同EF一起SaveChanges （详见）

http://www.cnblogs.com/GuZhenYin/p/5482288.html
在此纠正个问题EntityFramework.Extended并不是说不能回滚，感谢@GuZhenYin园友的指正（原谅我之前没有动手测试）。
注意：需要NuGet下载EntityFramework.Extended， 并导入命名空间： using EntityFramework.Extensions ;
测试代码如下：（如果注释掉手抛异常代码是可以直接更新到数据库的）

using (var ctxTransaction = db.Database.BeginTransaction())
{
    try
    {
        db.Teachers.Where(t => true).Update(t => new Teacher { Age = "1" });

        throw new Exception("手动抛出异常");

        ctxTransaction.Commit();//提交事务
    }
    catch (Exception)
    {
        ctxTransaction.Rollback();//回滚事务
    }
}

自定义IQueryable扩展方法
 最后整理下自定义的IQueryable的扩展。
 

 
补充1：
First和Single的区别：前者是TOP(1)后者是TOP(2)，后者如果查询到了2条数据则抛出异常。所以在必要的时候使用Single也不会比First慢多少。
补充2: 
已打包nuget提供直接安装 Install-Package Talk.Linq.Extensions 或nuget搜索 Talk.Linq.Extensions 
https://github.com/zhaopeiym/Talk/wiki/Talk.Linq.Extensions_demo
 
结束：
源码下载：http://pan.baidu.com/s/1o8MYozw
本文以同步至《C#基础知识巩固系列》
欢迎热心园友补充！
article  29
title: 一步步开发自己的博客 .NET版（9、从model first替换成code first 问题记录）
body: 
为什么要改用code first
用过code first的基本上都不会再想用回model first或是db first（谁用谁知道）。不要问我为什么不一开始就直接使用code first，因为那个时候我还不会（甚至还把model first当成了code first）。
因为工作中使用的就是code first，且越用越习惯，越用越喜欢。
原因如果：

再也用为每次生成那个笨重的edmx文件性急了
再也不用当心保存tt文件而丢失特性、注销、扩展方法了
再也不用为了使用微软的验证插件非得写Metadata文件了
再也不用为了扩展tt文件生成的实体类去写（partial）部分类了。
再也不用为了生成满足自己需要的实体而去修改那些坑爹的tt文件里面的语法代码了（如：默认每个实体继承一个父类）
再也不用为了查找edmx文件打不开，去编辑庞大的edmx文件中找那些坑爹的错误了。
等等还有些暂时没想到的....

说改就改
修改前实体：db first（由tt文件生成）

修改后实体：code first（完全手写）

然后把实体更新到数据库对应的表结构。执行命令Enable-Migrations
遇到问题：

 The EntityFramework package is not installed on project ''.（原因：因为没有选择“默认项目”）
继续问题：
 
 The project 'Blogs.Model' failed to build.（原因：没有建一个继承于DbContext的类）
 
 ok，提示已经启用迁移。
然后我们执行命令：Add-Migration blogs

异常： 从数据库中获取提供程序信息时出错。这可能是 Entity Framework 使用的连接字符串不正确导致的。有关详细信息，请查看内部异常并确保连接字符串正确。
我的乖乖，我非常确定我们字符串链接是正确的啊。
最后确定忘记给数据连接上下文在构造函数中传入配置文件的数据库链接名。


  public BlogDbContext()
            : base("HiBlogsTest")
        {
        }

 
再执行（Add-Migration blogs），再出错：
 
 异常：无法加载指定的元数据资源。（百度之，原来是链接字符串有问题。http://www.cnblogs.com/chengxiaohui/articles/2106765.html）

 <add name="HiBlogsTest" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=System.Data.SqlClient;
         provider connection string=&quot;
         data source=.;
         initial catalog=HiBlogsTest;
         user id=sa;
         password=123qwe;
         MultipleActiveResultSets=True;
         App=EntityFramework&quot;" providerName="System.Data.EntityClient" />

 
改成：（那一堆csdl、ssdl、msl什么都不要了，就留个简单的链接。干净）

<add name="HiBlogsTest" connectionString="Data Source=.;Initial Catalog=HiBlogsTest;User ID=sa;Password=123qwe;" providerName="System.Data.SqlClient" />

 
ok，终于没有看见红色的字了。

且看到了一个自动生成的blogs文件。且不管，看看数据库是否有表结构。

空空如也。（屁都没看到一个）（原因：BlogDbContext上下文中没有添加实体，没有告诉程序要生成哪些实体到数据库）
给BlogDbContext类添加数据代码：

  public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        }       
        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

 
然后执行 ：Add-Migration blogs 再执行 update-database

终于看到表数据了。
有了表还不行，我们还没有主外键。
修改BlogDbContext如下:


public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        } 
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            var entityBlogUser = modelBuilder.Entity<BlogUser>();

            entityBlogUser.HasMany(p => p.BlogInfos).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")); 
          
            entityBlogUser.HasRequired(p => p.BlogUserInfo).WithRequiredPrincipal(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")); 

            entityBlogUser.HasMany(p => p.BlogTags).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            entityBlogUser.HasMany(p => p.BlogTypes).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            entityBlogUser.HasMany(p => p.BlogComments).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            var entityBlogInfo = modelBuilder.Entity<BlogInfo>();

            entityBlogInfo.HasMany(p => p.BlogTags).WithMany(t => t.BlogInfos)
           .Map(m => m.ToTable("BlogInfo_BlogTag"));

            entityBlogInfo.HasMany(p => p.BlogTypes).WithMany(t => t.BlogInfos)
            .Map(m => m.ToTable("BlogInfo_BlogType"));

            entityBlogInfo.HasMany(p => p.BlogComments).WithRequired(t => t.BlogInfo)
              .Map(m => m.MapKey("BlogInfoId"));

            entityBlogInfo.HasMany(p => p.BlogReadInfos).WithRequired(t => t.BlogInfo)
             .Map(m => m.MapKey("BlogInfoId")); 
        }


        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

View Code
 
然后重新命令：Add-Migration blogs 再执行 update-database

又见错误：
将 FOREIGN KEY 约束 'FK_dbo.BlogInfo_dbo.BlogUser_BlogUserId' 引入表 'BlogInfo' 可能会导致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。无法创建约束。请参阅前面的错误消息。
于是，一个一个的外键删掉，又一个个的来建。终于发现：（下图是数据库关系图，mssql生成的）

百度之:(原来是为了约束联级删除数据做的约束。实在话，还没玩过联级删除了，说明这个需求应该不是很常用。找个方法禁用可否？)
直接加一个.WillCascadeOnDelete(false)就可以了。（http://www.cnblogs.com/chear/archive/2012/11/09/2762145.html）


public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        } 
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            var entityBlogUser = modelBuilder.Entity<BlogUser>();

            entityBlogUser.HasMany(p => p.BlogInfos).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //与上面等效
            //modelBuilder.Entity<BlogInfo>().HasRequired(p => p.BlogUser).WithMany(t => t.BlogInfos)  

            //以BlogUser为主表（BlogUserInfo为从表，建立外键）
            entityBlogUser.HasRequired(p => p.BlogUserInfo).WithRequiredPrincipal(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //等效于HasRequired(p => ).WithOptional(i => );

            ////以BlogUserInfo为主表（BlogUser为从表，建立外键）
            //modelBuilder.Entity<BlogUser>().HasRequired(p => p.BlogUserInfo).WithRequiredDependent(t => t.BlogUser) 
            //.Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //等效于 HasOptional(p => ).WithRequired(i => ); 

            entityBlogUser.HasMany(p => p.BlogTags).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            entityBlogUser.HasMany(p => p.BlogTypes).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            entityBlogUser.HasMany(p => p.BlogComments).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            var entityBlogInfo = modelBuilder.Entity<BlogInfo>();

            entityBlogInfo.HasMany(p => p.BlogTags).WithMany(t => t.BlogInfos)
           .Map(m => m.ToTable("BlogInfo_BlogTag"));

            entityBlogInfo.HasMany(p => p.BlogTypes).WithMany(t => t.BlogInfos)
            .Map(m => m.ToTable("BlogInfo_BlogType"));

            entityBlogInfo.HasMany(p => p.BlogComments).WithRequired(t => t.BlogInfo)
              .Map(m => m.MapKey("BlogInfoId")).WillCascadeOnDelete(false);

            entityBlogInfo.HasMany(p => p.BlogReadInfos).WithRequired(t => t.BlogInfo)
             .Map(m => m.MapKey("BlogInfoId")).WillCascadeOnDelete(false); 
        }


        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

View Code
 
然后重新命令：Add-Migration blogs 再执行 update-database

完美，表结构过来了。表关系过来了。（接下来就是该代码了，因为表名做了小的改动，字段也做了少许调整所以改的东西还真不少。整整改了一天时间。）
现在回过头来想想，之前是先model first之后小许改动就用的db first。以前怎么没有遇到过（将 FOREIGN KEY 约束 'FK_dbo.BlogInfo_dbo.BlogUser_BlogUserId' 引入表 'BlogInfo' 可能会导致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。无法创建约束。请参阅前面的错误消息。）这个错误。好奇心驱使，觉得看看以前的代码的edmx是怎么管理这种关系的。

很惊奇的发现，完全没有问题。于是，不死心看看数据库里面是不是有什么蹊跷。


搜噶，原来如此。通过model first生成的主外键关系默认就没有设计联级删除，而code first默认设置就是联级删除。
 

以上内容，都是我胡说八道。谢谢您的阅读，希望对您有那么一点点作用。
Hi-Blogs源码地址：http://git.oschina.net/zhaopeiym/Hi-Blogs
最近因为工作实在太慢，开源博客长久没有更新。今天突然来回翻了好几遍，发现半年前的自己写的代码是如此的不堪入目。
今天仅仅只是把db first改成了code first，发霉的代码我还得找个时间好好重构重构。
首发地址：http://www.cnblogs.com/zhaopei/p/5540532.html 

 
article  30
title: 你知道C#中的Lambda表达式的演化过程吗？
body: 
那得从很久很久以前说起了，记得那个时候...
懵懂的记得从前有个叫委托的东西是那么的高深难懂。
委托的使用
例一：

什么是委托？
个人理解：用来传递方法的类型。（用来传递数字的类型有int、float、double，用来传递方法的就有委托）
例二：

又经过了很久很久...
匿名方法
很多时候委托接收的方法是一次性的或者方法体是非常简单的...
例三：

我们可以写成：

有没有发现我们每次都要定义委托，很多时候签名可能是一样的。这样就没有必要定义重复的。
然后又过了很久很久...
Func和Action
可能老大也觉得我们每次定义委托有点傻，所以干脆在框架内一次定义好所有可能用到的委托。那千变万化的方法签名怎么可能定义得全？没关系，定义成泛型的不就可以了吗。
先说Func：

细心的朋友可能看到了，Func相对于AddDelegate多定义了一个int。多出了的那个是指的是返回类型。我们F12看对应的定义：

关于上面Func的写法我们可以简写成：（语法糖而已，编译后还是注释的代码）

再看Action：

提醒：以后如果我们写代码的时候如果写到到delegate...，你要马上想到是否可以用Func或者Action来代替呢？C#4中的Action和Func有16个参数，足够你用了。
我们等了又等，又过了好久好久...
Lambda的诞生

我XX，这TM就是亲兄弟啊。直接去掉delegate关键字，然后加一个=>就成了lambda表达式了。（=>读作goes to）
我们继续简化：

丢掉参数类型也是可以的，因为强大的VS可以根据泛型委托Func自己推断出来参数类型。
还可以简化吗？当然：

return关键字也不要了，大括号也不要了。（当然，方法体只有单条语句才能怎么做）
现在看起来已经非常接近我们平时用的Lambda表达式了。
如果传入参数只有一个的话，我们还可以继续简化：

这就是我们平时见得最多的lambda长相了。
要长成这样也是有要求的：

只能有一个传入参数
方法体只能只一条语句。

关于第1点，lambda我们平时用得较多的是基于IEnumerable或IQueryable，所以只能有一个参数也就满足了。
关于第2点，我们使用扩展方法的链式编程来解决。
如：（用链式来解决第二点）

从此，我们过上了幸福的生活...
 
借《深入理解C#》中的一图：

 
小知识：（异步Lambda）

Func<Student, Task<bool>> func = async t =>
{
    await Task.Delay(100);//等待100毫秒
    return false;
};

 
结束：
本文简短的说了下lambda表达式在C#中的一步步演化。说的不一定对，轻拍！
本文以同步至《C#基础知识巩固系列》
article  31
title: Linq表达式、Lambda表达式你更喜欢哪个？
body: 
什么是Linq表达式？什么是Lambda表达式？
如图：

由此可见Linq表达式和Lambda表达式并没有什么可比性。
那与Lambda表达式相关的整条语句称作什么呢？在微软并没有给出官方的命名，在《深入理解C#》中称为点标记。

查询表达式、点标记你更喜欢哪个？
所以，我们的标题的提问根本就不合适。应该是“查询表达式和点标记你更喜欢哪个？”。如：

 //查询表达式
 var students1 = from t in db.Students
                where t.Name == "张三"
                select new { t.Id, t.Name, t.Age };
 //点标记
 var students2 = db.Students
                 .Where(t => t.Name == "张三")
                 .Select(t => new { t.Id, t.Name, t.Age });

为什么选择点标记 
我相信更多的人偏向选择点标记。具体什么原因我也说不清（可能是点标记中的Lambda更加优雅吧）。对于我个人来说，也是更加喜欢点标记这种方式。
1、所有的查询表达式都可以转成对应的点标记。反之，不是所有的点标记都可以转成查询表达式。
为什么？因为查询表达式在编译后就直接变成了点标记：（以下是上面两个语句对应的编译后的反编译C#代码）

生成了一模一样的代码。（由于是编译后的，好多乱七八糟的代码。我们只看Where和Select关键字就知道，使用的都是点标记。）
2、点标记确实比查询表达式更加优雅
例一：

 //查询表达式
 var students1 = from t in db.Students
                 where t.Name == "张三"
                 select t;
 //点标记
 var students2 = db.Students
                 .Where(t => t.Name == "张三");

我为什么一定要 select t 啊，这句没卵用的废话就不能省吗？是的，省了就报错：

例二：
必须需要括号包裹起来才能取结果集？你还能更丑一点吗？

//查询表达式
var students1 = (from t in db.Students
                 where t.Name == "张三"
                 select t).ToList();
//点标记
var students2 = db.Students
                .Where(t => t.Name == "张三")
                .ToList();       

例三：（为什么说："不是所有的点标记都可以转成查询表达式"【此例只适用于IEnumerator】）
此条点标记你能转成查询表达式吗？

var list = new List<string>() { "张三", "张三", "张三", "张三", "李四", "张三", "李四", "张三", "李四" };

var students2 = list
                .Where((item, index) => item == "张三" && index % 2 == 0)
                .Select((item, index) => new { item, index })
                .ToList();

查询表达式你能Reverse吗？

var list = new List<string>() { "张三1", "张三2", "张三3", "张三0", "李四9", "张三3", "李四", "张三2", "李四" };

var students2 = list
             .Where((item, index) => item.Contains("张三"))
             .Select((item, index) => new { item, index })
             .Reverse()//反序
             .ToList();


ListA.Distinct().ToList();//去重
ListA.Except(ListB).ToList();//差集
ListA.Union(ListB).ToList();  //并集
ListA.Intersect(ListB).ToList();//交集

 
什么时候使用查询表达式？
通过上面的对比，好像查询表达式一文不值了。no，不是这样的。
比如下面几种情况我们就可以选择使用查询表达式：
例一：（本例适用于Linq to Object 和 没有建主外键的EF查询）
点标记中的Join需要传四个参数表达式，是不是有点晕了。。。

var list1 = new Dictionary<string, string> { { "1", "张三" }, { "2", "李四" }, { "3", "张三" }, { "4", "张三" } };
var list2 = new Dictionary<string, string> { { "1", "张三" }, { "2", "李四" }, { "3", "李四" }, { "4", "张三" } };

//查询表达式
var obj1 = from l1 in list1
           join l2 in list2
           on l1.Key equals l2.Key
           select new { l1, l2 };
//点标记
var obj = list1.Join(list2, l1 => l1.Key, l2 => l2.Key, (l1, l2) => new { l1, l2 });

例二：
点标记需要区分OrderBy、ThenBy有没有觉得麻烦

//查询表达式
var obj1 = from l1 in list1
           join l2 in list2
           on l1.Key equals l2.Key
           orderby l1.Key, l2.Key descending
           select new { l1, l2 };
//点标记
var obj = list1.Join(list2, l1 => l1.Key, l2 => l2.Key, (l1, l2) => new { l1, l2 })
    .OrderBy(li => li.l1.Key)
    .ThenByDescending(li => li.l2.Key)
    .Select(t => new { t.l1, t.l2 });

总觉得查询表达式更多的只是为了照顾那些写惯了sql的程序员。
联接查询（内联、左联、交叉联）
关于联接查询使用查询表达式会更合适一些这个上面已经说了。
接下来我们写内联、左联、交叉联的查询表达式和对应的点标记代码。（目的：可能有些人不会，同时在这里也给自己做个备忘）
内联：

左联：

交叉联：

其实关于联接查询，如果EF建好了主外键我还是觉得点标记用起来更爽爽的。
 
结束：
本文并不是要改变你的习惯，也不是否定你的观点。仅仅只是表达个人对点标记和查询表达式的些许理解。
关于是使用查询表达式还是点标记，可能起着更大决定性的作用的是团队共同的习惯和规范。
然后还想说说，只要我们对比什么，很可能就会有人跳出了，什么不要比，用好了都一样，什么什么才是最重要的，什么什么的。。。
就像很多人会反感java和C#的对比，其实我个人觉得对比下底层实现、对比下语法简易也不是不可以的，只要我们可以从中学到知识（个人也是不喜欢对比 谁谁谁学什么工资多少多少）。
昨天的自己对比今天的自己，今天的自己对比明天的自己。只要可以进步为什么不要对比呢？
 
本文以同步至《C#基础知识巩固系列》
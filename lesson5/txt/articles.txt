article  1
title: 权限管理学习 一、ASP.NET Forms身份认证
body: 
说明：本文示例使用的VS2017和MVC5。
系统无论大小、牛逼或屌丝，一般都离不开注册、登录。那么接下来我们就来分析下用户身份认证。
简单实现登录、注销
以前在学习.net的时候不知道什么Forms身份认证，直接用session实现登录，效果也蛮好嘛。而且用户信息存在服务端，安全。
前端代码：
@if (string.IsNullOrWhiteSpace(ViewBag.UserName))
{
    <form action="/home/login1">
        <input type="text" name="userName" />
        <input type="submit" value="登录" />
    </form>
}
else
{
    <form action="/home/logout1">
        <div>当前用户已登录，登录名：@ViewBag.UserName</div>
        <input type="submit" value="退出" />
    </form>
}

后台代码：
public ActionResult Index()
{
    ViewBag.UserName = Session["userName"]?.ToString();           
    return View();
}       

public void Login1(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了     
        Session["userName"] = userName;
    else
        Session["userName"] = null;
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}

public void Logout1()
{
    Session["userName"] = null;
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
是不是，简单明了。想要自己扩展或是定制什么功能都非常好用。不过我们需要维护session。比如系统重新发布，或者iis被自动重启。就会出现session丢失的情况。也就是用户会莫名其妙提升需要重新登录。体验非常不好。（这里先不讨论session服务和数据库的情况）。既然微软有一套成熟的权限管理我们为什么不用呢？
Forms认证登录、注销
首先在web.config里开启Forms身份认证：
<system.web>
  <authentication mode="Forms"></authentication>
后台代码：
public void Login2(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了
        FormsAuthentication.SetAuthCookie(userName, true); //登录
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}

public void Logout2()
{
    FormsAuthentication.SignOut();//登出
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
前台代码：
@if (!Request.IsAuthenticated)
{
    <form action="/home/login2">
        <input type="text" name="userName" />
        <input type="submit" value="登录" />
    </form>
}
else
{
    <form action="/home/logout2">
        <div>当前用户已登录，登录名：@Context.User.Identity.Name</div>
        <input type="submit" value="退出" />
    </form>
}
如此几句代码就实现了我们的登录和注销。和我们自己用session管理登录不同。Forms身份认证是直接把信息存cookie到浏览器的。通过SetAuthCookie这个方法名也可以看出来。不过Cookie信息经过了加密。
这里有必要说明session和cookie的关系。当我们利用session来维持用户状态的时候，其实也用到了cookie。

然而Forms身份认证仅仅只是把信息存了cookie，而没有在服务端维护一个对应的session。
不信你可以测试。可以用两种方式都登录，然后清除session就可以测出来了。（怎么清session?重启iis，或者修改下后台代码在重新编译访问）
【说明】用户认证为什么要存cookie？因为HTTP是一个无状态的协议。对于服务器来说，每次请求都是一样的。所以，只能通过每次请求带的cookie来识别用户了。(暂时不考虑其他方式)
自定义的身份认证标识
上面使用的登录很简单，但实际情况往往很复杂。明显正常业务需要存的用户信息会要更多。那么我们是否可以扩展身份标识呢？答案是肯定的。
后台代码：
public void Login3(string userName)
{
    if (!string.IsNullOrWhiteSpace(userName))  //为了方便演示，就不做真的验证了     
    {
        UserInfo user = new UserInfo()
        {
            Name = userName,
            LoginTime = DateTime.Now
        };
        //1、序列化要保存的用户信息
        var data = JsonConvert.SerializeObject(user);

        //2、创建一个FormsAuthenticationTicket，它包含登录名以及额外的用户数据。
        FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(2, userName, DateTime.Now, DateTime.Now.AddDays(1), true, data);

        //3、加密保存
        string cookieValue = FormsAuthentication.Encrypt(ticket);

        // 4. 根据加密结果创建登录Cookie
        HttpCookie cookie = new HttpCookie(FormsAuthentication.FormsCookieName, cookieValue);
        cookie.HttpOnly = true;
        cookie.Secure = FormsAuthentication.RequireSSL;
        cookie.Domain = FormsAuthentication.CookieDomain;
        cookie.Path = FormsAuthentication.FormsCookiePath;

        // 5. 写登录Cookie
        Response.Cookies.Remove(cookie.Name);
        Response.Cookies.Add(cookie);
    }
    Response.Redirect(Request.UrlReferrer.LocalPath);//重定向到原来页面
}
然后在Global.asax的Application_AuthenticateRequest方法：
protected void Application_AuthenticateRequest()
{
    GetUserInfo();
}

//通过coolie解密 读取用户信息到 HttpContext.Current.User
public void GetUserInfo()
{
    // 1. 读登录Cookie
    HttpCookie cookie = Request.Cookies[FormsAuthentication.FormsCookieName];

    try
    {
        UserInfo userData = null;
        // 2. 解密Cookie值，获取FormsAuthenticationTicket对象
        FormsAuthenticationTicket ticket = FormsAuthentication.Decrypt(cookie.Value);

        if (ticket != null && string.IsNullOrEmpty(ticket.UserData) == false)
            // 3. 还原用户数据
            userData = JsonConvert.DeserializeObject<UserInfo>(ticket.UserData);

        if (ticket != null && userData != null)
            // 4. 构造我们的MyFormsPrincipal实例，重新给context.User赋值。
            HttpContext.Current.User = new MyFormsPrincipal<UserInfo>(ticket, userData);
    }
    catch { /* 有异常也不要抛出，防止攻击者试探。 */ }
}
前端代码：
@{
    MyFormsPrincipal<UserInfo> user = Context.User as MyFormsPrincipal<UserInfo>;
    if (user == null)
    {
        <form action="/home/login3">
            <input type="text" name="userName" />
            <input type="submit" value="登录" />
        </form>
    }
    else
    {

        <form action="/home/logout2">
            <div>当前用户已登录，登录名：@Context.User.Identity.Name</div>
            <div>当前用户已登录，登录时间：@user.UserData.LoginTime</div>
            <input type="submit" value="退出" />
        </form>
    }
}
其实整个过程和FormsAuthentication.SetAuthCookie(userName, true); //登录是等效的。只是我们通过扩展，存了我们想要存储的数据。
过程也比较简单：

构造要存储的数据
序列化
把序列化信息放入FormsAuthenticationTicket对象
通过FormsAuthentication.Encrypt加密对象
发送cookie到浏览器

这里稍微复杂点的地方就是解密然后给User赋值HttpContext.Current.User = new MyFormsPrincipal<UserInfo>(ticket, userData);。
MyFormsPrincipal需要实现接口MyFormsPrincipal
public class MyFormsPrincipal<TUserData> : IPrincipal where TUserData : class, new()
{
    private IIdentity _identity;
    private TUserData _userData;

    public MyFormsPrincipal(FormsAuthenticationTicket ticket, TUserData userData)
    {
        if (ticket == null)
            throw new ArgumentNullException("ticket");
        if (userData == null)
            throw new ArgumentNullException("userData");

        _identity = new FormsIdentity(ticket);
        _userData = userData;
    }

    public TUserData UserData
    {
        get { return _userData; }
    }

    public IIdentity Identity
    {
        get { return _identity; }
    }

    public bool IsInRole(string role)//这里暂时不实现
    {
        return false;
    }
}
倒也没有什么特别，就是实例化的时候传入票据和自定义数据就好了。
授权
有了登录一般都离不开授权。微软的东西好就好在，一般都是成套成套的。
[Authorize]
public ActionResult LoginOk()
{
    return View();
}
直接给Action添加一个Authorize特性就好了，这人就会自动检查是否登录。如果没有登录自动跳转到登录页面。登录页面的设置还是在web.config里面
<system.web>
  <authentication mode="Forms" >
    <forms loginUrl="/home/index"></forms>
这种简单的授权验证明显是不够的。很多时候某些页面只有某些人才能访问。比如VIP。那么我们又要扩展了。
//继承 AuthorizeAttribute
public class MyAuthorizeAttribute : AuthorizeAttribute
{
    public override void OnAuthorization(AuthorizationContext filterContext)
    {
        if (filterContext.HttpContext.User.Identity.Name != "农码一生")
        {
            filterContext.HttpContext.Response.Write("您不是vip用户，不能访问机密数据");
            filterContext.HttpContext.Response.End();
            return;
        }
        base.OnAuthorization(filterContext);
    }
}
[MyAuthorize]
public ActionResult LoginVIP()
{
    return View();
}
是的，就是这么简单。说了这么多，来张效果图吧：

 
推荐阅读：

http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html
Demo：
https://github.com/zhaopeiym/BlogDemoCode/tree/master/权限管理/1-Forms身份认证


article  2
title: 文件下载之断点续传（客户端与服务端的实现）
body: 
前面讲了文件的上传，今天来聊聊文件的下载。
老规矩，还是从最简单粗暴的开始。那么多简单算简单？多粗暴算粗暴？我告诉你可以不写一句代码，你信吗？直接把一个文件往IIS服务器上一扔，就支持下载。还TM么可以断点续传（IIS服务端默认支持）。
在贴代码之前先来了解下什么是断点续传（这里说的是下载断点续传）？怎么实现的断点续传？
断点续传就是下载了一半断网或者暂停了，然后可以接着下载。不用从头开始下载。
很神奇吗，其实简单得很，我们想想也是可以想到的。
首先客户端向服务端发送一个请求（下载文件）。然后服务端响应请求，信息包含文件总大小、文件流开始和结束位置、内容大小等。那具体是怎么实现的呢？
HTTP/1.1有个头属性Range。比如你发送请求的时候带上Range:0-199，等于你是请求0到199之间的数据。然后服务器响应请求Content-Range: bytes 0-199/250 ，表示你获取了0到199之间的数据，总大小是250。（也就是告诉你还有数据没有下载完）。
我们来画个图吧。

是不是很简单？这么神奇的东西也就是个“约定”而已，也就是所谓的HTTP协议。
然而，协议这东西你遵守它就存在，不遵守它就不存在。就像民国时期的钱大家都信它，它就有用。如果大部分人不信它，也就没卵用了。
这个断点续传也是这样。你服务端遵守就支持，不遵守也就不支持断点续传。所以我们写下载工具的时候需要判断响应报文里有没有Content-Range，来确定是否支持断点续传。
废话够多了，下面撸起袖子开干。
文件下载-服务端
使用a标签提供文件下载
利用a标签来下载文件，也就是我们前面说的不写代码就可以实现下载。直接把文件往iis服务器上一扔，然后把链接贴到a标签上，完事。
<a href="/新建文件夹2.rar">下载</a>
简单、粗暴不用说了。如真得这么好那大家也不会费力去写其他下载逻辑了。这里有个致命的缺点。这种方式提供的下载不够安全。谁都可以下载，没有权限控制，说不定还会被人文件扫描（好像csdn就出过这档子事）。
使用Response.TransmitFile提供文件下载
上面说直接a标签提供下载不够安全。那我们怎么提供相对安全的下载呢。asp.net默认App_Data文件夹是不能被直接访问的，那我们把下载文件放这里面。然后下载的时候我们读取文件在返回到响应流。
//文件下载
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    Response.ContentType = "application/octet-stream";  //二进制流
    Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
    Response.TransmitFile(filePath); //将指定文件写入 HTTP 响应输出流
}

其他方式文件下载
在网上搜索C#文件下载一般都会搜到所谓的“四种方式”。其实那些代码并不能拿来直接使用，有坑的。
第一种：（Response.BinaryWrite）
 public void FileDownload2()
 {
     string fileName = "新建文件夹2.rar";//客户端保存的文件名  
     string filePath = Server.MapPath("/App_Data/新建文件夹2.rar");//要被下载的文件路径   

     Response.ContentType = "application/octet-stream";//二进制流
     //通知浏览器下载文件而不是打开  
     Response.AddHeader("Content-Disposition", "attachment;  filename=" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8));

     //以字符流的形式下载文件  
     using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))
     {
         Response.AddHeader("Content-Length", fs.Length.ToString());
         //这里容易内存溢出
         //理论上数组最大长度 int.MaxValue 2147483647 
         //（实际分不到这么多，不同的程序能分到值也不同，本人机器，winfrom( 2147483591 相差56)、iis(也差不多2G)、iis Express（只有100多MB））
         byte[] bytes = new byte[(int)fs.Length];
         fs.Read(bytes, 0, bytes.Length);
         Response.BinaryWrite(bytes);
     }
     Response.Flush();
     Response.End();
 }
首先数组最大长度为int.MaxValue，然后正常程序是不会分这么大内存，很容易搞挂服务器。（也就是可以下载的文件，极限值最多也就2G不到。）【不推荐】
第二种：（Response.WriteFile）
public void FileDownload3()
{
    string fileName = "新建文件夹2.rar";//客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/新建文件夹2.rar");//要被下载的文件路径  
    FileInfo fileInfo = new FileInfo(filePath);
    Response.Clear();
    Response.ClearContent();
    Response.ClearHeaders();
    Response.AddHeader("Content-Disposition", "attachment;filename=\"" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8) + "\"");
    Response.AddHeader("Content-Length", fileInfo.Length.ToString());//文件大小
    Response.AddHeader("Content-Transfer-Encoding", "binary");
    Response.ContentType = "application/octet-stream";
    Response.WriteFile(fileInfo.FullName);//大小参数必须介于零和最大的 Int32 值之间(也就是最大2G，不过这个操作非常耗内存)
    //这里容易内存溢出
    Response.Flush();
    Response.End();
}
问题和第一种类似，也是不能下载大于2G的文件。然后下载差不多2G文件时，机器也是处在被挂的边缘，相当恐怖。【不推荐】
第三种：（Response.OutputStream.Write）
public void FileDownload4()
{
    string fileName = "大数据.rar";//客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径   

    if (System.IO.File.Exists(filePath))
    {
        const long ChunkSize = 102400; //100K 每次读取文件，只读取100K，这样可以缓解服务器的压力  
        byte[] buffer = new byte[ChunkSize];

        Response.Clear();
        using (FileStream fileStream = System.IO.File.OpenRead(filePath))
        {
            long fileSize = fileStream.Length; //文件大小  
            Response.ContentType = "application/octet-stream"; //二进制流
            Response.AddHeader("Content-Disposition", "attachment; filename=" + HttpUtility.UrlEncode(fileName, System.Text.Encoding.UTF8));
            Response.AddHeader("Content-Length", fileStream.Length.ToString());//文件总大小
            while (fileSize > 0 && Response.IsClientConnected)//判断客户端是否还连接了服务器
            {
                //实际读取的大小  
                int readSize = fileStream.Read(buffer, 0, Convert.ToInt32(ChunkSize));
                Response.OutputStream.Write(buffer, 0, readSize);
                Response.Flush();//如果客户端 暂停下载时，这里会阻塞。
                fileSize = fileSize - readSize;//文件剩余大小
            }
        }
        Response.Close();
    }
}
这里明显看到了是在循环读取输出，比较机智。下载大文件时没有压力。【推荐】
第四种：（Response.TransmitFile）
也就上开始举例说的那种，下载大文件也没有压力。【推荐】
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    Response.ContentType = "application/octet-stream";  //二进制流
    Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
    Response.TransmitFile(filePath); //将指定文件写入 HTTP 响应输出流
}
文件下载-客户端
上面实现了文件下载的服务端实现，接下来我们实现文件下载的客户端实现。客户端的下载可以直接是浏览器提供的下载，也可以是迅雷或者我们自己写的下载程序。这里为了更好的分析，我们来用winfrom程序自己写个下载客户端。
直接下载
private async void button1_ClickAsync(object sender, EventArgs e)
{
    using (HttpClient http = new HttpClient())
    {
        var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar");//发送请求 (链接是a标签提供的)
        var contentLength = httpResponseMessage.Content.Headers.ContentLength;//读取文件大小
        using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())//读取文件流
        {
            var readLength = 1024000;//1000K  每次读取大小
            byte[] bytes = new byte[readLength];
            int writeLength;
            while ((writeLength = stream.Read(bytes, 0, readLength)) > 0)//分块读取文件流
            {
                using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))//使用追加方式打开一个文件流
                {
                    fs.Write(bytes, 0, writeLength);//追加写入文件
                    contentLength -= writeLength;
                    if (contentLength == 0)//如果写入完成 给出提示
                        MessageBox.Show("下载完成");
                }
            }
        }
    } 
}
看着这么漂亮的代码，好像没问题。可现实往往事与愿违。

我们看到了一个异常“System.Net.Http.HttpRequestException:“不能向缓冲区写入比所配置最大缓冲区大小 2147483647 更多的字节。”，什么鬼，又是2147483647这个数字。因为我们下载的文件大小超过了2G，无法缓冲下载。
可是“缓冲下载”下又是什么鬼。我也不知道。那我们试试可以关掉这个东东呢？答案是肯定的。
var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar");//发送请求
改成下面就可以了
var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar",HttpCompletionOption.ResponseHeadersRead);//响应一可用且标题可读时即应完成的操作。 (尚未读取的内容。)

我们看到枚举HttpCompletionOption的两个值。一个是响应读取内容，一个是响应读取标题（也就是Headers里的内容）。
异步下载
我们发现在下载大文件的时候会造成界面假死。这是UI单线程程序的通病。当然，这么差的用户体验是我们不能容忍的。下面我们为下载开一个线程，避免造成UI线程的阻塞。
/// <summary>
/// 异步下载
/// </summary>
/// <param name="sender"></param>
/// <param name="e"></param>
private async void button2_ClickAsync(object sender, EventArgs e)
{
    //开启一个异步线程
    await Task.Run(async () =>
    {
        //异步操作UI元素
        label1.Invoke((Action)(() =>
                {
                    label1.Text = "准备下载...";
                }));

        long downloadSize = 0;//已经下载大小
        long downloadSpeed = 0;//下载速度
        using (HttpClient http = new HttpClient())
        {
            var httpResponseMessage = await http.GetAsync("http://localhost:813/新建文件夹2.rar", HttpCompletionOption.ResponseHeadersRead);//发送请求
            var contentLength = httpResponseMessage.Content.Headers.ContentLength;   //文件大小                
            using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())
            {
                var readLength = 1024000;//1000K
                byte[] bytes = new byte[readLength];
                int writeLength;
                var beginSecond = DateTime.Now.Second;//当前时间秒
                while ((writeLength = stream.Read(bytes, 0, readLength)) > 0)
                {
                    //使用追加方式打开一个文件流
                    using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))
                    {
                        fs.Write(bytes, 0, writeLength);
                    }
                    downloadSize += writeLength;
                    downloadSpeed += writeLength;
                    progressBar1.Invoke((Action)(() =>
                    {
                        var endSecond = DateTime.Now.Second;
                        if (beginSecond != endSecond)//计算速度
                        {
                            downloadSpeed = downloadSpeed / (endSecond - beginSecond);
                            label1.Text = "下载速度" + downloadSpeed / 1024 + "KB/S";

                            beginSecond = DateTime.Now.Second;
                            downloadSpeed = 0;//清空
                        }
                        progressBar1.Value = Math.Max((int)(downloadSize * 100 / contentLength), 1);
                    }));
                }

                label1.Invoke((Action)(() =>
                {
                    label1.Text = "下载完成";
                }));
            }
        }
    });
}
效果图：

断点续传
上面的方式我们发现，如果下载到一个半断网了下次会重头开始下载。这和我们今天的主题明显不符嘛。下面我们开始正式进入主题文件下载之断点续传。把前面我们说到的头属性Range用起来。
var request = new HttpRequestMessage { RequestUri = new Uri(url) };
request.Headers.Range = new RangeHeaderValue(rangeBegin, null); //【关键点】全局变量记录已经下载了多少，然后下次从这个位置开始下载。
var httpResponseMessage = await http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
完整代码：
/// <summary>
/// 是否暂停
/// </summary>
static bool isPause = true;
/// <summary>
/// 下载开始位置（也就是已经下载了的位置）
/// </summary>
static long rangeBegin = 0; //(当然，这个值也可以存为持久化。如文本、数据库等)

private async void button3_ClickAsync(object sender, EventArgs e)
{
    isPause = !isPause;
    if (!isPause)//点击下载
    {
        button3.Text = "暂停";

        await Task.Run(async () =>
        {
            //异步操作UI元素
            label1.Invoke((Action)(() =>
           {
               label1.Text = "准备下载...";
           }));

            long downloadSpeed = 0;//下载速度
            using (HttpClient http = new HttpClient())
            {
                var url = "http://localhost:813/新建文件夹2.rar";
                var request = new HttpRequestMessage { RequestUri = new Uri(url) };
                request.Headers.Range = new RangeHeaderValue(rangeBegin, null); //【关键点】全局变量记录已经下载了多少，然后下次从这个位置开始下载。
                var httpResponseMessage = await http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
                var contentLength = httpResponseMessage.Content.Headers.ContentLength;//本次请求的内容大小
                if (httpResponseMessage.Content.Headers.ContentRange != null) //如果为空，则说明服务器不支持断点续传
                {
                    contentLength = httpResponseMessage.Content.Headers.ContentRange.Length;//服务器上的文件大小
                }

                using (var stream = await httpResponseMessage.Content.ReadAsStreamAsync())
                {
                    var readLength = 1024000;//1000K
                    byte[] bytes = new byte[readLength];
                    int writeLength;
                    var beginSecond = DateTime.Now.Second;//当前时间秒
                    while ((writeLength = stream.Read(bytes, 0, readLength)) > 0 && !isPause)
                    {
                        //使用追加方式打开一个文件流
                        using (FileStream fs = new FileStream(Application.StartupPath + "/temp.rar", FileMode.Append, FileAccess.Write))
                        {
                            fs.Write(bytes, 0, writeLength);
                        }
                        downloadSpeed += writeLength;
                        rangeBegin += writeLength;
                        progressBar1.Invoke((Action)(() =>
                        {
                            var endSecond = DateTime.Now.Second;
                            if (beginSecond != endSecond)//计算速度
                            {
                                downloadSpeed = downloadSpeed / (endSecond - beginSecond);
                                label1.Text = "下载速度" + downloadSpeed / 1024 + "KB/S";

                                beginSecond = DateTime.Now.Second;
                                downloadSpeed = 0;//清空
                            }
                            progressBar1.Value = Math.Max((int)((rangeBegin) * 100 / contentLength), 1);
                        }));
                    }

                    if (rangeBegin == contentLength)
                    {
                        label1.Invoke((Action)(() =>
                        {
                            label1.Text = "下载完成";
                        }));
                    }
                }
            }
        });
    }
    else//点击暂停
    {
        button3.Text = "继续下载";
        label1.Text = "暂停下载";
    }
}
效果图：

到现在为止，你以为我们的断点续传就完成了吗？
错，你有没有发现我们使用的下载链接是a标签的。也就是我们自己写服务端提供的下载链接是不是也可以支持断点续传呢？下面我换个下载链接试试便知。
断点续传(服务端的支持)
测试结果如下：

发现并不支持断点续传。为什么a标签链接可以直接支持，我们写的下载却不支持呢。
a标签的链接指向的直接是iis上的文件（iis默认支持），而我们写的却没有做响应报文表头Range的处理。（没想象中的那么智能嘛 >_<）
前面我们说过，断线续传是HTTP的一个协议。我们遵守它，它就存在，我们不遵守它也就不存在。
那下面我们修改前面的文件下载代码（服务端）：
public void FileDownload5()
{          
    //前面可以做用户登录验证、用户权限验证等。

    string filename = "大数据.rar";   //客户端保存的文件名  
    string filePath = Server.MapPath("/App_Data/大数据.rar");//要被下载的文件路径 

    var range = Request.Headers["Range"];
    if (!string.IsNullOrWhiteSpace(range))//如果遵守协议，支持断点续传
    {
        var fileLength = new FileInfo(filePath).Length;//文件的总大小
        long begin;//文件的开始位置
        long end;//文件的结束位置
        long.TryParse(range.Split('=')[1].Split('-')[0], out begin);
        long.TryParse(range.Split('-')[1], out end);
        end = end - begin > 0 ? end : (fileLength - 1);// 如果没有结束位置，那我们读剩下的全部

        //表头 表明  下载文件的开始、结束位置 和文件总大小
        Response.AddHeader("Content-Range", "bytes " + begin + "-" + end + "/" + fileLength);
        Response.ContentType = "application/octet-stream";
        Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
        Response.TransmitFile(filePath, begin, (end - begin));//发送 文件开始位置读取的大小
    }
    else
    {
        Response.ContentType = "application/octet-stream";
        Response.AddHeader("Content-Disposition", "attachment;filename=" + filename);
        Response.TransmitFile(filePath);
    }
}
然后再测试断点续传，完美支持。
多线程同时下载（分片下载）
文件的断点续传已经分析完了。不过中间有些细节的东西你可以根据实际需求去完善。如：文件命名、断点续传的文件是否发生了改变、下载完成后验证文件和服务器上的是否一致。
还有我们可以根据表头属性Range来实现多线程下载，不过这里就不贴代码了,贴个效果图吧。和上一篇文件上传里的多线程上传同理。您也可以根据提供的demo代码下载查看，内有完整实现。

 
参考资料

http://www.cnblogs.com/yank/p/HTTP-Range.html
http://www.cnblogs.com/sparkdev/p/6141539.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/上传下载


article  3
title: 《HiBlogs》重写笔记[1]--从DbContext到依赖注入再到自动注入
body: 
本篇文章主要分析DbContext的线程内唯一，然后ASP.NET Core的注入，再到实现自动注入。
DbContext为什么要线程内唯一（非线程安全）
我们在使用EF的时候，可能使用相关框架封装过了，也可能是自己直接使用DbContext。但是有没有想过怎么使用DbContext才是正确的姿势呢？
DbContext可以访问操作所有数据表、保持跟踪状态、SaveChanges统一提交等等强大的功能。我们会不会想，它的创建和销毁是否要付出昂贵的代价？
其实不是的，DataContext 是轻量的，创建它不需要很大的开销。
在EF6的DbContext文档 https://msdn.microsoft.com/zh-cn/library/system.data.entity.dbcontext(v=vs.113).aspx 最下面有句话 此类型的任何公共 static（在 Visual Basic 中为 Shared） 成员都是线程安全的。但不保证所有实例成员都是线程安全的。DbContext实例不保证线程安全。也就是说多线程同时操作一个DbContext实例，可能会有意想不到的问题。
比如我前面的文章 http://www.cnblogs.com/zhaopei/p/async_two.html 遇到的问题就是如此

之所以本地iis和iis express测试都是没问题，是因为本地访问速度快，没有并发。
更加极端点的体现，全局使用一个静态DbContext实例（之前我就这么想过）。
比如：线程a正在修改一个实体到一半，线程b给不小心保存了。线程c在修改一个实体，线程d又把这个实体不小心删了。这玩笑就开大了。并发越大，此类情况越多。所以DbContext实例只能被单个线程访问。还有，在执行异步的方法的时候切不可能自认为的“效率提升”同时发起多个异步查询。
当然，这也只是我个人认为可能存在的问题。不过你只要记住DbContext不是线程安全类型就够了。
如此，我们是不是应该每次数据操作都应该实例一个新的DbContext呢？也不尽然。比如方法a中的DbContext实例查询出实体修改跟踪，并把实体传入了方法b，而方法b是另外实例的DbContext，那么在方法b中就不能保存方法a传过来的实体了。如果非得这么做方法b中的DbContext也应该由方法a传过来。也就是说我们要的效果是线程内的DbContext实例唯一。
DbContext怎么做到线程内唯一（依赖注入）
在使用EF x时你可能是
public static BlogDbContext dbEntities
{
    get
    {
        DbContext dbContext = CallContext.GetData("dbContext") as DbContext;
        if (dbContext == null)
        {
            dbContext = new BlogDbContext();
             //将新创建的 ef上下文对象 存入线程
            CallContext.SetData("dbContext", dbContext);
         }
        return dbContext as BlogDbContext;
    }
}
而在EF Core中没有了CallContext。其实我们不需要CallContext，通过自带的注入框架就可以实现线程内唯一。
我们来写个demo
首先创建一个类库，通过注入得到DbContext。然后在web里面也注入一个DbContext，然后在web里面调用类库里面的方法。验证两个DbContext的GetHashCode()值是否一致。
类库内获取DbContext的HashCode
namespace DemoLibrary
{
    public class TempDemo
    {
        BloggingContext bloggingContext;
        public TempDemo(BloggingContext bloggingContext)
        {
            this.bloggingContext = bloggingContext;
        }
        //获取DbContext的HashCode
        public int GetDBHashCode()
        {
            return bloggingContext.GetHashCode();
        }
    }
}
然后在web里面也注入DbContext，并对比HashCode
public IActionResult Index()
{
    // 获取类库中的DbContext实例Code
    var code1 = tempDemo.GetDBHashCode();
    // 获取web启动项中DbContext实例Code
    var code2 = bloggingContext.GetHashCode();
    return View();
}
效果图：

由此可见通过注入得到的DbContext对象是同一个（起码在一个线程内是同一个）
另外，我们还可以反面验证通过new关键字实例DbContext对象在线程内不是同一个

为什么可以通过注入的方式得到线程内唯一（注入的原理）
这里不说注入的定义，也不说注入的好处有兴趣可查看。我们直接来模拟实现注入功能。
首先我们定义一个接口IUser和一个实现类User
public interface IUser
{
    string GetName();
}
public class User : IUser
{
    public string GetName()
    {
        return "农码一生";
    }
}
然后通过不同方式获取User实例

第一种不用说大家都懂的
第二种和第三种我们看到使用到了DI类（自己实现的一个简易注入"框架"），下面我们来看看DI类中的Resolve到底是个什么鬼
public class DI
{
    //通过反射 获取实例  并向上转成接口类型
    public static IUser Resolve(string name)
    {
        Assembly assembly = Assembly.GetExecutingAssembly();//获取当前代码的程序集
        return (IUser)assembly.CreateInstance(name);//这里写死了，创建实例后强转IUser
    }

    //通过反射 获取“一个”实现了此接口的实例
    public static T Resolve<T>()
    {
        Assembly assembly = Assembly.GetExecutingAssembly();
        //获取“第一个”实现了此接口的实例
        var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(typeof(T))).FirstOrDefault();
        if (type == null)
            throw new Exception("没有此接口的实现");
        return (T)assembly.CreateInstance(type.ToString());//创建实例 转成接口类型
    }
是不是想说“靠，这么简单”。简单的注入就这样简单的实现了。如果是相对复杂点的呢？比如我们经常会用到，构造注入里面的参数本身也需要注入。
比如我们再创建一个IUserService接口和一个UserService类
public interface IUserService
{
    IUser GetUser();
}

public class UserService : IUserService
{
    private IUser _user;
    public UserService(IUser user)
    {
        _user = user;
    }

    public IUser GetUser()
    {
        return _user;
    }
}
我们发现UserService的构造需要传入IUser，而IUser的实例使用也是需要注入IUser的实例。

这里需要思考的就是userService.GetUser()怎么可以得到IUser的实现类实例。所以，我们需要继续看Resolve2的具体实现了。
public static T Resolve2<T>()
{
    Assembly assembly = Assembly.GetExecutingAssembly();//获取当前代码的程序集
    //获取“第一个”实现了此接口的实例（UserService）
    var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(typeof(T))).FirstOrDefault();
    if (type == null)          
        throw new Exception("没有此接口的实现");
    
    var parameter = new List<object>();
    //type.GetConstructors()[0]获取第一个构造函数 GetParameters的所有参数（IUser接口）
    var constructorParameters = type.GetConstructors()[0].GetParameters();
    foreach (var constructorParameter in constructorParameters)
    {
        //获取实现了（IUser）这个接口类型（User）
        var tempType = assembly.GetTypes().Where(t => t.GetInterfaces()
                    .Contains(Type.GetType(constructorParameter.ParameterType.FullName)))
                    .FirstOrDefault();
        //并实例化成对象（也就是User实例） 添加到一个集合里面 供最上面（UserService）的注入提供参数 
        parameter.Add(assembly.CreateInstance(tempType.ToString()));
    }
    //创建实例，并传入需要的参数 【public UserService(IUser user)】
    return (T)assembly.CreateInstance(type.ToString(), true, BindingFlags.Default, null, parameter.ToArray(), null, null);//true：不区分大小写 
}
仔细看了也不难，就是稍微有点绕。
既然知道了注入的原理，那我们控制通过方法A注入创建实例每次都是重新创建、通过方法B创建的实例在后续参数使用相同的实例、通过方便C创建的实例全局单例，就不是难事了。
以下伪代码：
//每次访问都是新的实例(通过obj1_1、obj1_2可以体现)
public static T Transient<T>()
{
    //var obj1_1 = assembly.CreateInstance(name);
    //var obj2 = assembly.CreateInstance(obj1_1,...)
    //var obj1_2 = assembly.CreateInstance(name);
    //var obj3 = assembly.CreateInstance(obj1_2,...)
    //var obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
//一次请求中唯一实例(通过obj1可以体现)
public static T Scoped<T>()
{
    //var obj1 = assembly.CreateInstance(name);
    //var obj2 = assembly.CreateInstance(obj1,...)
    //var obj3 = assembly.CreateInstance(obj1,...)
    //var obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
//全局单例（通过obj1 == null可以体现）
public static T Singleton<T>()
{
    //if(obj1 == null)
    //  obj1 = assembly.CreateInstance(name);
    //if(obj2 == null)
    //  obj2 = assembly.CreateInstance(obj1,...)
    //if(obj3 == null)
    //  obj3 = assembly.CreateInstance(obj1,...)
    //if(obj4 == null)
    //  obj4 = assembly.CreateInstance(,...[obj2,obj3],...)
    //return (T)obj4;
}
通过伪代码，应该不难理解怎么通过注入框架实现一个请求内实现DbContext的唯一实例了吧。
同时也应该更加深刻的理解了ASP.NET Core中对应的AddScoped、AddTransient、AddSingleton这三个方法和生命周期了吧。
在ASP.NET Core中实现自动注入
不知道你有没有在使用AddScoped、AddTransient、AddSingleton这类方法的时候很烦。每次要使用一个对象都需要手动注入，每次都要到Startup.cs文件里面去做对应的修改。真是烦不胜烦。
使用过ABP的同学就有种感觉，那就是根本体会不到注入框架的存在。我们写的接口和实现都自动注入了。使用的时候直接往构造函数里面扔就好了。那我们在使用ASP.NET Core的时候很是不是也可以实现类似的功能呢？
答案是肯定的。我们先定义这三种生命周期的标识接口，这三个接口仅仅只是做标记作用。（名字你可以随意）
// 瞬时（每次都重新实例）
public interface ITransientDependency
//一个请求内唯一（线程内唯一）
public interface IScopedDependency
//单例（全局唯一）
public interface ISingletonDependency
我们以ISingletonDependency为例
/// 自动注入
/// </summary>
private void AutoInjection(IServiceCollection services, Assembly assembly)
{
    //获取标记了ISingletonDependency接口的接口
    var singletonInterfaceDependency = assembly.GetTypes()
            .Where(t => t.GetInterfaces().Contains(typeof(ISingletonDependency)))
            .SelectMany(t => t.GetInterfaces().Where(f => !f.FullName.Contains(".ISingletonDependency")))
            .ToList();
    //获取标记了ISingletonDependency接口的类
    var singletonTypeDependency = assembly.GetTypes()
            .Where(t => t.GetInterfaces().Contains(typeof(ISingletonDependency)))
            .ToList();
    //自动注入标记了 ISingletonDependency接口的 接口
    foreach (var interfaceName in singletonInterfaceDependency)
    {
        var type = assembly.GetTypes().Where(t => t.GetInterfaces().Contains(interfaceName)).FirstOrDefault();
        if (type != null)
            services.AddSingleton(interfaceName, type);
    }
    //自动注入标记了 ISingletonDependency接口的 类
    foreach (var type in singletonTypeDependency)
    {             
        services.AddSingleton(type, type);
    }
然后在Startup.cs文件的ConfigureServices方法里调用下就好了
public void ConfigureServices(IServiceCollection services)
{
    var assemblyWeb = Assembly.GetExecutingAssembly();
    // 自动注入
    AutoInjection(services, assemblyApplication);
这样以后我们只要给某个接口和类定义了ISingletonDependency接口就会被自动单例注入了。是不是很酸爽！
什么？反射低效？别闹了，这只是在程序第一次启动的时候才运行的。
嗨-博客，的源代码就是如此实现。
当然，给你一个跑不起来的Demo是很痛苦的，没有对应源码的博文看起来更加痛苦。特别是总有这里或那里有些细节没注意，导致达不到和博文一样的效果。
所以我又另外重写了一个Demo。话说，我都这么体贴了你不留下赞了再走真的好吗？如果能在github上送我颗星星就再好不过了！
 
-------------------- 更新 -------------------------
基于园友对关于DbContext能不能单次请求内唯一？DbContex需不需要主动释放？：http://www.cnblogs.com/zhaopei/p/dispose-on-dbcontext.html
 
博文源码

嗨博客，基于ASP.NET COre 2.0的跨平台的免费开源博客 https://github.com/zhaopeiym/Hi-Blogs （求⭐⭐）
demo https://github.com/zhaopeiym/BlogDemoCode/tree/master/依赖注入/DIDemo

相关资料

http://www.cnblogs.com/hjf1223/archive/2010/10/10/static_datacontext.html

http://www.cnblogs.com/xishuai/p/ef-dbcontext-thread-safe.html


article  4
title: 面对疑似网络诈骗，应该怎样维权？反信用钱包！
body: 

受害人群逐渐增多，各平台依然可以下载，相关部门依然没有动作。
反信用钱包群：187865423
新浪新闻：
http://comment5.news.sina.com.cn/comment/skin/default.html?channel=cj&newsid=comos-fxwvpar8410253
同步知乎提问：（请求各位园友、知乎大佬加速扩散）
https://www.zhihu.com/question/60349734/answer/175494684


article  5
title: Linux学习(1)-常用快捷键、文件管理和查询
body: 
有话要说
为什么要用Linux？要用Linux的原因太多，想说说不完啊。
如果你说用Linux只是为了装逼，那证明你真的还很菜。不排除有装逼了因素，那也只占非常少的比例，可以忽略不计。
我们反问一下，为什么不用Linux呢？回答无非就是：没有图像界面、操作太复杂、和我以前的使用习惯不一样、学习新的系统需要学习成本。
其实只是我们排斥未知的恐惧，从心底里面抵触，而找的各种理由。要想做好一件事，我们会去找各种方法。不想做一件事，我们会去找各种理由。
.net core的推出绝对不是让我们在Windows上玩玩的。特别是多年经验的.net er，需要快速适应这种变化，不然这是个危险的信号啊。
我们正在进行一场革命，革的不好就没命了。微软都已经拥抱Linux了，你还有在坚持什么呢？（当然，如果你只是想玩.net framework的话，当我没说。）

进入Linux你将进入另一个世界，下面开始我们Linux的学习吧~
Shell应用技巧，常用快捷键
Shift + insert             #粘贴
Ctrl + insert              #复制
Tab【按键】或者 Ctrl + i   #命令补齐 【这个快捷键太有用了，这不就是linux下的智能提示么】
Ctrl + w                   #删除前一个单词
Ctrl + u                   #删除光标前全部字符
Ctrl + k                   #删除光标后全部字符
Ctrl + d                   #删除光标所在字符
Ctrl + y                   #将删除的字符粘出来
Ctrl + a                   #将光标移动到行首
Ctrl + e                   #将光标移动到行尾
← 或者 ctrl + b            #光标左移动
→ 或者 Ctrl + f            #光标右移动
↑ 或者 Ctrl + p            #显示上一条命令
↓ 或者 ctrl + n            #显示下一条命令
ctrl + s                   #暂时冻结输入
ctrl + q                   #解冻(解冻后会自动输入之前的输入)
Ctrl + l                   #清屏  
Ctrl + c                   #退出正在的执行命令或另起一行
Ctrl + d                   #退出登录
Ctrl + z
帮助命令
man （帮助命令）
原意：manual
语法：man [命令或配置文件]  
首先我们学习linux命令太多，不可能记住所有命令。那么这个man命令就是个很好的帮助命令。  
示例：
man 1 passwd  # 1查看命令帮助 ，1默认可以省略
man 5 passwd  # 5查看配置文件帮助
#只要按下/，光标就会跑到这个地方来，你就可以开始输入搜寻字串（n继续往下查询，N方向查询）
#q退出、空格向下翻页、pgup向上翻页
info （和man差不多）
原意：information
语法：info [任何关键字]
whatis （查询基本信息，等效于man -f）
#mandb 更新whatis数据库
help （帮助）
可以查询一些shell内置命令帮助，如 cd、pwd
--help (获取选项信息【常用】)
示例: 
[root@localhost ~]# cat --help
用法：cat [选项]... [文件]...
将[文件]或标准输入组合输出到标准输出。
  -A, --show-all           等于-vET
  -b, --number-nonblank    对非空输出行编号
  -e                       等于-vE
  -E, --show-ends          在每行结束处显示"$"
  -n, --number             对输出的所有行编号
  -s, --squeeze-blank      不输出多行空行
  -t                       与-vT 等价
  -T, --show-tabs          将跳格字符显示为^I
  -u                       (被忽略)
  ...
有了这个命令，我们学习起来就有了诀窍。  
alias （别名）
查看别名：alias
命令别名：alias mycp='cp'
这样起的别名只在当前窗口有效，如果要是命令长期有效则要修改配置文件.bashrc，在/root目录下。  
这样就很方便我们定制自己的个性命令了。比如重启supervisorctl reload这个命令记不住，太长了。我们可以别名alias reloadsupervisorctl='supervisorctl reload'。这样我们只要记住reload然后按tab键就可以自动补全了。
文件管理、文件搜索命令
cd （切换目录）
原意：change directo
语法：cd [目录]
pwd （显示当前目录）
原意：print working directory
语法：pwd
特殊目录
. 代表此层目录（cd ./dotnet 和 cd dotnet等效）
.. 代表上一层目录
- 代表前一个工作目录（上次执行cd前的目录）
~ 代表“目前使用者身份”所在的主文件夹（和直接执行cd等效）
~account 代表 account 这个使用者的主文件夹（ account是个帐号名称）
示例：
cd ~   #和直接cd 等效
cd ..  #返回上层目录
cd -   #回到上次执行cd执行前的目录
ls （显示目录文件）
- 原意：list
- 语法：ls [-ald] [文件或目录]
touch （创建空文件）
语法：touch [文件名]
查看文件的时间信息：
modification time （ mtime）：内容数据变更时
status time （ ctime）：状态改变时
access time （ atime） ：该文件的内容被取用时
示例：
[root@localhost dotnet]# ls -l dotnet              #查看dotnet文件的创建时间（默认就是mtime）
-rwxr-xr-x. 1 1002 27 105664 7月  21 07:16 dotnet
[root@localhost dotnet]# ls -l --time=atime dotnet #查看dotnet文件的读取时间
-rwxr-xr-x. 1 1002 27 105664 8月  19 17:31 dotnet
[root@localhost dotnet]# ls -l --time=ctime dotnet #查看dotnet文件的状态更新时间
-rwxr-xr-x. 1 1002 27 105664 8月  15 20:23 dotnet

mkdir （创建新目录）
语法：mkdir [目录名]
cp （复制文件或目录）
语法：cp -r [原文件或目录][目的目录]
示例：
[root@localhost ~]# cp mytest.txt mytest2.txt #复制mytest.txt 到 mytest2.txt
[root@localhost ~]# cp project project2       #复制文件夹（如果文件夹里面有内容赋值失败） 
cp: 略过目录"project"
[root@localhost ~]# cp -r project project2    #复制文件夹 （需要带上 -r参数，递回持续复制）
mv （移动文件或重命名）
原意：move
语法：mv [源文件或目录 ][目的目录]
rm （删除文件）
原意：remove
语法：rm -rf [文件或目录]   #r是删除目录 f是不需要确认
示例：
[root@localhost ~]# rm mytest2.txt     #删除文件mytext2.txt（会默认给出提示）
rm：是否删除普通文件 "mytest2.txt"？y
[root@localhost ~]# rm -f mytest.txt   #删除文件不需要提示（带上 -f参数）
[root@localhost ~]# rm project2        #不能删除目录
rm: 无法删除"project2": 是一个目录
[root@localhost ~]# rm -rf project2    #删除目录需要带上-r（-r递回删除、带上f是不需要确认提示，如果一百个文件，提示一百次会疯的）
[root@localhost project2]# rm System.Xml*                #删除System.Xml开头的文件
rm：是否删除普通文件 "System.Xml.ReaderWriter.dll"？y
rm：是否删除普通文件 "System.Xml.XDocument.dll"？y

cat （显示文件内容）
原意：Concatenate
语法：cat [文件名]
示例：
[root@localhost ~]# cat mytest.test     #查看文件mytest.test
[root@localhost ~]# cat -n mytest.test  #-n显示行号 （类似nl命令）
这个命令有个缺点，就是显示全部信息，如果内容过多，浏览就不方便了。
more （分页显示文件内容）
语法：more [文件名] 
 空格或f显示下一页
 回车显示下一行
 q退出
示例：
[root@localhost ~]# more 三体.txt 
输入/  然后输入关键字比如“三”
/三
...跳过
相关文章
 
《三体3》未获雨果奖 ...
《三体》电影确定上映日程,...
#把带“三”的行都搜索出来了。
less （分页查询，比more更加强大）
more 只能翻下一页，less可以上下翻页。
参数：
[pagedown]：向下翻动一页；
[pageup] ：向上翻动一页；
/字串 ：向下搜寻“字串”的功能；
?字串 ：向上搜寻“字串”的功能；
n ：重复前一个搜寻 （ 与 / 或 ? 有关！）
N ：反向的重复前一个搜寻 （ 与 / 或 ? 有关！）
g ：前进到这个数据的第一行去；
G ：前进到这个数据的最后一行去 （ 注意大小写） ；
q ：离开 less 这个程序；
示例：
[root@localhost ~]# less  三体.txt 
输入/  然后输入关键字比如“三” 可以高亮关键字。
head （查看文件的前几行）
语法：head -num [文件名]
示例：
[root@localhost ~]# head -n 5 三体.txt   #显示前五行
[root@localhost ~]# head -n 5 三体.txt   #不显示后五行
tail （查看文件的后几行）
语法：tail -num [文件名]
ln （产生链接文件）
原意：link
语法：ln -s [源文件] [目标文件]
示例：  
ln -s /home/testfile /home/testfile.soft  #创建文件的软链接testfile.soft  
ls -s /home.testfile /home/testifle.hard  #创建文件的硬链接testfile.hard
which （显示系统命令所在目录）
语法：which [命令名称]
示例：
[root@localhost dotnet]# which ifconfig
/usr/sbin/ifconfig
find （查找文件或目录）
语法：find [搜索路径][搜索关键字]
-a 逻辑与 -o 逻辑或  -name文件名 -size文件大小 -cteime文件修改时间
示例：
find /etc -name init    #查找目录下名字是inti的文件   
find /etc -size +204800 #查找目录下大于100M的文件   
find /etc -ctime -1     #查找24小时内被修改过属性的文件和目录  
find mytest -exec ls -l {} \; #查看当前目录mytest文件夹下的文件执行 ls -l 命令。 -exec {}\; 是固定格式。
find mytest -name F* #查找mytest文件夹下以F开头的文件
find mytest -name F??? #查找mytest文件夹下以F开头的并且文件名只有四个字母
locate （寻找文件或目录）
用法：locate [搜索关键字]
示例：
[root@localhost dotnet]# locate dotnet    #查询所有包含dotnet的文件和目录  
[root@localhost dotnet]# locate Dotnet    #查询不到，因为区分大小写
[root@localhost dotnet]# locate -i Dotnet #查找所有路径或文件名包含dotnet关键字文件路径，且不区分大小写
[root@localhost dotnet]# locate -ic Dotnet#查询搜索结果的数量 
3661
说明：
查询缓存数据库里查询（可以使用updatedb命令 [建立目录文件的数据库]，默认每天更新一次）
grep （在文件内容中搜索匹配的行并输出）
用法：grep [指定字符串][源文件]
示例：
grep 我 testfile #搜索当前目录下的文件testfile中包含“我”的行
其他
输入/输出重定向
- > 输出重定向
示例： ls -l > mytest.txt #将当前目录的所以文件信息写入mytest.txt文件下。
- < 输入重定向
示例：wall <  mytest.txt  #将mytest.txt文件里面的内容广播（wall广播命令）  
- 2> 错误重定向
示例：ggg 2> err.txt      # err.txt将记录错误信息 (ggg是个错误命令)
history （显示历史命令）
| （管道）
ls查询到的文件可能很多，如果我们想要分页浏览，我们可以使用管道命令  
ls -l /etc | more              #分页查看etc目录下的文件  
ls -l /etc | grep init         #查看etc目录下文件名包含init的文件  
ls -l /etc | grep init | wc -l #查看etc目录下文件名包含init的文件的个数
命令连接符
 ; 
示例：cd /home ; ls #跳转到home目录并且查看里面的文件（就算是错误的命令也会继续执行后面的命令。）
 &&
示例：ggg && ls #不会查看目录下的文件（中间有错误的命令存在就不会执行后面的命令）
 ||
示例：ggg || ls #会执行查看目录下的文件（遇到可以执行成功的命令就会停止执行后面的命令）
命令替换符
用法：命令1 `命令2`
示例：
ls -l `which cd` #查看cd命令的文件信息（which定位命令的位置）
netstat
netstat -lntp  #查看监听(Listen)的端口
netstat -antp  #查看所有建立的TCP连接
netstat -tunlp #查看端口使用情况 （如  netstat -tunlp | grep 3306 查看3306端口是否被使用）
netstat -n | grep tcp | grep 80 | wc -l #监控网络客户连接数
负载信息
ps -eLf | grep dotnet | wc -l           #监控dotnet线程数
mpstat       #不但能查看所有CPU的平均信息，还能查看指定CPU的信息。
top -u mysql #查看使用情况 按键盘数字“1”，可监控每个逻辑CPU的状况 （http://blog.csdn.net/dxl342/article/details/53507673）
df -lh            #显示所有硬盘的使用状况
firewall防火墙
firewall-cmd --zone=public --add-port=80/tcp --permanent     #开放80端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent  #关闭80端口
firewall-cmd --reload                                        #重新载入，使其生效
systemctl restart firewalld                                  #重启防火墙
firewall-cmd --zone=public --list-ports                      #查看防火墙开启的端口
http://www.cnblogs.com/moxiaoan/p/5683743.html
其他
- su #用户切换
[root@localhost dotnet]# su BennyZhao
[BennyZhao@localhost dotnet]$ su root
- 图形界面与字符界面切换
init 5 #切换到图形界面
init 3 #切换到命令行界面
- 安装rz
yum install lrzsz #安装rz和sz命令
- curl访问
curl              #访问
注意：除了 / 之外，所有的符号都可以为文件或文件夹命名。命名大小写敏感。
yum list installed | grep dotnet  #查找已经安装的程序
yum remove dotnet                  #卸载安装的程序
推荐
我的博客只是个人学习总结，并不适合园友用来学习。
这里推荐《鸟哥的Linux 私房菜》：http://linux.vbird.org/linux_basic/0220filemanager.php 这是网页版（默认是繁体字，可以使用chrome浏览器自动翻译成简体。可以用pocket插件在手机端看）网上也有PDF、mobi版。
然后喜欢看视频的可以：http://study.163.com/course/introduction.htm?courseId=266032#/courseDetail?tab=1 李明老师的视频也很不错，你也可以下载网易云课堂手机版在公交车或地铁上看。

article  6
title: 浅析C#中单点登录的原理和使用
body: 
什么是单点登录？
我想肯定有一部分人“望文生义”的认为单点登录就是一个用户只能在一处登录，其实这是错误的理解（我记得我第一次也是这么理解的）。
单点登录指的是多个子系统只需要登录一个，其他系统不需要登录了（一个浏览器内）。一个子系统退出，其他子系统也全部是退出状态。
如果你还是不明白，我们举个实际的例子把。比如博客园首页：https://www.cnblogs.com，和博客园的找找看http://zzk.cnblogs.com。这就是两个系统（不同的域名）。如果你登录其中一个，另一个也是登录状态。如果你退出一个，另一个也是退出状态了。
那么这是怎么实现的呢？这就是我们今天要分析的问题了。
单点登录(SSO)原理

首先我们需要一个认证中心(Service)，和两个子系统(Client)。

当浏览器第一次访问Client1时，处于未登录状态 -> 302到认证中心(Service) -> 在Service的登录页面登录(写入Cookie记录登录信息) -> 302到Client1(写入Cookie记录登录信息)
第二次访问Client1 -> 读取Client1中Cookie登录信息 -> Client1为登录状态

第一次访问Client2 -> 读取Client2中Cookie中的登录信息 -> Client2为未登录状态 -> 302到在Service(读取Service中的Cookie为登录状态) -> 302到Client2(写入Cookie记录登录信息)

我们发现在访问Client2的时候，中间时间经过了几次302重定向，并没有输入用户名密码去登录。用户完全感觉不到，直接就是登录状态了。
图解：

手撸一个SSO
环境：.NET Framework 4.5.2
Service：
/// <summary>
/// 登录
/// </summary>
/// <param name="name"></param>
/// <param name="passWord"></param>
/// <param name="backUrl"></param>
/// <returns></returns>
[HttpPost]
public string Login(string name, string passWord, string backUrl)
{
    if (true)//TODO：验证用户名密码登录
    {
        //用Session标识会话是登录状态
        Session["user"] = "XX已经登录";
        //在认证中心 保存客户端Client的登录认证码
        TokenIds.Add(Session.SessionID, Guid.NewGuid());
    }
    else//验证失败重新登录
    {
        return "/Home/Login";
    }
    return backUrl + "?tokenId=" + TokenIds[Session.SessionID];//生成一个tokenId 发放到客户端
}
Client：
public static List<string> Tokens = new List<string>();
public async Task<ActionResult> Index()
{
    var tokenId = Request.QueryString["tokenId"];
    //如果tokenId不为空，则是由Service302过来的。
    if (tokenId != null)
    {
        using (HttpClient http = new HttpClient())
        {
            //验证Tokend是否有效
            var isValid = await http.GetStringAsync("http://localhost:8018/Home/TokenIdIsValid?tokenId=" + tokenId);
            if (bool.Parse(isValid.ToString()))
            {
                if (!Tokens.Contains(tokenId))
                {
                    //记录登录过的Client (主要是为了可以统一登出)
                    Tokens.Add(tokenId);
                }
                Session["token"] = tokenId;
            }
        }
    }
    //判断是否是登录状态
    if (Session["token"] == null || !Tokens.Contains(Session["token"].ToString()))
    {
        return Redirect("http://localhost:8018/Home/Verification?backUrl=http://localhost:26756/Home");
    }
    else
    {
        if (Session["token"] != null)
            Session["token"] = null;
    }
    return View();
}
效果图：

当然，这只是用较少的代码撸了一个较简单的SSO。仅用来理解，勿用于实际应用。
IdentityServer4实现SSO
环境：.NET Core 2.0
上面我们手撸了一个SSO，接下来我们看看.NET里的IdentityServer4怎么来使用SSO。
首先建一个IdentityServer4_SSO_Service(MVC项目)，再建两个IdentityServer4_SSO_Client(MVC项目)
在Service项目中用nuget导入IdentityServer4 2.0.2、IdentityServer4.AspNetIdentity 2.0.0、IdentityServer4.EntityFramework 2.0.0
在Client项目中用nuget导入IdentityModel 2.14.0
然后分别设置Service和Client项目启动端口为 5001(Service)、5002(Client1)、5003(Client2)

在Service中新建一个类Config：
public class Config
{        
    public static IEnumerable<IdentityResource> GetIdentityResources()
        {
            return new List<IdentityResource>
            {
                new IdentityResources.OpenId(),
                new IdentityResources.Profile(),
            };
        }

    public static IEnumerable<ApiResource> GetApiResources()
    {
        return new List<ApiResource>
        {
            new ApiResource("api1", "My API")
        };
    }

    // 可以访问的客户端
    public static IEnumerable<Client> GetClients()
        {           
            return new List<Client>
            {               
                // OpenID Connect hybrid flow and client credentials client (MVC)
                //Client1
                new Client
                {
                    ClientId = "mvc1",
                    ClientName = "MVC Client1",
                    AllowedGrantTypes = GrantTypes.HybridAndClientCredentials,
                    RequireConsent = true,
                    ClientSecrets =
                    {
                        new Secret("secret".Sha256())
                    },
                    RedirectUris = { "http://localhost:5002/signin-oidc" }, //注意端口5002 是我们修改的Client的端口
                    PostLogoutRedirectUris = { "http://localhost:5002/signout-callback-oidc" },
                    AllowedScopes =
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        "api1"
                    },
                    AllowOfflineAccess = true
                },
                 //Client2
                new Client
                {
                    ClientId = "mvc2",
                    ClientName = "MVC Client2",
                    AllowedGrantTypes = GrantTypes.HybridAndClientCredentials,
                    RequireConsent = true,
                    ClientSecrets =
                    {
                        new Secret("secret".Sha256())
                    },
                    RedirectUris = { "http://localhost:5003/signin-oidc" },
                    PostLogoutRedirectUris = { "http://localhost:5003/signout-callback-oidc" },
                    AllowedScopes =
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        "api1"
                    },
                    AllowOfflineAccess = true
                }
            };
        }
}
新增一个ApplicationDbContext类继承于IdentityDbContext：
public class ApplicationDbContext : IdentityDbContext<IdentityUser>
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    } 
    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);
    }
}
在文件appsettings.json中配置数据库连接字符串：
"ConnectionStrings": {
    "DefaultConnection": "Server=(local);Database=IdentityServer4_Demo;Trusted_Connection=True;MultipleActiveResultSets=true"
  }
在文件Startup.cs的ConfigureServices方法中增加:
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<ApplicationDbContext>(options =>
       options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))); //数据库连接字符串
    services.AddIdentity<IdentityUser, IdentityRole>()
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();

    services.AddMvc();

    string connectionString = Configuration.GetConnectionString("DefaultConnection");
    var migrationsAssembly = typeof(Startup).GetTypeInfo().Assembly.GetName().Name;
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddAspNetIdentity<IdentityUser>() 
        .AddConfigurationStore(options =>
        {
            options.ConfigureDbContext = builder =>
                builder.UseSqlServer(connectionString,
                    sql => sql.MigrationsAssembly(migrationsAssembly));
        })
        .AddOperationalStore(options =>
        {
            options.ConfigureDbContext = builder =>
                builder.UseSqlServer(connectionString,
                    sql => sql.MigrationsAssembly(migrationsAssembly));
            options.EnableTokenCleanup = true;
            options.TokenCleanupInterval = 30;
        });
}
并在Startup.cs文件里新增一个方法InitializeDatabase（初始化数据库）：
/// <summary>
/// 初始数据库
/// </summary>
/// <param name="app"></param>
private void InitializeDatabase(IApplicationBuilder app)
{
    using (var serviceScope = app.ApplicationServices.GetService<IServiceScopeFactory>().CreateScope())
    {
        serviceScope.ServiceProvider.GetRequiredService<ApplicationDbContext>().Database.Migrate();//执行数据库迁移
        serviceScope.ServiceProvider.GetRequiredService<PersistedGrantDbContext>().Database.Migrate();

        var context = serviceScope.ServiceProvider.GetRequiredService<ConfigurationDbContext>();
        context.Database.Migrate();
        if (!context.Clients.Any())
        {
            foreach (var client in Config.GetClients())//循环添加 我们直接添加的 5002、5003 客户端
            {
                context.Clients.Add(client.ToEntity());
            }
            context.SaveChanges();
        } 
        if (!context.IdentityResources.Any())
                {
                    foreach (var resource in Config.GetIdentityResources())
                    {
                        context.IdentityResources.Add(resource.ToEntity());
                    }
                    context.SaveChanges();
                } 
        if (!context.ApiResources.Any())
                {
                    foreach (var resource in Config.GetApiResources())
                    {
                        context.ApiResources.Add(resource.ToEntity());
                    }
                    context.SaveChanges();
                }
    }
}
修改Configure方法：
 public void Configure(IApplicationBuilder app, IHostingEnvironment env)
 {
     //初始化数据
     InitializeDatabase(app);
     if (env.IsDevelopment())
     {
         app.UseDeveloperExceptionPage();
         app.UseBrowserLink();
         app.UseDatabaseErrorPage();
     }
     else
     {
         app.UseExceptionHandler("/Home/Error");
     }
     app.UseStaticFiles();
     app.UseIdentityServer();
     app.UseMvc(routes =>
     {
         routes.MapRoute(
             name: "default",
             template: "{controller=Home}/{action=Index}/{id?}");
     });
 }
然后新建一个AccountController控制器，分别实现注册、登录、登出等。
新建一个ConsentController控制器用于Client回调。
然后在Client的Startup.cs类里修改ConfigureServices方法：
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
    services.AddAuthentication(options =>
    {
        options.DefaultScheme = "Cookies";
        options.DefaultChallengeScheme = "oidc";
    }).AddCookie("Cookies").AddOpenIdConnect("oidc", options =>
    {
        options.SignInScheme = "Cookies";
        options.Authority = "http://localhost:5001";
        options.RequireHttpsMetadata = false;
        options.ClientId = "mvc2";
        options.ClientSecret = "secret";
        options.ResponseType = "code id_token";
        options.SaveTokens = true;
        options.GetClaimsFromUserInfoEndpoint = true;
        options.Scope.Add("api1");
        options.Scope.Add("offline_access");
    });
}

对于Client的身份认证就简单了：
[Authorize]//身份认证
public IActionResult Index()
{
    return View();
}

/// <summary>
/// 登出
/// </summary>
/// <returns></returns>
public async Task<IActionResult> Logout()
{
    await HttpContext.SignOutAsync("Cookies");
    await HttpContext.SignOutAsync("oidc");
    return View("Index");
}
效果图：

 
 
源码地址（demo可配置数据库连接后直接运行）

https://github.com/zhaopeiym/BlogDemoCode/tree/master/sso(%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95)

推荐阅读

http://www.cnblogs.com/ywlaker/p/6113927.html
https://identityserver4.readthedocs.io/en/release


article  7
title: 关于DbContext能不能单次请求内唯一？DbContex需不需要主动释放？欢迎各路大侠来“参战”！
body: 
基于上篇文章《HiBlogs》重写笔记[1]--从DbContext到依赖注入再到自动注入园友 @Flaming丶淡蓝@ 吴瑞祥 提出了讨论和质疑，吓得我连夜查询资料（玩笑~）。
本来重点是想分析“自动注入”和对“注入”有更深的理解。不过既然有疑问和讨论那也是很好的。总比时不时来篇“这个不行”“那个要死了”的好。
之所以没有在评论区马上回复，是因为我确实不懂。所以下班后赶紧查阅相关资料。
我个人得出来的结论是：DbContext可以单次请求内唯一，且可以不主动释放。（其实当时心里也纳闷了。asp.net core就是这么干的啊，如果有问题还玩个毛线啊）
相关资料：http://blog.jongallant.com/2012/10/do-i-have-to-call-dispose-on-dbcontext/
这篇资料博客应该还是有一定的权威性的，内容是EF团队解释回应。
Hello Jon,
The default behavior of DbContext is that the underlying connection is automatically opened any time is needed and closed when it is no longer needed. E.g. when you execute a query and iterate over query results using “foreach”, the call to IEnumerable<T>.GetEnumerator() will cause the connection to be opened, and when later there are no more results available, “foreach” will take care of calling Dispose on the enumerator, which will close the connection. In a similar way, a call to DbContext.SaveChanges() will open the connection before sending changes to the database and will close it before returning.
Given this default behavior, in many real-world cases it is harmless to leave the context without disposing it and just rely on garbage collection.
That said, there are two main reason our sample code tends to always use “using” or dispose the context in some other way:
1. The default automatic open/close behavior is relatively easy to override: you can assume control of when the connection is opened and closed by manually opening the connection. Once you start doing this in some part of your code, then forgetting to dipose the context becomes harmful, because you might be leaking open connections.
2. DbContext implements IDiposable following the recommended pattern, which includes exposing a virtual protected Dispose method that derived types can override if for example the need to aggregate other unmanaged resources into the lifetime of the context.
By the way, with DbContext the pattern to open the connection manually and override the automatic open/close behavior is a bit awkward:
((IObjectContextAdapter)dbContext).ObjectContext.Connection.Open()
But we have a bug to make this easier as it used to be with ObjectContext before, e.g.:
dbContext.Database.Connection.Open()
Hope this helps,
Diego
谷歌翻译如下（英文不行，不知道翻译是否正确）：
乔恩，
DbContext的默认行为是底层连接在需要时自动打开，并在不再需要时关闭。例如，当您执行查询并使用“foreach”迭代查询结果时，对IEnumerable <T> .GetEnumerator（）的调用将导致打开连接，并且稍后再没有可用的结果，“foreach”将会关闭调用Dispose在枚举器上，这将关闭连接。以类似的方式，调用DbContext.SaveChanges（）将在将更改发送到数据库之前打开连接，并在返回之前关闭它。
鉴于这种默认行为，在许多现实世界的情况下，离开上下文而不处理它，只依靠垃圾回收是无害的。
也就是说，我们的示例代码往往总是使用“使用”或以其他方式处理上下文的两个主要原因：
1.默认的自动打开/关闭行为相对容易被覆盖：您可以通过手动打开连接来控制何时打开和关闭连接。一旦您在代码的某些部分开始执行此操作，那么忘记使用上下文会变得有害，因为您可能会泄露打开的连接。
2.DbContext根据推荐的模式实现IDiposable，其中包括暴露一个虚拟保护的Dispose方法，如果需要将其他非托管资源聚合到上下文的生命周期中，派生类型可以覆盖。
顺便说一下，用DbContext打开手动连接的模式，覆盖自动打开/关闭的行为有点尴尬：
（（IObjectContextAdapter）的DbContext）.ObjectContext.Connection.Open（）
但是，我们有一个错误，使之更容易，因为它曾经与ObjectContext之前，例如：
dbContext.Database.Connection.Open（）
希望这可以帮助，
迭戈
光说不练假把式，我们还是亲自来测试一下吧。
我们测试分两种情况：

1、主动释放DbContext
2、不释放DbContext
3、最好能用多线程模拟下并发
4、然后查看执行时数据库的连接数，和程序执行完之后数据库的连接数。

测试代码：
//模拟数据库的一些操作（为了相对真实，包含了新增、修改和查询）
private static void DbOperation(BloggingContext db)
{
    db.Blogs.Add(new Blog()
    {
        Rating = 1,
        Url = "www.i.haojima.net"
    });
    db.SaveChanges();

    db.Blogs.First().Url = "www.haojima.net";
    db.SaveChanges();

    foreach (var item in db.Blogs.Take(10).ToList())
    {
        Console.WriteLine("查询到的博客id：" + item.BlogId);
    }
}
条件输入：
static void Main(string[] args)
{
    Console.WriteLine("是否主动释放DbContext（y/n）");
    var yes = Console.ReadLine();
    Console.WriteLine("请输入模拟并发量");
    var number = Console.ReadLine();
    SemaphoreSlim _sem = new SemaphoreSlim(int.Parse(number));
循环代码：
var i = 0;
while (i <= 5000)
{
    Console.WriteLine("启动第" + i++ + "个线程");

    _sem.Wait();

    #region Thread
    new Thread(() =>
           {
               if (yes == "y")
               {
                   using (BloggingContext bloggingContext = new BloggingContext())//主动释放
                   {
                       DbOperation(bloggingContext);
                   }
               }
               else
               {
                   BloggingContext bloggingContext = new BloggingContext();//不释放
                   DbOperation(bloggingContext);
               }

           }).Start();
    #endregion

    _sem.Release();
查看连接数量（sql语句）：
SELECT count(1) AS '连接到EFCoreDemoDB2数据库的数量' FROM
[Master].[dbo].[SYSPROCESSES] WHERE [DBID] IN ( SELECT 
   [DBID]
FROM 
   [Master].[dbo].[SYSDATABASES]
WHERE 
   NAME='EFCoreDemoDB2'
)
操作截图如下（你也可以下载demo代码自行测试）：
主动释放、模拟200并发量


数据库看到的连接数最多的时候54个

不释放、模拟200并发量

数据库看到的连接数最多的时候56个

程序执行完成后，连接自动释放了

 
【技巧】：
我们使用ef或dbcontext的时候主要注意三个问题：

1、多个线程不能访问同一个dbcontext
2、同一个跟踪实体不能被多个dbcontext操作
3、如果查询数据不需要被修改，一定按需查询.select(t=>new Dto(){ })。最不济也要AsNoTracking().ToList()。
一般也就不会出现奇怪的问题了。

 
【注意】运行测试的时候用命令行执行或者“开始执行不调试”
demo：https://github.com/zhaopeiym/BlogDemoCode/tree/master/EFCoreDemo
当然，我也不知道这种测试是否合理。如果园友有更好的测试方式可以提供。欢迎大家交流。

article  8
title: 关于健康和运动
body: 
    像我们程序猿/媛们，天天坐在电脑旁边。运动量为零，还要时刻接受电脑的辐射。那么日子长了，健康自然就出问题了。什么近视眼和肩周炎应是最常见的，就是所谓的职业病。IT界有名的乔帮主都挂了，国内的有张孝祥也挂了年仅38，不是还有李开复也得了淋巴癌。这是大名鼎鼎的。其中还有多少多少的IT草根，加班猝死，时不时都有这样的新闻。难道这还不够我们程序猿/媛们引起警觉吗？健康是大问题啊。身体是革命的本钱， 身体不好，拼不过菜鸟。很多人对技术非常的热爱，天天无休止的学习进步，当人投入到了一件事情里面去了，是不知道时间过了多少的，也许天天加班加点的，但是从中得到了提升，我们就不觉得那么累了。但心里好像过的充实、兴奋，身体就不一定受的了了。
    万事开头难，千里之行始于足下。那就从今天开始，从现在开始。每天进步一点点，坚持下来，你会发现原来我也可以。
    下面我就来与大家分享下，我最近的运动情况。我觉得有效的运动，还是要做有氧运动，比如慢跑啊、爬山啊、滑冰啊、、我在上海，这边都没有看到山，所以只能选择跑步了。滑冰偶尔去。怎样坚持自己的运动呢？最好有个运动记录软件，那样的话，就好像有个东西在督促着，然后有份数据在那里自己的特有成就感。

 
 

 
    这就是我17天的运动数据，其中除了天气下雨和加班。每天必跑。其实老早去年的时候我就想跑步了。一直觉得实在是没时间。唯一有时间就只有周末了，发现周末两天实在是很难坚持。后来又想，要不早上跑吧，懒床有起不来。某次，偶然晚上有人跑步，想了想，那我就晚上跑吧。说实在的，刚开始确实很累很吃力。跑的时候，眼都看不清前面、脚也抬不起来、严重缺氧，肚子里面像打翻了什么一样。但我还是坚持了，心想付出了汗水，总会有回报的。不仅可以锻炼身体，更能锻炼我的毅力。刚开始的时候回到家里起码要半个小时后才能恢复，现在慢慢的十分钟不到就能呼吸平稳，也不继续流汗了。
 
一个人跑步是很孤独的，如果人多了。更能坚持。所以大家可以在网友约跑友一起。
 

 
----------------------------------更新2016-07-10----------------------------------
距离这篇博文发布已经一年多了，是时候更新下数据了。

 

什么事，都是贵在坚持。且，我们每个人都是可以被自己的坚持所吓到！
跑步是一种生活，当你汗流浃背的感觉有多爽，整个人都是轻松的。
不一定要跑多远，但是一定要坚持每天都跑。
我们不比时间、不比路程、不比速度，我们只比看谁更能坚持。
不要求有兔子般的速度，只求有乌龟般的精神。

 
另，热爱运动的农码可以进群（咕咚群）分享心得：
团号：11251918

 
article  9
title: 我们为什么应该坚持写博客
body: 
种种原因：
我们很多人都有过写点东西的冲动，只是又因为种种原因没有发表。

写着写着，挤不出字来了。
总感觉自己的内心想法表达不出来。
感觉写了没什么用，自己都明白了干嘛还要写。
怕写出来被人笑话被人喷。（这个也是我经常害怕的）
写博客的费脑力，耗时间。还不如拿这精力去再学更多的东西。

关于以上几点我的理解：

第一点：万事开头难，我们不管做什么事，最难的就是从零到一的过程。只要你跨过了，什么都是那么的自然。不管写的多差，你就要坚持，然后慢慢得就有了感觉。
第二点：从一个方面说明，我们的表达能力还不行（这正好可以锻炼我们的表达能力）。从另一方面也说明，你对这个问题或是知识点了解得还不够透彻。如果你知道了来龙去脉、前因后果不会说不清除的（借此我们可以更加深入的学习）。
第三点：写博客当然有用，不然那么多牛人为什么写博客。首先，人都有一个遗忘规律。现在你认为已经烂记于心的东西，几个月后说不定就模糊了。其实，很多时候我们都是在反复的记忆遗忘做斗争。不说别的，现在要你写个数据库ado连接你写得出来吗？现在要你写个原生的ajax你写得出来吗？其实，这都是我们读书的时候就写过好多遍的，不如工作中不是经常手动去写很可能现在就忘记了。然，我们写博客有效的加深记忆。万一，还是忘记了，我们查找自己的博客也是很快就能回忆起来的。（其实，我们很多时候都是在反复的在学以前学过的东西，如果我们能过目不忘以前所接触、所学过的，我们一定是牛人了）
第四点：笑就笑呗，哪个牛人不是从菜鸟过来的。我不写教程，我写笔记写心得总可以吧。喷子，是少不了的。就是世上的蚊子无法灭绝。（正好可以锻炼你强大的内心）
第五点：费脑力，确实。耗时间，也是。不过这是值得的。为什么这么说，不管做什么，都是要有付出的。（不过，在后期越写越顺，脑力和时间也就越用越少，就像平时说话那么自然）

好处多多：

可以结交更多的朋友。和同档次和高于你档次的人做朋友，你可以学到很多。（近朱者赤，同道的朋友会有一种暗自竞争的动力）
在我们博文写成，会有很多道友阅读。很多我们自己认为是对的，实际上是错误的东西、或是我们难以发现的错误，热心的道友会帮你指出。这是一个难得的成长机会。
在写博客的过程中，我们肯定会遇到这样或那样的疑问会去查资料。在这过程，我们可能会引发更多的知识或疑问。这个时候问题本身可能就不是那么重要的，引申出来的问题和知识带你会让我们学习到更多。
很多时候，我们也会有心或是无心帮到一些初学者或是遇到同样问题的人。在得到他人的感谢或是肯定的时候心里满满的美（或是虚荣心吧）。
通过博客轨迹，我们以后也可以看到自己的成长轨迹。我们都做过些什么，以后应该怎么做，以至于不忘初心，不迷失自己。
还有一点，也许不是那么明显。我觉得博客是一个非常好的简历。不仅可以看到你的技术水平，还可以看到你平时的关注内容、评论言辞，从而看出你的为人和人品。

我们应该怎样去写好博客：

首先，我们要么就不写要么用心写。也不是说一定要写得多么牛逼，起码用心了，我们就有长进。如果随意滥竽充数，那就真的是浪费时间了。用心了，也不一定就是好的博文，但是会慢慢的一篇篇的变成好的博文。
然后，我们需要假想观众。我们写出来的东西，总是会有人去读的，起码自己会读吧。所以，一定要以能让别人读懂为基础理念。然后就是怎样能让别人更加容易读懂。
想象我们的读者是个初学者。不要一开始，在认为自己懂了的前提直接写下结论。（就像注释一样，也许我们写代码的时候整个逻辑都清晰明了。不过几个后，就要把代码从头理解了。所以，我们必要的时候会标上注释。我们假想对象是初学者，那样我们以后看自己的博客也会马上进入状态理解以前是要表达的意思）。
我们在看某本书的时候就开始计划着，我应该怎样更好的把自己现在看的这节通过博文的方式表达出来，而让读者看得懂。（有个这个想法，你看书会更加的专心，会去了解其原理。而不是像有时候，似懂非懂的情况下继续接着看），我们通过博文形式记录自己的读书笔记，会要比只是把书浏览一遍，然后过几个月又忘记了，然后又去读，要好的多。

 
我注册博客园已经整整五年了，真正开始写博客也只是近一年的事情，以前没写也是因为上面的“种种原因”。然而，正是这一年，是我在程序员的这条道路上，成长最多最快也是这一年。也不是说写博客就真的会让你想开挂般成长。只是真的可以引发很多积极的东西，一些平时你不会去做的东西或者难以坚持的东西。（本人现在正在看《javascript高级程序设计》，并以博文笔记形式记下所读所解）
 
最后附上一副图，平时我群里群友闲聊时的镇群图。 （一图足以解释标题的疑问）

  

这是我个人对写博客的一点心得，每个写博客的人都有自己的心得，我这里列举出来的肯定不全，也有些是你并不认同的。但是，我相信还是有部分是正确有用的。道友们也可以在评论区，写下自己的一点心得，大家探讨探讨。
原文链接：http://www.cnblogs.com/zhaopei/p/4998937.html
如果本文引起了您的共鸣或是对您有点帮助，那么请您轻轻点个赞，鼓励下。

 

 
园友心得（评论）：
 五月的仓颉 
“就拿我自己来说，每次写博客的时候，我都会想到我的博客是面向网友们的，所以必须要非常严谨，一定不能把自己都想不明白的知识点就这么随意往博客上一放，每一句话都必须自己想清楚了才可以，每一个知识点必须自己弄懂了才会写上去。就像我博客里面的一篇Java代码性能优化的文章吧，在发表之前在我的草稿箱里面放了至少有半个月，不断思考、修改，结果在发表之后收到了一些的好评，也被广泛转载。现在，我自己的博客里面草稿箱里面还有9篇文章，只有完全搞懂了，才会发布出去。从这个角度说，对于一个用心写博客的人来说，写博客对于提升自己的严谨度、专业性是非常有帮助的，久而久之，你对于技术的态度也会潜移默化地变成你对于生活的态度。”
 
相关文章推荐：
《为什么要写技术博》：http://www.cnblogs.com/vamei/archive/2012/11/17/2774208.html
《为什么写技术博客对新人如此重要？》：http://blog.csdn.net/oiio/article/details/6913156
《为什么你应该（从现在开始就）写博客》：http://blog.csdn.net/pongba/article/details/3896311
《我为什么鼓励工程师写blog》：https://news.cnblogs.com/n/566179/
 
article  10
title: 文件各种上传，离不开的表单
body: 
作为程序员的我们，经常会要用到文件的上传和下载功能。到了需要用的时候，各种查资料。有木有..有木有...。为了方便下次使用，这里来做个总结和备忘。
利用表单实现文件上传
最原始、最简单、最粗暴的文件上传。
前端代码：
//方式1
<form action="/Home/SaveFile1" method="post" enctype="multipart/form-data">
     <input type="file" class="file1" name="file1" />
     <button type="submit" class="but1">上传</button>
</form>

【注意】

1、需要post提交
2、enctype="multipart/form-data" （传输文件）
3、需要提交的表单元素需要设置 name 属性

后台代码：
public ActionResult SaveFile1()
{
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Request.Files[0].FileName);
        return Content("保存成功");
    }
    return Content("没有读到文件");
}
表单异步上传（jquery.form插件）
虽然上面的方式简单粗暴，但是不够友好。页面必然会刷新。难以实现停留在当前页面，并给出文件上传成功的提示。
随着时间的流逝，技术日新月异。ajax的出现，使得异步文件提交变得更加容易。
下面我们利用jquery.form插件来实现文件的异步上传。
首先我们需要导入jquery.js和jquery.form.js
前端代码：
<form id="form2" action="/Home/SaveFile2" method="post" enctype="multipart/form-data">
    <input type="file" class="file1" name="file1" />
    <button type="submit" class="but1">上传1</button>
    <button type="button" class="but2">上传2</button>
</form>

//方式2（通过ajaxForm绑定ajax操作）
$(function () {
    $('#form2').ajaxForm({
        success: function (responseText) {
            alert(responseText);
        }
    });
});

//方式3（通过ajaxSubmit直接执行ajax操作）
$(function () {
    $(".but2").click(function () {
        $('#form2').ajaxSubmit({
            success: function (responseText) {
                alert(responseText);
            }
        });
    });
});

后台代码：
public string SaveFile2()
{
    if (Request.Files.Count > 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
原理：
我们很多时候使用了插件，就不管其他三七二十一呢。
如果有点好奇心，想想这个插件是怎么实现的。随便看了看源码一千五百多行。我的妈呀，不就是个异步上传吗，怎么这么复杂。
难以看出个什么鬼来，直接断点调试下吧。

原来插件内部有iframe和FormData不同方式来上传，来适应更多版本浏览器。
模拟表单数据上传（FormData）
iframe这东西太恶心。我们看到上面可以利用FormData来上传文件，这个是Html 5 才有的。下面我们自己也来试试把。
前端代码：
<input id="fileinfo" type="file" class="notFormFile" />
<button type="button" class="btnNotForm">上传4</button>
//方式4
$(".btnNotForm").click(function () {
    var formData = new FormData();//初始化一个FormData对象
    formData.append("files", $(".notFormFile")[0].files[0]);//将文件塞入FormData
    $.ajax({
        url: "/Home/SaveFile2",
        type: "POST",
        data: formData,
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });
});

后的代码：（不变，还是上例代码）
public string SaveFile2()
{
    if (Request.Files.Count > 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
我们看到，FormData对象也只是在模拟一个原始的表单格式的数据。那有没有可能不利用表单或表单格式来上传文件呢？答案是肯定的。（下面马上揭晓）
前端代码：
<input type="file"  id="file5" multiple>
<button type="button" class="btnFile5">上传5</button>    

//方式5
$(".btnFile5").click(function () {
    $.ajax({
        url: "/Home/SaveFile4",
        type: "POST",
        data: $("#file5")[0].files[0],
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });;       
});       
     
后台代码：
public string SaveFile4()
{
    //这里发现只能得到一个网络流，没有其他信息了。（比如，文件大小、文件格式、文件名等）
    Request.SaveAs(Server.MapPath("~/App_Data/SaveFile4.data") + "", false);
    return "保存成功";
}
细心的你发现没有了表单格式，我们除了可以上传文件流数据外，不能再告诉后台其他信息了（如文件格式）。
到这里，我似乎明白了以前上传文件为什么非得要用个form包起来，原来这只是和后台约定的一个传输格式而已。
其实我们单纯的用jq的ajax传输文本数据的时候，最后也是组装成了form格式的数据，如：
 $.ajax({
    data: { "userName": "张三" } 
分片上传
在知道了上面的各种上传之后，我们是不是就满于现状了呢？no，很多时候我们需要传输大文件，一般服务器都会有一定的大小限制。
某天，你发现了一个激情小电影想要分享个大家。无奈，高清文件太大传不了，怎么办？我们可以化整为零，一部分一部分的传嘛，也就是所谓的分片上传。
前端代码：
<input type="file" id="file6" multiple>
<button type="button" class="btnFile6">分片上传6</button>
<div class="result"></div>

//方式6
 $(".btnFile6").click(function () { 
     var upload = function (file, skip) {
         var formData = new FormData();//初始化一个FormData对象
         var blockSize = 1000000;//每块的大小
         var nextSize = Math.min((skip + 1) * blockSize, file.size);//读取到结束位置             
         var fileData = file.slice(skip * blockSize, nextSize);//截取 部分文件 块
         formData.append("file", fileData);//将 部分文件 塞入FormData
         formData.append("fileName", file.name);//保存文件名字
         $.ajax({
             url: "/Home/SaveFile6",
             type: "POST",
             data: formData,
             processData: false,  // 告诉jQuery不要去处理发送的数据
             contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
             success: function (responseText) {
                 $(".result").html("已经上传了" + (skip + 1) + "块文件");
                 if (file.size <= nextSize) {//如果上传完成，则跳出继续上传
                     alert("上传完成");
                     return;
                 }
                 upload(file, ++skip);//递归调用
             }
         });
     };

     var file = $("#file6")[0].files[0];
     upload(file, 0);
 }); 

后台代码：
public string SaveFile6()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
相对而言，代码量多了一点，复杂了一点。不过相对于网上的其他分片上传的代码应该要简单得多（因为这里没有考虑多文件块同时上传、断点续传。那样就需要在后台把文件块排序，然后上传完成按序合并，然后删除原来的临时文件。有兴趣的同学可以自己试试，稍候在分析上传插件webuploader的时候也会实现）。
效果图：

【说明】：如果我们想要上传多个文件怎么办？其实H5中也提供了非常简单的方式。直接在input里面标记multiple，<input type="file" id="file6" multiple>，然后我们后台接收的也是一个数组Request.Files。
使用HTML5 拖拽、粘贴上传
只能说H5真是强大啊，权限越来越大，操作越来越牛逼。
前端代码（拖拽上传）：
<textarea class="divFile7" style="min-width:800px;height:150px" placeholder="请将文件拖拽或直接粘贴到这里"></textarea>
//方式7
 $(".divFile7")[0].ondrop = function (event) {

     event.preventDefault();//不要执行与事件关联的默认动作
     var files = event.dataTransfer.files;//获取拖上来的文件

     //以下代码不变
     var formData = new FormData();//初始化一个FormData对象
     formData.append("files", files[0]);//将文件塞入FormData
     $.ajax({
         url: "/Home/SaveFile2",
         type: "POST",
         data: formData,
         processData: false,  // 告诉jQuery不要去处理发送的数据
         contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
         success: function (responseText) {
             alert(responseText);
         }
     });
 };

后台代码：
略（和之前的SaveFile2一样）
前端代码（粘贴上传 限图片格式）：
//方式8
$(".divFile7")[0].onpaste = function (event) {
    event.preventDefault();//不要执行与事件关联的默认动作
    var clipboard = event.clipboardData.items[0];//剪贴板数据
    if (clipboard.kind == 'file' || clipboard.type.indexOf('image') > -1) {//判断是图片格式
        var imageFile = clipboard.getAsFile();//获取文件

        //以下代码不变
        var formData = new FormData;
        formData.append('files', imageFile);
        formData.append('fileName', "temp.png");//这里给文件命个名（或者直接在后台保存的时候命名）
        $.ajax({
            url: "/Home/SaveFile8",
            type: "POST",
            data: formData,
            processData: false,  // 告诉jQuery不要去处理发送的数据
            contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
            success: function (responseText) {
                alert(responseText);
            }
        });
    }
};

后台代码：
public string SaveFile8()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];      
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(filePath);
        return "保存成功";
    }
    return "没有读到文件";
}

效果图：

上传插件（WebUploader）
已经列举分析了多种上传文件的方式，我想总有一种适合你。不过，上传这个功能比较通用，而我们自己写的可能好多情况没有考虑到。接下来简单介绍下百度的WebUploader插件。
比起我们自己写的简单上传，它的优势：稳定、兼容性好（有flash切换，所以支持IE）、功能多、并发上传、断点续传（主要还是靠后台配合）。
官网：http://fex.baidu.com/webuploader/
插件下载：https://github.com/fex-team/webuploader/releases/download/0.1.5/webuploader-0.1.5.zip
下面开始对WebUploader的使用
第一种，简单粗暴
前端代码：
<div id="picker">选择文件</div>
<button id="ctlBtn" class="btn btn-default">开始上传</button>

<!--引用webuploader的js和css-->
<link href="~/Scripts/webuploader-0.1.5/webuploader.css" rel="stylesheet" />
<script src="~/Scripts/webuploader-0.1.5/webuploader.js"></script>
<script type="text/javascript">
    var uploader = WebUploader.create({

        // (如果是新浏览器 可以不用 flash)
        //swf: '/Scripts/webuploader-0.1.5/Uploader.swf',

        // 文件接收服务端。
        server: '/Webuploader/SaveFile',

        // 选择文件的按钮。可选。
        // 内部根据当前运行是创建，可能是input元素，也可能是flash.
        pick: '#picker'
    });

    $("#ctlBtn").click(function () {
        uploader.upload();
    });

    uploader.on('uploadSuccess', function (file) {
        alert("上传成功");
    });

</script>

后台代码：
public string SaveFile()
{
    if (Request.Files.Count > 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
第二种，分片上传。和我们之前自己写的效果差不多。
前端代码：
var uploader = WebUploader.create({ 
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf', 
    // 文件接收服务端。
    server: '/Webuploader/SveFile2', 
    // 开起分片上传。
    chunked: true, 
    //分片大小
    chunkSize: 1000000, 
    //上传并发数
    threads: 1,
    // 选择文件的按钮。 
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    alert("上传成功");
});

后台代码：
public string SveFile2()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName);
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
我们看到了有个参数threads: 1上传并发数，如果我们改成大于1会怎样？前端会同时发起多个文件片上传。后台就会报错，多个进程同时操作一个文件。
那如果我们想要多线程上传怎么办？改代码吧（主要是后台逻辑）。
前端代码：
//并发上传（多线程上传）
var uploader = WebUploader.create({
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf',
    // 文件接收服务端。
    server: '/Webuploader/SveFile3',
    // 开起分片上传。
    chunked: true,
    //分片大小
    chunkSize: 1000000,
    //上传并发数
    threads: 10,
    // 选择文件的按钮。
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    //上传完成后，给后台发送一个合并文件的命令
    $.ajax({
        url: "/Webuploader/FileMerge",
        data: { "fileName": file.name },
        type: "post",
        success: function () {
            alert("上传成功");
        }
    });
});

后台代码：
public string SveFile3()
{
    var chunk = Request.Form["chunk"];//当前是第多少片 

    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(Request.Files
    if (!Directory.Exists(path))//判断是否存在此路径，如果不存在则创建
    {
        Directory.CreateDirectory(path);
    }
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = path + "/" + chunk;
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }           
    return "保存成功";
}
/// <summary>
/// 合并文件
/// </summary>
/// <param name="path"></param>
/// <returns></returns>
public bool FileMerge()
{
    var fileName = Request.Form["fileName"];
    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(fileName);

    //这里排序一定要正确，转成数字后排序（字符串会按1 10 11排序，默认10比2小）
    foreach (var filePath in Directory.GetFiles(path).OrderBy(t => int.Parse(Path.GetFileNameWithoutExtension(t))))
    {
        using (FileStream fs = new FileStream(Server.MapPath("~/App_Data/") + fileName, FileMode.Append, FileAccess.Write))
        {
            byte[] bytes = System.IO.File.ReadAllBytes(filePath);//读取文件到字节数组
            fs.Write(bytes, 0, bytes.Length);//写入文件
        }
        System.IO.File.Delete(filePath);
    }
    Directory.Delete(path);
    return true;
}
到这里你以为就结束了吗？错，还有好多情况没有考虑到。如果多个用户上传的文件名字一样会怎样？如何实现断点续传？还没实现选择多个文件？不过，这里不打算继续贴代码了（再贴下去，代码量越来越多了），自己也来练习练习吧。
提供一个思路，上传前先往数据库插入一条数据。数据包含文件要存的路径、文件名（用GUID命名，防止同名文件冲突）、文件MD5（用来识别下次续传和秒传）、临时文件块存放路径、文件是否完整上传成功等信息。
然后如果我们断网后再传，首先获取文件MD5值，看数据库里面有没上传完成的文件，如果有就实现秒传。如果没有，看是不是有上传了部分的。如果有接着传，如果没有则重新传一个新的文件。
总结
之前我一直很疑惑，为什么上传文件一定要用form包起来，现在算是大概明白了。
最开始在javascript还不流行时，我们就可以直接使用submit按钮提交表单数据了。表单里面可以包含文字和文件。然后随着js和ajax的流行，可以利用ajax直接异步提交部分表单数据。这里开始我就纠结了，为什么ajax可以提交自己组装的数据。那为什么不能直接提交文件呢。这里我错了，ajax提交的并不是随意的数据，最后还是组装成了表单格式（因为后台技术对表单格式数据的支持比较普及）。但是现有的技术还不能通过js组装一个文件格式的表单数据。直到H5中的FormData出现，让前端js组装一个包含文件的表单格式数据成为了可能。所以说表单只是为了满足和后台“约定”的数据格式而已。
 
相关推荐

http://www.cnblogs.com/fish-li/archive/2011/07/17/2108884.html
http://javascript.ruanyifeng.com/htmlapi/file.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/上传下载


article  11
title: ASP.NET Core 快速入门（实战篇）
body: 
上篇讲了《asp.net core在linux上的环境部署》。今天我们将做几个小玩意实战一下。用到的技术和工具有mysql、websocket、AngleSharp（爬虫html解析）、nginx多站点部署。
NO1 留言板（mysql的使用）
演示：http://haojima.net
这个功能很简单。就是对数据库的写入和展示。如果在Windows下，相信大家分分钟都可以搞定。而初次接触.net core + mysql可能需要注意些细节。
首先打开vs2017新建一个asp.net core项目（选Web应用程序），然后nuget 导入Microsoft.EntityFrameworkCore.Tools 1.1.1和MySql.Data.EntityFrameworkCore 8.0.8-dmr。
然后新建一个DbContext类。
public class DataContext : DbContext
{
    //【注意】连接字符串一定要加 sslmode=none 
    string str = @"Data Source=;Database=;User ID=;Password=;pooling=true;CharSet=utf8;port=3306;sslmode=none";
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) =>
        optionsBuilder.UseMySQL(str);

    //下面就可以添加要加入数据库的实体了
    //public DbSet<Message> Messages { get; set; }
}
到此为止，我们已经可以利用EF Core直接连接mysql进行增删改查操作了。注意：需要导入命名空间using Microsoft.EntityFrameworkCore; using MySQL.Data.EntityFrameworkCore.Extensions;
当然。你会说，连接字符串不能硬编码到代码里面。我们也可以放配置文件。appsettings.json
{
  "Logging": {
    "IncludeScopes": false,
    "LogLevel": {
      "Default": "Warning"
    }
  },
  "ConnectionStrings": { "SqlServerConnection": "Data Source=;Database=;User ID=;Password=;pooling=true;CharSet=utf8;port=3306;sslmode=none" }
}

然后把上面的硬编码注释掉。在Startup.cs文件的ConfigureServices方法添加
var connection = Configuration.GetConnectionString("SqlServerConnection");
services.AddDbContext<DataContext>(options => options.UseMySQL(connection));
【注意】项目名称和路径最好不要有中文，不然会出现些乱七八糟的问题。
【完整代码】：https://github.com/zhaopeiym/BlogDemoCode/tree/master/MessageBoard
NO2 聊天室（WebSocket的使用）
演示：http://socket.haojima.net
WebSocket是Html5新增的一个很酷的技术。下面我们简单讲解下这个很酷的技术
var Socket = new WebSocket(url);//创建 WebSocket 对象
创建了一个WebSocket对象后会触发打开连接事件：
Socket.onopen = function(){  }
除了onopen事件，还有其他三个事件：
Socket.onmessage  //客户端接收服务端数据时触发
Socket.onerror    //通信发生错误时触发
Socket.onclose    //连接关闭时触发
另外还有两个方法：
Socket.send()   //使用连接发送数据
Socket.close()  //关闭连接
最后还有四个连接状态属性：
Socket.readyState
0 - 表示连接尚未建立。
1 - 表示连接已建立，可以进行通信。
2 - 表示连接正在进行关闭。
3 - 表示连接已经关闭或者连接不能打开。
整个WebSocket常用功能知识点就四个事件、两个方法、四种状态。简单吧，下面我们看看asp.net core后台的配合：
后台添加一个SocketHandler类，并添加一个静态方法Map：
/// <summary>
/// 请求
/// </summary>
/// <param name="app"></param>
public static void Map(IApplicationBuilder app)
{
    app.UseWebSockets(); //【注意】需要 nuget   导入 Microsoft.AspNetCore.WebSockets.Server
    app.Use(Acceptor);
}
然后新增对应的Acceptor方法：
/// <summary>
/// 接收请求
/// </summary>
/// <param name="httpContext"></param>
/// <param name="n"></param>
/// <returns></returns>
static async Task Acceptor(HttpContext httpContext, Func<Task> n)
{
需要在Startup.cs类里面的Configure方法里面加入
app.Map("/ws", SocketHandler.Map);   //传入我们刚才新建的静态方法Map
现在为止，基本的类和配置已经完成。
我们主要操作，是在Acceptor方法里面接收和发送消息。
//建立连接
var socket = await httpContext.WebSockets.AcceptWebSocketAsync();
//等待接收数据
await socket.ReceiveAsync(new ArraySegment<byte>(buffer), CancellationToken.None);
//发送消息
await socket.SendAsync(arraySegment, WebSocketMessageType.Text, true, CancellationToken.None);
后台关键代码也就这三句，建立连接、等待接收、发送消息。
不过这里有一点需要理解。建立连接后，可以接收任意多次客户端消息。所以ReceiveAsync等待接收这里需要死循环接收消息，直到连接断开。（不用担心真的死循环，没有消息发送的时候，代码会阻塞在那里等待消息）
【完整实现】：https://github.com/zhaopeiym/ChatRoom
NO3 找工作（AngleSharp的使用）
演示：http://job.haojima.net
对于爬虫抓包，我相信大家初次接触都非常的热衷于此。我也不例外。
那么在asp.net core下面是否也有这样的插件呢？答案是肯定的。
http://www.cnblogs.com/linezero/p/5599611.html HtmlAgilityPack HTML解析（感谢博主对.net core的贡献）。不过xpath用起来超级恶心。
之前在.net下面有一款Jumony http://www.cnblogs.com/Ivony/p/3447536.html（博客园大牛写的）。支持CSS选择和linq查询。简直不要太爽。可是不支持.net core。（本人试了下迁移.net core，发现很多类在.net core没有实现）
最后还是到了一款支持.net core的解析组件。并可以媲美Jumony，同样支持css选择和linq查询。那就是AngleSharp。
新建项目，nuget 安装 AngleSharp。然后以下简单使用：
using (HttpClient http = new HttpClient())
{
    var htmlString = await http.GetStringAsync(url);
    HtmlParser htmlParser = new HtmlParser();
    var jobInfos = htmlParser.Parse(htmlString)
        .QuerySelectorAll(".newlist_list_content table")
        .Where(t => t.QuerySelectorAll(".zwmc a").FirstOrDefault() != null)
        .Select(t => new JobInfo()
        {
            PositionName = t.QuerySelectorAll(".zwmc a").FirstOrDefault().TextContent,
            CorporateName = t.QuerySelectorAll(".gsmc a").FirstOrDefault().TextContent,
            Salary = t.QuerySelectorAll(".zwyx").FirstOrDefault().TextContent,
            WorkingPlace = t.QuerySelectorAll(".gzdd").FirstOrDefault().TextContent,
        .ToList();
    return jobInfos;
}
看到没有，就像jq一样解析html。如果你说不爽我都不信。
【完整实现】：https://github.com/zhaopeiym/JobWanted
部署多个站点
以上，这些项目都比较简单。关键技术点和难点都进行的分析。我相信大家都可以动起手练习起来了。
不过有个问题，前面我们只说了部署一个应用程序。如果是多个该怎么部署呢？
首先我们把多个程序发布包放到服务器上。
然后修改nginx的配置文件/etc/nginx/conf.d/default.conf
server {
    listen 80;
    server_name www.haojima.net;           #对应的域名
    root /home/projects/messagBoard;       #程序路径
    location / {
        proxy_pass http://localhost:5000;  #内网端口
        proxy_http_version 1.1; 
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;
        
        proxy_set_header Upgrade $http_upgrade;   
    }
}
有几个程序就添加几个server，不过需要修改你解析到的域名、程序路径和内网对应的端口(看配置里的注释) 。
然后修改supervisor的配置文件/etc/supervisor/conf.d/supervisord.conf
[program:MessageBoard]
command=dotnet MessageBoard.dll        ; 运行程序的命令
directory= /home/projects/messagBoard/ ; 命令执行的目录
autorestart=true                    ; 程序意外退出是否自动重启
stderr_logfile=/var/log/WebApplication1.err.log ; 错误日志文件
stdout_logfile=/var/log/WebApplication1.out.log ; 输出日志文件
environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量
user=root ; 进程执行的用户身份
stopsignal=INT
有几个程序就往下复制几份program。需要修改program名称，只要名称不重复就可以。然后修改 运行程序的命令 对应的dll和命令执行的目录（看配置文件的注释）。
如此就可以部署多个程序了。
开始我还以为是在域名解析的时候，解析IP + 端口。原来是多个域名解析到同一个IP，然后nginx在内部做域名和内网端口分发。
一些其它的细节
部署阿里云
我们在linux的防火墙开放了端口，发现在外面还是访问不了（可以telnet IP 端口 来测试）。有可能是阿里云拦截了。https://help.aliyun.com/document_detail/25471.html 在安全组添加某端口哪些IP可以访问。
mysql的客户端
对于mysql，我们安装好之后总不能每次命令操作吧。在Windows下面有个客户端Navicat可以方便管理mysql。Navicat
获取ip
用了nginx后发现取不到浏览器IP了。那是因为我们程序都是浏览器访问nginx，然后nginx转发内网程序端口。所以取到的IP都是内网本机IP。如果需要取浏览器IP需要在nginx配置
server {
    listen 80;
    server_name www.haojima.net;
    root /home/projects/messagBoard;
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1; 
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;     # 新添加
    }
}
然后代码里面取IP：
 var ip = HttpContext.Request.Headers["X-real-ip"].FirstOrDefault();
WebSocket在nginx的配置
上面我们写的WebSocket直接运行发现没有任何问题，可是部署在nginx去跑不起来了。那是因为需要nginx支持WebSocket，需要配置。http://nginx.org/en/docs/http/websocket.html
server {
    listen 80;
    server_name job.haojima.net;
    root /home/projects/jobWanted;
    location / {
        proxy_pass http://localhost:5002;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-real-ip $remote_addr;
        proxy_set_header Upgrade $http_upgrade;     # 新增
        proxy_set_header Connection "upgrade";      # 新增 
    }
}
WebSocket心跳
经过上面的配置，我们的WebSocket在nginx上跑起来了。万分欢喜的我们，发现一分钟不发消息就自动掉线了。郁闷至极到头大。细心的同学通过上面的链接资料其实已经有说明：
By default, the connection will be closed if the proxied server does not transmit any data within 60 seconds. This timeout can be increased with the proxy_read_timeout directive. Alternatively, the proxied server can be configured to periodically send WebSocket ping frames to reset the timeout and check if the connection is still alive.
靠，英文实在太烂了。
默认情况下，如果代理的服务器在60秒内没有传输任何数据，则连接将被关闭。可以使用proxy_read_timeout指令增加此超时 。或者，代理服务器可以配置为定期发送WebSocket ping帧以重置超时并检查连接是否仍然存在。
nginx给出了两种解决方案。第一种，修改proxy_read_timeout (默认60秒)。第二种，浏览器客户端定时发送心跳包（时间要短于proxy_read_timeout）。
我使用的是第二种方式。
第一种虽然简单粗暴，但是时间再长也是一个值，还是会有超时的可能。再者，谁能保证浏览器端不会new 很多个WebSocket出来捣蛋。
第二种方式，浏览器定时发送一条消息，内容和后台约定下。如发送“心跳”，然后后台接收消息是，判断如果是“心跳”则不做任何处理。
中文编码
在做“找工作”爬前程无忧的数据时，发现他们使用的GBK编码。而在.net core中默认不支持这种格式，导致取到的数据都是乱码。我们需要nuget安装System.Text.Encoding.CodePages。然后在Startup.cs的Configure里面注册：
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);//注册编码提供程序
使用：
var htmlBytes = await http.GetByteArrayAsync(url);
var htmlString = Encoding.GetEncoding("GBK").GetString(htmlBytes);
asp.net core 端口分配
asp.net core 默认端口都是5000。那么我们运行第二个程序的时候就会提示5000端口被占用。这个时候，我们就需要为每个程序分配不同的端口了。
在根目录新建一个json文件hosting.json
{
  "server.urls": "http://*:5002"
}
在Program.cs文件修改
public static void Main(string[] args)
{
    var config = new ConfigurationBuilder()
          .SetBasePath(Directory.GetCurrentDirectory())
          .AddJsonFile("hosting.json", optional: true)
          .Build();

    var host = new WebHostBuilder()
        .UseKestrel()
        .UseConfiguration(config)
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup<Startup>()
        .UseApplicationInsights()
        .Build();

    host.Run();
}
爬拉勾数据
在爬拉勾网的时候没有搞定，不知道是不是因为https的原因。
using (HttpClient http = new HttpClient())
{
    var url = "https://www.lagou.com/zhaopin/Java/?labelWords=label";
    var htmlString = await http.GetStringAsync(url);
}
在.net core中报错：An unhandled exception occurred while processing the request.
在.net 4.5 中抓到的数据是“页面加载中...”。和浏览器访问的结果不一样。
原因未知。如果有大佬解惑，感激不尽！
 
参考
http://www.runoob.com/html/html5-websocket.html
http://www.cnblogs.com/liguobao/p/6130121.html
http://www.cnblogs.com/linezero/p/5806814.html
演示
http://haojima.net
http://socket.haojima.net
http://job.haojima.net
源码
https://github.com/zhaopeiym/JobWanted
https://github.com/zhaopeiym/ChatRoom
https://github.com/zhaopeiym/BlogDemoCode

article  12
title: ASP.NET Core 快速入门（环境篇）
body: 
【申明】：本人.NET Core小白、Linux小白、MySql小白、nginx小白。而今天要说是让你精通Linux ... 的开机与关机、nginx安装与部署、Core的Hello World ...等。
首先，入门文章园子里面已经很多了。这里再做个整理和备忘。您也可以根据目录挑着看。（亲测多次可行，以下多图预警！）
vmware虚拟机安装
vmware哪里下载？360软件管家就可以下载。然后网上找个序列号。
我这里安装的是12.1.1

安装很简单一直下一步就好了。
CentOS7.3安装
下载CentOS http://isoredirect.centos.org/centos/7/isos/x86_64/ 我们可以选择163或阿里云的节点，速度会快点。

下载完成后打开vmware准备安装







菜鸟可以选择有界面的


选好后然后开始安装，然后设置密码，然后重启就好了。

Windows的客户端软件
下载安装Xshell https://www.baidu.com/baidu?word=Xshell
下载安装WinSCP https://www.baidu.com/baidu?word=WinSCP (你也可以使用Xftp，记得选sftp，不然需要服务器支持ftp)
进入CentOS，右键

开始第一个命令。查看IP
ifconfig -a

接下来，可以全部由Xshell操作。
打开Xshell

然后输入用户名密码登录。（使用root登录）

.NET Core1.1安装
根据微软资料 https://www.microsoft.com/net/core#linuxcentos
在命令行执行：
sudo yum install libunwind libicu  #（安装libicu依赖）
curl -sSL -o dotnet.tar.gz https://go.microsoft.com/fwlink/?linkid=848821 #（下载sdk压缩包） 根据网速，可能快可能慢
sudo mkdir -p /opt/dotnet && sudo tar zxf dotnet.tar.gz -C /opt/dotnet #（解压缩）
sudo ln -s /opt/dotnet/dotnet /usr/local/bin #（创建链接）
dotnet new console -o hwapp   # 我们初始化一个示例Hello World应用程序 （这里稍微耗时点）
cd hwapp
dotnet restore
dotnet run   #运行应用程序 

看到打印的hello world证明 .net core的环境已经装好了。
【小白技巧】

"#"是注释
shirf + insert 粘贴 （不能ctrl + c v 有点不习惯）
ctrl + insert 复制

nginx1.12.1安装
curl -o  nginx.rpm http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
rpm -ivh nginx.rpm
yum install nginx #安装

systemctl start nginx #启动nginx
systemctl enable nginx #设置nginx的开机启动
然后登录 CentOs系统 打开浏览器 输入 ：192.168.233.129 （之前查到的IP）

看到这个页面就代表安装成功了。
配置防火墙
如果你在物理机的浏览器访问，你会发现访问不了。
那是因为CentOs的防火墙拦截了，我们打开端口。
firewall-cmd --zone=public --add-port=80/tcp --permanent #（开放80端口）
systemctl restart firewalld #（重启防火墙以使配置即时生效）
然后访问成功。
部署ASP.NET Core应用程序
打开VS2017 新建一个.net core 项目

右键发布（发布之前最好先在本地跑下看正常不）

然后打开我们的WinSCP（前面下载的）

点击登录，然后就可以看到CentOs系统的文件目录了。然后随便建个文件夹，准备放我们发布发好的程序。

右键上传

然后命令运行
cd /home/NetCoreDemo #这个目录 要输入你自己对应放的目录
dotnet netcoreDemo.dll # netcoreDemo.dll 这个对应你建的项目生成的dll

看到了5000 端口的一个网址，证明部署好了。
然后在虚拟机里面访问 http://localhost:5000 ，ok。

nginx 配置
前面我们只说了nginx，并没有说是干嘛的。nginx的作用有点先iis，是个web服务器。做转发。
我们发现http://localhost:5000 可以访问。但是通过ip却不能访问。那么我们现在就可以通过80访问nginx，然后nginx再帮我们访问5000。

打开路径 /etc/nginx/conf.d
编辑default.conf 文件内容替换为
server {
    listen 80;
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
将nginx添加至SELinux的白名单，否则会报502错误。
nginx -s reload #使其即时生效
【注意】然后这里访问下 http://192.168.233.130/ （对应你自己的centos ip，这一步好重要。应该是要先主动触发这个502错误吧。）
yum install policycoreutils-python  #（选y）
cat /var/log/audit/audit.log | grep nginx | grep denied | audit2allow -M mynginx
semodule -i mynginx.pp
然后我们就可以在物理机上通过ip访问了（不用带端口了，直接80 然后 nginx 转到了5000）。
配置守护服务（Supervisor）
yum install python-setuptools
easy_install supervisor  #安装Supervisor
mkdir /etc/supervisor
echo_supervisord_conf > /etc/supervisor/supervisord.conf  #配置Supervisor

文件的最后
;[include]
;files = relative/directory/*.ini
改成（【注意】去掉;且不能有空格）
[include]
files = conf.d/*.conf
进入目录 /etc/supervisor/ 新建 conf.d文件夹，conf.d文件夹下新建 netcoreDemo.conf文件
内容（【注意】看 第二行 第三行的 注释，根据实际名字填入）
[program:netcoreDemo]
command=dotnet netcoreDemo.dll ; （注意）运行程序的命令
directory= /home/NetCoreDemo/ ; （注意 注意）对应的你的项目的存放目录，这个地方好多初学者搞错！！！
autorestart=true ; 程序意外退出是否自动重启
stderr_logfile=/var/log/WebApplication1.err.log ; 错误日志文件
stdout_logfile=/var/log/WebApplication1.out.log ; 输出日志文件
environment=ASPNETCORE_ENVIRONMENT=Production ; 进程环境变量
user=root ; 进程执行的用户身份
stopsignal=INT
supervisord -c /etc/supervisor/supervisord.conf
ps -ef | grep netcoreDemo  #【注意】netcoreDemo是上面 program:netcoreDemo 的命名 
supervisorctl reload  #重新加载

然后就好了，现在关掉那个5000界面也可以访问。
配置Supervisor开机启动
打开目录 /usr/lib/systemd/system/ 新建文件 supervisord.service
内容：
# dservice for systemd (CentOS 7.0+)
# by ET-CS (https://github.com/ET-CS)
[Unit]
Description=Supervisor daemon

[Service]
Type=forking
ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf
ExecStop=/usr/bin/supervisorctl shutdown
ExecReload=/usr/bin/supervisorctl reload
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
执行命令：
systemctl enable supervisord  
systemctl is-enabled supervisord #来验证是否为开机启动
到此，完工。现在重新电脑什么都不用管，直接可以访问部署好的网站。
MySql5.6.37安装
http://www.cnblogs.com/starof/p/4680083.html （我用的方法二）
安装rar压缩
下载 http://www.rarsoft.com/download.htm

把文件放服务器上。然后cd到这个目录执行
tar -zxvf rarlinux-x64-5.4.0.tar.gz # rarlinux-x64-5.4.0.tar.gz是你下载的文件名
cd rar
make
rar #安装
安装好了后我们就可以打命令解压文件了
cd #跳到压缩文件目录
rar x ceshi.rar     #解压到当前文件夹 ceshi.rar是压缩文件名
rar a abc.rar ceshi #压缩文件夹 到 abc.rar
在CentOS中安装完rar命令，会自动安装zip命令
cd /home #进入/home目录
zip -r mydata.zip mydata      #把/home目录下面的mydata目录压缩为mydata.zip
unzip mydata.zip -d mydatabak #把/home目录下面的mydata.zip解压到mydatabak目录里面
zip -r abc123.zip abc 123.txt #把/home目录下面的abc文件夹和123.txt压缩成为abc123.zip
unzip wwwroot.zip             #把/home目录下面的wwwroot.zip直接解压到/home目录里面
unzip abc\*.zip               #把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面
unzip -v wwwroot.zip          #查看把/home目录下面的wwwroot.zip里面的内容
unzip -t wwwroot.zip          #验证/home目录下面的wwwroot.zip是否完整
unzip -j wwwroot.zip          #把/home目录下面wwwroot.zip里面的所有文件解压到第一级目录
常用linux命令
cd                 #目录跳转
cd /               #回到上一个目录
ls                 #查看目录下的文件
df -h              #查看文件使用情况
mkdir              #创建文件夹文件夹
vi                 # 编辑文件
:wq!               #强制保存文件，并退出vi

ifconfig -a        #查看ip
free #查看系统资源使用情况 http://blog.csdn.net/zhongluhuaok/article/details/52804187

firewall-cmd --zone=public --add-port=80/tcp --permanent     #开放80端口，也可以是其他端口
firewall-cmd --zone=public --remove-port=80/tcp --permanent  # 关闭端口
systemctl restart firewalld                                  #重启防火墙，使其生效

service mysqld restart #重启mysql
nginx -s reload        # nginx 生效
reboot                 # 重启系统

supervisorctl start program_name   #启动某个进程(program_name=你配置中写的程序名称)
supervisorctl stop program_name    #停止某一进程 (program_name=你配置中写的程序名称)
supervisorctl reload               #重新启动配置中的所有程序
supervisorctl stop all             #停止全部进程
supervisorctl update               #更新新的配置到supervisord    
supervisorctl restart program_name #重启某一进程 (program_name=你配置中写的程序名称)
supervisorctl                      #查看正在守候的进程
http://blog.csdn.net/shudaqi2010/article/details/51153961

clear          #刷新终端屏幕 （或者 ctrl + l）
exit           #退出
shift + insert #粘贴
ctrl + insert  #复制
补充
centos上升级 .net core 2.0 需要先执行官网命令
curl -sSL -o dotnet.tar.gz https://aka.ms/dotnet-sdk-2.0.0-linux-x64
mkdir -p ~/dotnet && tar zxf dotnet.tar.gz -C ~/dotnet
export PATH=$PATH:$HOME/dotnet
然后再删除原有文件夹
rm -rf /opt/dotnet                              #删除原有文件夹
rm -rf /usr/local/bin/dotnet                    #删除原来定义的dotnet命令
sudo ln -s /root/dotnet/dotnet /usr/local/bin   #重新定义dotnet命令
且，项目程序也要升级到2.0，不然dotnet dll不能成功。
 
结束
这几天给我的感受就是，CentOS带我进入了一个更开阔的世界！！！开启我们的.net core吧，你会觉得很好玩的。
打算重写Hi-Blogs系统
访问地址：http://haojima.net （刚入手做了一个留言板、聊天室快去体验下吧。.net core 跑在阿里云linux上的。）
开源地址：https://github.com/zhaopeiym/Hi-Blogs
 
参考

http://www.cnblogs.com/ants/p/5732337.html
http://www.cnblogs.com/keepcodingforever/p/6642183.html
http://www.cnblogs.com/starof/p/4680083.html
http://www.cnblogs.com/linjiqin/archive/2013/03/24/2979897.html


article  13
title: C#单元测试，带你快速入门
body: 
注：本文示例环境

VS2017
XUnit 2.2.0 单元测试框架
xunit.runner.visualstudio 2.2.0 测试运行工具
Moq 4.7.10 模拟框架

为什么要编写单元测试
对于为什么要编写单元测试，我想每个人都有着自己的理由。对于我个人来说，主要是为了方便修改（bug修复）而不引入新的问题。可以放心大胆的重构，我认为重构觉得是提高代码质量和提升个人编码能力的一个非常有用的方式。好比一幅名画一尊雕像，都是作者不断重绘不断打磨出来的，而优秀的代码也需要不断的重构。
当然好处不仅仅如此。TDD驱动，使代码更加注重接口，迫使代码减少耦合，使开发人员一开始就考虑面对各种情况编写代码，一定程度的保证的代码质量，通过测试方法使后续人员快速理解代码...等。
额，至于不写单元测试的原因也有很多。原因无非就两种：懒、不会。当然你还会找更多的理由的。
框架选型
至于框架的选型。其实本人并不了解也没写过单元测试，这算是第一次真正接触吧。在不了解的情况下怎么选型呢？那就是看哪个最火、用的人多就选哪个。起码出了问题也容易同别人交流。

单元测试框架：XUnit 2.2.0。asp.net mvc就是用的这个，此内框架还有：NUnit、MSTest等。
测试运行工具：xunit.runner.visualstudio 2.2.0。类似如：Resharper的xUnit runner插件。
模拟框架：Moq 4.7.10。 asp.net mvc、Orchard使用了。此类框架还有：RhinoMocks、NSubstitute、FakeItEasy等。

基本概念

AAA逻辑顺序

准备（Arrange)对象，创建对象，进行必要的设置


操作（Act）对象


断言（Assert）某件事情是预期的。

Assert(断言)：对方法或属性的运行结果进行检测
Stub(测试存根\桩对象)：用返回指定结果的代码替换方法（去伪造一个方法,阻断对原来方法的调用，为了让测试对象可以正常的执行）
Mock(模拟对象)：一个带有期望方法被调用的存根（可深入的模拟对象之间的交互方式，如：调用了几次、在某种情况下是否会抛出异常。mock是一种功能丰富的stub）
Stub和Mock的定义比较抽象不好理解，延伸阅读1、阅读2、阅读3

好的测试

测试即文档
无限接近言简意赅的自然化语言
测试越简明越好，每个测试只关注一个点。
好的测试足够快,测试易于编写，减少依赖
好的测试应该相互隔离，不依赖于别的测试，不依赖于外部资源
可描述的命名：UnitOfWorkName_ScenarioUnderTest_ExpectedBehavior（命名可团队约定，我甚至觉得中文命名也没什么不可以的）

UnitOfWorkName　　被测试的方法、一组方法或者一组类


Scenario　　测试进行的假设条件，例如“登入失败”，“无效用户”或“密码正确”等


ExpectedBehavior　　在测试场景指定的条件下，你对被测试方法行为的预期　　


基础实践
“废话”说的够多了，下面撸起袖子开干吧。
下面开始准备工作：

vs2017新建一个空项目 UnitTestingDemo
新建类库 TestDemo （用于编写被测试的类）
新建类库 TestDemo.Tests （用于编写单元测试）
对类库 TestDemo.Tests 用nuget 安装XUnit 2.2.0、xunit.runner.visualstudio 2.2.0、Moq 4.7.10。

添加 TestDemo.Tests 对 TestDemo 的引用。

例：
public class Arithmetic
{
    public int Add(int nb1, int nb2)
    {
        return nb1 + nb2;
    }
}
对应的单元测试：（需要导入using Xunit;命名空间。 ）
public class Arithmetic_Tests
{
    [Fact]//需要在测试方法加上特性Fact
    public void Add_Ok()
    {
        Arithmetic arithmetic = new Arithmetic();
        var sum = arithmetic.Add(1, 2);
        
        Assert.True(sum == 3);//断言验证
    }
}
一个简单的测试写好了。由于我们使用的vs2017 它出了一个新的功能“Live Unit Testing”,我们可以启用它进行实时的测试。也就是我们编辑单元测试，然后保存的时候，它会自动生成自动测试，最后得出结果。


我们看到了验证通过的绿色√。
注意到测试代码中的参数和结果都写死了。如果我们要对多种情况进行测试，岂不是需要写多个单元测试方法或者进行多次方法执行和断言。这也太麻烦了。在XUnit框架中为我们提供了Theory特性。使用如下：
例：
[Theory]
[InlineData(2, 3, 5)]
[InlineData(2, 4, 6)]
[InlineData(2, 1, 3)] //对应测试方法的形参
public void Add_Ok_Two(int nb1, int nb2, int result)
{
    Arithmetic arithmetic = new Arithmetic();
    var sum = arithmetic.Add(nb1, nb2);
    Assert.True(sum == result);
}

测试了正确的情况，我们也需要测试错误的情况。达到更好的覆盖率。
例：
[Theory]
[InlineData(2, 3, 0)]
[InlineData(2, 4, 0)]
[InlineData(2, 1, 0)] 
public void Add_No(int nb1, int nb2, int result)
{
    Arithmetic arithmetic = new Arithmetic();
    var sum = arithmetic.Add(nb1, nb2);
    Assert.False(sum == result);
}
有时候我们需要确定异常
例：
public int Divide(int nb1, int nb2)
{
    if (nb2==0)
    {
        throw new Exception("除数不能为零");
    }
    return nb1 / nb2;
}
[Fact]      
public void Divide_Err()
{
    Arithmetic arithmetic = new Arithmetic(); 
    Assert.Throws<Exception>(() => { arithmetic.Divide(4, 0); });//断言 验证异常
}

以上为简单的单元测试。接下来，我们讨论更实际更真实的。
我们一般的项目都离不开数据库操作，下面就来实践下对EF使用的测试：

使用nuget安装 EntityFramework 5.0.0

例：
public class StudentRepositories
{
    //...
    public void Add(Student model)
    {
        db.Set<Student>().Add(model);
        db.SaveChanges();
    }
}
[Fact]
public void Add_Ok()
{
    StudentRepositories r = new StudentRepositories();
    Student student = new Student()
    {
        Id = 1,
        Name = "张三"
    };
    r.Add(student);

    var model = r.Students.Where(t => t.Name == "张三").FirstOrDefault();
    Assert.True(model != null);           
}
我们可以看到我们操作的是EF连接的实际库。（注意：要改成专用的测试库）
我们会发现，每测试一次都会产生对应的垃圾数据，为了避免对测试的无干扰性。我们需要对每次测试后清除垃圾数据。
//注意：测试类要继承IDisposable接口
public void Dispose()
{
 StudentRepositories r = new StudentRepositories();
 var models = r.Students.ToList();
 foreach (var item in models)
 {
     r.Delete(item.Id);
 }
}
这样每执行一个测试方法就会对应执行一次Dispose，可用来清除垃圾数据。
我们知道对数据库的操作是比较耗时的，而单元测试的要求是尽可能的减少测试方法的执行时间。因为单元测试执行的比较频繁。基于前面已经对数据库的实际操作已经测试过了，所以我们在后续的上层操作使用Stub(存根)来模拟，而不再对数据库进行实际操作。
例：
我们定义一个接口IStudentRepositories 并在StudentRepositories 继承。
 public interface IStudentRepositories
 {
     void Add(Student model);
 }
 public class StudentRepositories: IStudentRepositories
 {
    //省略。。。 （还是原来的实现）
 }   
public class StudentService
{
    IStudentRepositories studentRepositories;
    public StudentService(IStudentRepositories studentRepositories)
    {
        this.studentRepositories = studentRepositories;
    }
    public bool Create(Student student)
    {
        studentRepositories.Add(student);

        return true;
    }
}
新建一个类，用来测试。这个Create会使用仓储操作数据库。这里不希望实际操作数据库，以达到快速测试执行。
[Fact]
public void Create_Ok()
{
    IStudentRepositories studentRepositories = new StubStudentRepositories();
    StudentService service = new StudentService(studentRepositories);
    var isCreateOk = service.Create(null);
    Assert.True(isCreateOk);
}

public class StubStudentRepositories : IStudentRepositories
{
    public void Add(Student model)
    {
    }
}

图解：

每次做类似的操作都要手动建议StubStudentRepositories存根，着实麻烦。好在Mock框架（Moq）可以自动帮我们完成这个步骤。
例：
[Fact]
public void Create_Mock_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    StudentService service = new StudentService(studentRepositories.Object);
    var isCreateOk = service.Create(null);
    Assert.True(isCreateOk);
}
相比上面的示例，是不是简化多了。起码代码看起来清晰了，可以更加注重测试逻辑。

下面接着来看另外的情况，并且已经通过了测试
public class Notiy
{
    public bool Info(string messg)
    {
        //发送消息、邮件发送、短信发送。。。
        //.........
        if (string.IsNullOrWhiteSpace(messg))
        {
            return false;
        }
        return true;
    }
}
public class Notiy_Tests
{
    [Fact]
    public void Info_Ok()
    {
        Notiy notiy = new Notiy();
        var isNotiyOk = notiy.Info("消息发送成功");
        Assert.True(isNotiyOk);
    }
}
现在我们接着前面的Create方法加入消息发送逻辑。
public bool Create(Student student)
{
    studentRepositories.Add(student);

    var isNotiyOk = notiy.Info("" + student.Name);//消息通知

    //其他一些逻辑
    return isNotiyOk;
}
[Fact]
public void Create_Mock_Notiy_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    StudentService service = new StudentService(studentRepositories.Object, notiy.Object);
    var isCreateOk = service.Create(new Student());
    Assert.True(isCreateOk);
}
而前面我们已经对Notiy进行过测试了，接下来我们不希望在对Notiy进行耗时操作。当然，我们可以通过上面的Mock框架来模拟。这次和上面不同，某些情况我们不需要或不想写对应的接口怎么来模拟？那就使用另外一种方式把要测试的方法virtual。
例：
public virtual bool Info(string messg)
{
    //发送消息、邮件发送、短信发送。。。
    //.........
    if (string.IsNullOrWhiteSpace(messg))
    {
        return false;
    }
    return true;
}
测试如下
[Fact]
public void Create_Mock_Notiy_Ok()
{
    var studentRepositories = new Mock<IStudentRepositories>();
    var notiy = new Mock<Notiy>();
    notiy.Setup(f => f.Info(It.IsAny<string>())).Returns(true);//【1】
    StudentService service = new StudentService(studentRepositories.Object, notiy.Object);
    var isCreateOk = service.CreateAndNotiy(new Student());
    Assert.True(isCreateOk);
}
我们发现了标注【1】处的不同，这个代码的意思是，执行模拟的Info方法返回值为true。参数It.IsAny() 是任意字符串的意思。
当然你也可以对不同参数给不同的返回值：
notiy.Setup(f => f.Info("")).Returns(false);
notiy.Setup(f => f.Info("消息通知")).Returns(true);
有时候我们还需要对private方法进行测试

使用nuget 安装 MSTest.TestAdapter 1.1.17
使用nuget 安装 MSTest.TestFramework 1.1.17

例：
private bool XXXInit()
{
    return true;
}
[Fact]
public void XXXInit_Ok()
{
    var studentRepositories = new StudentService();
    var obj = new Microsoft.VisualStudio.TestTools.UnitTesting.PrivateObject(studentRepositories);
    Assert.True((bool)obj.Invoke("XXXInit"));
}
如果方法有参数，接着Invoke后面传入即可。
好了，就说这么多吧。只能说测试的内容还真多，想要一篇文章说完是不可能的。但希望已经带你入门了。
附录
xUnit(2.0) 断言 (来源)

Assert.Equal() 验证两个参数是否相等，支持字符串等常见类型。同时有泛型方法可用，当比较泛型类型对象时使用默认的IEqualityComparer实现，也有重载支持传入IEqualityComparer
Assert.NotEqual() 与上面的相反
Assert.Same() 验证两个对象是否同一实例，即判断引用类型对象是否同一引用
Assert.NotSame() 与上面的相反
Assert.Contains() 验证一个对象是否包含在序列中，验证一个字符串为另一个字符串的一部分
Assert.DoesNotContain() 与上面的相反
Assert.Matches() 验证字符串匹配给定的正则表达式
Assert.DoesNotMatch() 与上面的相反
Assert.StartsWith() 验证字符串以指定字符串开头。可以传入参数指定字符串比较方式
Assert.EndsWith() 验证字符串以指定字符串结尾
Assert.Empty() 验证集合为空
Assert.NotEmpty() 与上面的相反
Assert.Single() 验证集合只有一个元素
Assert.InRange() 验证值在一个范围之内，泛型方法，泛型类型需要实现IComparable，或传入IComparer
Assert.NotInRange() 与上面的相反
Assert.Null() 验证对象为空
Assert.NotNull() 与上面的相反
Assert.StrictEqual() 判断两个对象严格相等，使用默认的IEqualityComparer对象
Assert.NotStrictEqual() 与上面相反
Assert.IsType()/Assert.IsType() 验证对象是某个类型（不能是继承关系）
Assert.IsNotType()/Assert.IsNotType() 与上面的相反
Assert.IsAssignableFrom()/Assert.IsAssignableFrom() 验证某个对象是指定类型或指定类型的子类
Assert.Subset() 验证一个集合是另一个集合的子集
Assert.ProperSubset() 验证一个集合是另一个集合的真子集
Assert.ProperSuperset() 验证一个集合是另一个集合的真超集
Assert.Collection() 验证第一个参数集合中所有项都可以在第二个参数传入的Action序列中相应位置的Action上执行而不抛出异常。
Assert.All() 验证第一个参数集合中的所有项都可以传入第二个Action类型的参数而不抛出异常。与Collection()类似，区别在于这里Action只有一个而不是序列。
Assert.PropertyChanged() 验证执行第三个参数Action使被测试INotifyPropertyChanged对象触发了PropertyChanged时间，且属性名为第二个参数传入的名称。
Assert.Throws()/Assert.Throws()Assert.ThrowsAsync()/Assert.ThrowsAsync() 验证测试代码抛出指定异常（不能是指定异常的子类）如果测试代码返回Task，应该使用异步方法
Assert.ThrowsAny() 验证测试代码抛出指定异常或指定异常的子类
Assert.ThrowsAnyAsync() 如果测试代码返回Task，应该使用异步方法

Moq(4.7.10) It参数约束

Is：匹配确定的给定类型
IsAny：匹配给定的任何值
IsIn: 匹配指定序列中存在的任何值
IsNotIn: 匹配指定序列中未找到的任何值
IsNotNull: 找任何值的给定值类型，除了空
IsInRange：匹配给定类型的范围
IsRegex：正则匹配

相关资料

Moq（Mock框架）：

http://www.cnblogs.com/haogj/archive/2011/07/22/2113496.html


http://www.cnblogs.com/jams742003/archive/2010/03/02/1676215.html

NSubstitute（Mock框架）：http://www.cnblogs.com/gaochundong/archive/2013/05/22/nsubstitute_manual.html
Shouldly（方便断言书写）：http://www.cnblogs.com/defzhu/p/4841289.html
Effort.EF6：通过nuget获取，使得创建一个伪造的、供EF容易使用的内存数据库成为可能。
netDumbster：通过nuget获取netDumbster组件，该组件提供了SimpleSmtpServer对象用于模拟邮件发送环境
HttpSimulator：通过nuget获取，通过使用HttpSimulator对象发起Http请求，在其生命周期内HttContext对象为可用状态
相关书籍：《单元测试之道》、《C#测试驱动开发》、《测试驱动开发》、《单元测试艺术》

相关推荐

http://www.cnblogs.com/easygame/p/5199785.html

http://www.cnblogs.com/edisonchou/p/5447812.html
http://www.cnblogs.com/lsxqw2004/p/4793623.html

demo

https://github.com/zhaopeiym/BlogDemoCode/tree/master/UnitTestingDemo


article  14
title: C#异步的世界【下】
body: 
 
接上篇：《C#异步的世界【上】》
上篇主要分析了async\await之前的一些异步模式，今天说异步的主要是指C#5的async\await异步。在此为了方便的表述，我们称async\await之前的异步为“旧异步”，async\await为“新异步”。
新异步的使用
只能说新异步的使用太简单（如果仅仅只是说使用）
方法加上async修饰符，然后使用await关键字执行异步方法，即可。对就是如此简单。像使用同步方法逻辑一样使用异步。

 public async Task<int> Test()
 {
     var num1 = await GetNumber(1);
     var num2 = await GetNumber(num1);
     var task =  GetNumber(num2);
     //或者
     var num3 = await task;
     return num1 + num2 + num3;
 }

新异步的优势
在此之前已经有了多种异步模式，为什么还要引入和学习新的async\await异步呢？当然它肯定是有其独特的优势。
我们分两个方面来分析：WinForm、WPF等单线程UI程序和Web后台服务程序。
对于WinForm、WPF等单线程UI程序
代码1（旧异步）

private void button1_Click(object sender, EventArgs e)
{
    var request = WebRequest.Create("https://github.com/");
    request.BeginGetResponse(new AsyncCallback(t =>
    {
        //（1）处理请求结果的逻辑必须写这里
        label1.Invoke((Action)(() => { label1.Text = "[旧异步]执行完毕！"; }));//（2）这里跨线程访问UI需要做处理      
    }), null);
}

代码2（同步）

private void button3_Click(object sender, EventArgs e)
{
    HttpClient http = new HttpClient();
    var htmlStr = http.GetStringAsync("https://github.com/").Result;
    //（1）处理请求结果的逻辑可以写这里
    label1.Text = "[同步]执行完毕！";//（2）不在需要做跨线程UI处理了
}

代码3（新异步）

 private async void button2_Click(object sender, EventArgs e)
 {
     HttpClient http = new HttpClient();
     var htmlStr = await http.GetStringAsync("https://github.com/");
     //（1）处理请求结果的逻辑可以写这里
     label1.Text = "[新异步]执行完毕！";//（2）不在需要做跨线程UI处理了
 }

新异步的优势：

没有了烦人的回调处理
不会像同步代码一样阻塞UI界面（造成假死）
不在像旧异步处理后访问UI不在需要做跨线程处理
像使用同步代码一样使用异步（超清晰的逻辑）

 是的，说得再多还不如看看实际效果图来得实际：（新旧异步UI线程没有阻塞，同步阻塞了UI线程）

【思考】：旧的异步模式是开启了一个新的线程去执行，不会阻塞UI线程。这点很好理解。可是，新的异步看上去和同步区别不大，为什么也不会阻塞界面呢？
【原因】：新异步，在执行await表达式前都是使用UI线程，await表达式后会启用新的线程去执行异步，直到异步执行完成并返回结果，然后再回到UI线程（据说使用了SynchronizationContext）。所以，await是没有阻塞UI线程的，也就不会造成界面的假死。
【注意】：我们在演示同步代码的时候使用了Result。然，在UI单线程程序中使用Result来使异步代码当同步代码使用是一件很危险的事（起码对于不太了解新异步的同学来说是这样）。至于具体原因稍候再分析（哎呀，别跑啊）。
对于Web后台服务程序
也许对于后台程序的影响没有单线程程序那么直观，但其价值也是非常大的。且很多人对新异步存在误解。
【误解】：新异步可以提升Web程序的性能。
【正解】：异步不会提升单次请求结果的时间，但是可以提高Web程序的吞吐量。
1、为什么不会提升单次请求结果的时间？
其实我们从上面示例代码（虽然是UI程序的代码）也可以看出。
 
2、为什么可以提高Web程序的吞吐量？
那什么是吞吐量呢，也就是本来只能十个人同时访问的网站现在可以二十个人同时访问了。也就是常说的并发量。
还是用上面的代码来解释。[代码2] 阻塞了UI线程等待请求结果，所以UI线程被占用，而[代码3]使用了新的线程请求，所以UI线程没有被占用，而可以继续响应UI界面。
那问题来了，我们的Web程序天生就是多线程的，且web线程都是跑的线程池线程（使用线程池线程是为了避免不断创建、销毁线程所造成的资源成本浪费）,而线程池线程可使用线程数量是一定的，尽管可以设置，但它还是会在一定范围内。如此一来，我们web线程是珍贵的（物以稀为贵），不能滥用。用完了，那么其他用户请求的时候就无法处理直接503了。
那什么算是滥用呢？比如：文件读取、URL请求、数据库访问等IO请求。如果用web线程来做这个耗时的IO操作那么就会阻塞web线程，而web线程阻塞得多了web线程池线程就不够用了。也就达到了web程序最大访问数。
此时我们的新异步横空出世，解放了那些原本处理IO请求而阻塞的web线程（想偷懒？没门，干活了。）。通过异步方式使用相对廉价的线程（非web线程池线程）来处理IO操作，这样web线程池线程就可以解放出来处理更多的请求了。
不信？下面我们来测试下：
【测试步骤】:
1、新建一个web api项目 
2、新建一个数据访问类，分别提供同步、异步方法(在方法逻辑执行前后读取时间、线程id、web线程池线程使用数)

public class GetDataHelper
{
    /// <summary>
    /// 同步方法获取数据
    /// </summary>
    /// <returns></returns>
    public string GetData()
    {
        var beginInfo = GetBeginThreadInfo();
        using (HttpClient http = new HttpClient())
        {
            http.GetStringAsync("https://github.com/").Wait();//注意：这里是同步阻塞
        }
        return beginInfo + GetEndThreadInfo();
    }

    /// <summary>
    /// 异步方法获取数据
    /// </summary>
    /// <returns></returns>
    public async Task<string> GetDataAsync()
    {
        var beginInfo = GetBeginThreadInfo();
        using (HttpClient http = new HttpClient())
        {
            await http.GetStringAsync("https://github.com/");//注意：这里是异步等待
        }
        return beginInfo + GetEndThreadInfo();
    }

    public string GetBeginThreadInfo()
    {
        int t1, t2, t3;
        ThreadPool.GetAvailableThreads(out t1, out t3);
        ThreadPool.GetMaxThreads(out t2, out t3);
        return string.Format("开始:{0:mm:ss,ffff} 线程Id:{1} Web线程数:{2}",
                                DateTime.Now,
                                Thread.CurrentThread.ManagedThreadId,                                  
                                t2 - t1);
    }

    public string GetEndThreadInfo()
    {
        int t1, t2, t3;
        ThreadPool.GetAvailableThreads(out t1, out t3);
        ThreadPool.GetMaxThreads(out t2, out t3);
        return string.Format(" 结束:{0:mm:ss,ffff} 线程Id:{1} Web线程数:{2}",
                                DateTime.Now,
                                Thread.CurrentThread.ManagedThreadId,
                                t2 - t1);
    }
}

3、新建一个web api控制器

[HttpGet]
public async Task<string> Get(string str)
{
    GetDataHelper sqlHelper = new GetDataHelper();
    switch (str)
    {
        case "异步处理"://
            return await sqlHelper.GetDataAsync();
        case "同步处理"://
            return sqlHelper.GetData();
    }
    return "参数不正确";           
}       

4、发布web api程序，部署到本地iis(同步链接：http://localhost:803/api/Home?str=同步处理  异步链接：http://localhost:803/api/Home?str=异步处理) 
5、接着上面的winform程序里面测试请求：(同时发起10个请求)


private void button6_Click(object sender, EventArgs e)
{
    textBox1.Text = "";
    label1.Text = "";
    Task.Run(() =>
    {
        TestResultUrl("http://localhost:803/api/Home?str=同步处理");
    });
}

private void button5_Click(object sender, EventArgs e)
{
    textBox1.Text = "";
    label1.Text = "";
    Task.Run(() =>
    {
        TestResultUrl("http://localhost:803/api/Home?str=异步处理");
    });
}

public void TestResultUrl(string url)
{
    int resultEnd = 0;
    HttpClient http = new HttpClient();

    int number = 10;
    for (int i = 0; i < number; i++)
    {
        new Thread(async () =>
        {
            var resultStr = await http.GetStringAsync(url);
            label1.Invoke((Action)(() =>
            {
                textBox1.AppendText(resultStr.Replace(" ", "\r\t") + "\r\n");
                if (++resultEnd >= number)
                {
                    label1.Text = "全部执行完毕";
                }
            }));

        }).Start();
    }
}

View Code
6、重启iis，并用浏览器访问一次要请求的链接地址（预热）
7、启动winform程序，点击“访问同步实现的Web”：


8、重复6，然后重新启动winform程序点击“访问异步实现的Web”

看到这些数据有什么感想？
数据和我们前面的【正解】完全吻合。仔细观察，每个单次请求用时基本上相差不大。 但是步骤7"同步实现"最高投入web线程数是10,而步骤8“异步实现”最高投入web线程数是3。
也就是说“异步实现”使用更少的web线程完成了同样的请求数量，如此一来我们就有更多剩余的web线程去处理更多用户发起的请求。
接着我们还发现同步实现请求前后的线程ID是一致的，而异步实现前后线程ID不一定一致。再次证明执行await异步前释放了主线程。
【结论】：

使用新异步可以提升Web服务程序的吞吐量
对于客户端来说，web服务的异步并不会提高客户端的单次访问速度。
执行新异步前会释放web线程，而等待异步执行完成后又回到了web线程上。从而提高web线程的利用率。

【图解】：

Result的死锁陷阱
我们在分析UI单线程程序的时候说过，要慎用异步的Result属性。下面我们来分析：

private void button4_Click(object sender, EventArgs e)
{
    label1.Text = GetUlrString("https://github.com/").Result;
}

public async Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url);
    }
}

代码 GetUlrString("https://github.com/").Result 的Result属性会阻塞(占用)UI线程，而执行到GetUlrString方法的 await异步的时候又要释放UI线程。此时矛盾就来了，由于线程资源的抢占导致死锁。
且Result属性和.Wait()方法一样会阻塞线程。此等问题在Web服务程序里面一样存在。（区别：UI单次线程程序和web服务程序都会释放主线程，不同的是Web服务线程不一定会回到原来的主线程，而UI程序一定会回到原来的UI线程）
我们前面说过，.net为什么会这么智能的自动释放主线程然后等待异步执行完毕后又回到主线程是因为SynchronizationContext的功劳。
但这里有个例外，那就是控制台程序里面是没有SynchronizationContext的。所以这段代码放在控制台里面运行是没有问题的。

static void Main(string[] args)
{
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
    GetUlrString("https://github.com/").Wait();
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
    Console.ReadKey();
}

public async static Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
        return await http.GetStringAsync(url);
    }
}

打印出来的都是同一个线程ID
使用AsyncHelper在同步代码里面调用异步
但可是，可但是，我们必须在同步方法里面执行异步怎办？办法肯定是有的
我们首先定义一个AsyncHelper静态类：

static class AsyncHelper
{
    private static readonly TaskFactory _myTaskFactory = new TaskFactory(CancellationToken.None,
        TaskCreationOptions.None, TaskContinuationOptions.None, TaskScheduler.Default);

    public static TResult RunSync<TResult>(Func<Task<TResult>> func)
    {
        return _myTaskFactory.StartNew(func).Unwrap().GetAwaiter().GetResult();
    }

    public static void RunSync(Func<Task> func)
    {
        _myTaskFactory.StartNew(func).Unwrap().GetAwaiter().GetResult();
    }
}

然后调用异步：

private void button7_Click(object sender, EventArgs e)
{
    label1.Text = AsyncHelper.RunSync(() => GetUlrString("https://github.com/"));
}

这样就不会死锁了。
ConfigureAwait
除了AsyncHelper我们还可以使用Task的ConfigureAwait方法来避免死锁

private void button7_Click(object sender, EventArgs e)
{
    label1.Text = GetUlrString("https://github.com/").Result;
}

public async Task<string> GetUlrString(string url)
{
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url).ConfigureAwait(false);
    }
}

ConfigureAwait的作用：使当前async方法的await后续操作不需要恢复到主线程（不需要保存线程上下文）。

异常处理
关于新异步里面抛出异常的正确姿势。我们先来看下面一段代码：

private async void button8_Click(object sender, EventArgs e)
{
    Task<string> task = GetUlrStringErr(null);
    Thread.Sleep(1000);//一段逻辑。。。。
    textBox1.Text = await task;
}

public async Task<string> GetUlrStringErr(string url)
{
    if (string.IsNullOrWhiteSpace(url))
    {
        throw new Exception("url不能为空");
    }
    using (HttpClient http = new HttpClient())
    {
        return await http.GetStringAsync(url);
    }
}

调试执行执行流程：

在执行完118行的时候竟然没有把异常抛出来？这不是逆天了吗。非得在等待await执行的时候才报错，显然119行的逻辑执行是没有什么意义的。让我们把异常提前抛出：

提取一个方法来做验证，这样就能及时的抛出异常了。有朋友会说这样的太坑爹了吧，一个验证还非得另外写个方法。接下来我们提供一个没有这么坑爹的方式：

在异步函数里面用匿名异步函数进行包装，同样可以实现及时验证。
感觉也不比前种方式好多少...可是能怎么办呢。
异步的实现
上面简单分析了新异步能力和属性。接下来让我们继续揭秘异步的本质，神秘的外套下面究竟是怎么实现的。
首先我们编写一个用来反编译的示例：

class MyAsyncTest
{
    public async Task<string> GetUrlStringAsync(HttpClient http, string url, int time)
    {
        await Task.Delay(time);
        return await http.GetStringAsync(url);
    }
}

反编译代码：
点击看大图
为了方便阅读，我们把编译器自动命名的类型重命名。
 GetUrlStringAsync 方法变成了如此模样：

public Task<string> GetUrlStringAsync(HttpClient http, string url, int time)
{
    GetUrlStringAsyncdStateMachine stateMachine = new GetUrlStringAsyncdStateMachine()
    {
        _this = this,
        http = http,
        url = url,
        time = time,
        _builder = AsyncTaskMethodBuilder<string>.Create(),
        _state = -1
    };
    stateMachine._builder.Start(ref stateMachine);
    return stateMachine._builder.Task;
}

方法签名完全一致，只是里面的内容变成了一个状态机 GetUrlStringAsyncdStateMachine  的调用。此状态机就是编译器自动创建的。下面来看看神秘的状态机是什么鬼：

private sealed class GetUrlStringAsyncdStateMachine : IAsyncStateMachine
{
    public int _state;
    public MyAsyncTest _this;
    private string _str1;
    public AsyncTaskMethodBuilder<string> _builder;
    private TaskAwaiter taskAwaiter1;
    private TaskAwaiter<string> taskAwaiter2;    //异步方法的三个形参都到这里来了
    public HttpClient http;
    public int time;
    public string url;

    private void MoveNext()
    {
        string str;
        int num = this._state;
        try
        {
            TaskAwaiter awaiter;
            MyAsyncTest.GetUrlStringAsyncdStateMachine d__;
            string str2;
            switch (num)
            {
                case 0:
                    break;

                case 1:
                    goto Label_00CD;

                default:                    //这里是异步方法 await Task.Delay(time);的具体实现
                    awaiter = Task.Delay(this.time).GetAwaiter();
                    if (awaiter.IsCompleted)
                    {
                        goto Label_0077;
                    }
                    this._state = num = 0;
                    this.taskAwaiter1 = awaiter;
                    d__ = this;
                    this._builder.AwaitUnsafeOnCompleted<TaskAwaiter, MyAsyncTest.GetUrlStringAsyncdStateMachine>(ref awaiter, ref d__);
                    return;
            }
            awaiter = this.taskAwaiter1;
            this.taskAwaiter1 = new TaskAwaiter();
            this._state = num = -1;
        Label_0077:
            awaiter.GetResult();
            awaiter = new TaskAwaiter();            //这里是异步方法await http.GetStringAsync(url);的具体实现
            TaskAwaiter<string> awaiter2 = this.http.GetStringAsync(this.url).GetAwaiter();
            if (awaiter2.IsCompleted)
            {
                goto Label_00EA;
            }
            this._state = num = 1;
            this.taskAwaiter2 = awaiter2;
            d__ = this;
            this._builder.AwaitUnsafeOnCompleted<TaskAwaiter<string>, MyAsyncTest.GetUrlStringAsyncdStateMachine>(ref awaiter2, ref d__);
            return;
        Label_00CD:
            awaiter2 = this.taskAwaiter2;
            this.taskAwaiter2 = new TaskAwaiter<string>();
            this._state = num = -1;
        Label_00EA:
            str2 = awaiter2.GetResult();
            awaiter2 = new TaskAwaiter<string>();
            this._str1 = str2;
            str = this._str1;
        }
        catch (Exception exception)
        {
            this._state = -2;
            this._builder.SetException(exception);
            return;
        }
        this._state = -2;
        this._builder.SetResult(str);
    }

    [DebuggerHidden]
    private void SetStateMachine(IAsyncStateMachine stateMachine)
    {
    }

}

明显多个异步等待执行的时候就是在不断调用状态机中的MoveNext()方法。经验来至我们之前分析过的IEumerable,不过今天的这个明显复杂度要高于以前的那个。猜测是如此，我们还是来验证下事实：
在起始方法 GetUrlStringAsync 第一次启动状态机 stateMachine._builder.Start(ref stateMachine); 

 确实是调用了 MoveNext 。因为_state的初始值是-1，所以执行到了下面的位置：

绕了一圈又回到了 MoveNext 。由此，我们可以现象成多个异步调用就是在不断执行MoveNext直到结束。
说了这么久有什么意思呢，似乎忘记了我们的目的是要通过之前编写的测试代码来分析异步的执行逻辑的。
再次贴出之前的测试代码，以免忘记了。

反编译后代码执行逻辑图：

当然这只是可能性较大的执行流程，但也有 awaiter.Iscompleted 为 true 的情况。其他可能的留着大家自己去琢磨吧。 
 
本文已同步至索引目录：《C#基础知识巩固》
本文demo：https://github.com/zhaopeiym/BlogDemoCode
 
【推荐】
http://www.cnblogs.com/wisdomqq/archive/2012/03/29/2417723.html
 
article  15
title: 面向对象编程思想(1)--单例模式
body: 
世界上本来没有设计模式。用的人多了，也就成了设计模式。所以，我们不是严格按照它的定义去执行，可以根据自己的实际场景、需求去变通。领悟了其中的思想，实现属于自己的设计模式。
你肯定有过这样的体会。某某时候，听人说起**模式。这么牛逼，回去得看看。结果仔细一看原来自己早就是这么用了，只是不知道它还有个这么高大上的名字。当然，专业的名字方便我们业内交流和教学，对技术的发展和传播起着重要的作用。
废话不多说，和我一起来学习这些高大上的术语吧。本系列《设计模式学习》，通过对传统面向对象编程语言C#和函数为第一等的元素的javascript语言来对比学习加深对设计模式的领悟和运用。
定义
单例模式
个人理解：只能存在一个实例
官方解释：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
C#代码示例
示例1
public static class Singleton
{
   //TODO
}
表激动，它确实不是我们平时使用的单例模式。它只是个静态对象。但是，我觉得也是可以当成单例来使用的。
当然，肯定有它的不足，不然也不会去搞个单例模式了。

致命的缺点，不能继承类也不能实现接口。

静态类中所有方法、字段必须是静态的。
你无法控制它的初始化。

静态类我们一般都是用来编写和业务无关的基础方法、扩展方法。而单例类是一个实例类，一般和业务相关。

示例2
public class Singleton
{
    public static Singleton singleton = new Singleton();   
}
Console.WriteLine(Singleton.singleton.Equals(Singleton.singleton));//true
其实它是个假单例
Singleton s1 = new Singleton();
Singleton s2 = new Singleton();
Console.WriteLine(s1.Equals(s2));//false
且有缺点

在类被加载的时候就自动初始化了singleton
singleton应该被定义为只读属性

示例3
public class Singleton
{
    public static readonly Singleton singleton = new Singleton();//自读字段
    private Singleton()//禁止初始化
    {
    }
}
这是一个比较简单的单例，但是自动化初始变量还是存在
示例4
public class Singleton
{
    public static Singleton singleton = null;

    public static Singleton GetSingleton()
    {
        if (singleton == null)
        {
            singleton = new Singleton();
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
如此一来，我们就可以在调用GetSingleton方法的时候再去实例话了。注意：实例化之后singleton变量值不能再被GC回收了，因为它是个静态变量。
如此就算完事了吗？不，如果多线程同时执行的时候还是会出现多个实例。
public class Singleton
{
    public static Singleton singleton = null;

    public static Singleton GetSingleton()
    {
        if (singleton == null) //线程二执行到这里singleton == null为true，会继续下面实例Singleton
        {
           //线程一执行到这里
            Thread.Sleep(1000);//假设这还有段耗时逻辑（也可以理解并发极限）
            singleton = new Singleton();
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
所以还需要继续改进
示例5
public class Singleton
{
    public static Singleton singleton = null;
    private static object obj = new object();

    public static Singleton GetSingleton()
    {
        if (singleton == null) //下面有锁了为什么还要判断，因为锁会阻塞线程。而singleton被实例化后这个判断永远为false，不在需要锁。
        {
            lock (obj)
            {
                //这里代码只可能存在一个线程同时到达
                if (singleton == null)
                {
                    Thread.Sleep(1000);
                    singleton = new Singleton();
                } 
            } 
        }
        return singleton;
    }
    private Singleton()//禁止初始化
    {
    }
}
这就是我们常见的单例类代码了。当然你也可以改成读取属性的方式。但区别不大。
public class Singleton
{
    private static Singleton singleton = null;
    private static object obj = new object(); 
    public static Singleton Instance
    {
        get
        {
            if (singleton == null)
            {
                lock (obj)
                {
                    if (singleton == null)
                    {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        } 
    }
    private Singleton()//禁止初始化
    {
    }
}
C#使用场景
上面用了那么多的笔墨分析单例模式的使用，可是我们在什么场景下使用单例呢？
最典型的就是配置文件的读取，通常我们的配置文件是在程序第一次启动的时候读取，运行中是不允许修改配置文件的。
public class ConfigInfo
{
    private static ConfigInfo singleton = null;
    private static object obj = new object();
    public static ConfigInfo Instance
    {
        get
        {
            if (singleton == null)
            {
                lock (obj)
                {
                    if (singleton == null)
                    {
                        singleton = new ConfigInfo(); 
                        //从配置文件读取并赋值
                        singleton.Email = "zhaopeiym@163.com";
                        singleton.EmailUser = "农码一生";
                        singleton.EmailPass = "***********";
                    }
                }
            }
            return singleton;
        }
    }

    public string Email { get; private set; }
    public string EmailUser { get; private set; }
    public string EmailPass { get; private set; } 

    private ConfigInfo()//禁止初始化
    {
    }
}
调用
var emailInfo = ConfigInfo.Instance;
EmailSend(emailInfo.Email,emailInfo.EmailUser,emailInfo.EmailPass);
好了，C#中的单例模式大概就这样了。
JS代码示例
js和C#是不同的，一个是"无类"语言，一个是传统的面向对象语言。而在js中的单例就比较简单了。比如我们熟悉的window对象。
那么我们怎么在js中实现自己的单例模式呢？方法很多，先来个简单的：
示例1
var Singleton = {
    name: "农码一生",
    getName: function () {
        return this.name;
    }  
}
这就是一个最简单的单例，通过字面量创建一个对象。看着是不是非常像C#中的静态类？但是，它不存在静态类中的缺点。
继承毫无压力：
var Person = {
    age: 27
}

var Me = Person;
Me.name = "农码一生";
Me.getName = function () {
    return this.name;
}
Me.getAge = function () {
    return this.age;
}
虽然如此，但它并不完美。按理说字段不应该被外界随意修改的。可是js“无类”，更别说私有字段了。幸运的是js中有无处不在的闭包。
示例2
var Singleton = (function () {
    var name = "农码一生";   
    return {
        getName: function () {
            return name;
        }
    }
})();
如此一来，我们就实现了一个单例模式。经过前面对C#单例的分析，我们希望在使用的时候才去实例话对象怎么办？（且不要小看这个惰性加载，在实际开发中作用可大着呢。）
示例3
var Singleton = (function () {

    var Person = function () {
        this.name = "农码一生";
    }
    Person.prototype.getName = function () {
        return this.name;
    };
    var instance;
    return {
        getInstance: function () {
            if (!instance) {
                instance = new Person();
            }
            return instance;
        }
    }
})();

var person1 = Singleton.getInstance();
var person2 = Singleton.getInstance();
console.log(person1 === person2);//true
这算是js中比较标准的单例模式了。可能有同学会问，之前C#的时候我记得加了lock锁的啊。这里怎么就算比较标准了呢。不要忘记，==js天生的单线程，后台天生的多线程==。这就是区别。
为了职责的单一，我应该改写成
示例4
var Person = function () {
    this.name = "农码一生";
}
Person.prototype.getName = function () {
    return this.name;
};
    
var Singleton = (function () {
    var instance;
    return {
        getInstance: function () {
            return instance ||  (instance = new Person(););//简化if判断
        }
    }
})();
我们很多时候都会使用到单例，那我们可否把一个对象变成单例的过程抽象出来呢。如下：
示例5
//通用的创建单例对象的方法
var getSingle = function (obj) {
    var instance;
    return function () {
        return instance || (instance = new obj());
    }
};

var PersonA = function () {
    this.name = "农码一生";
}

var PersonB = function () {
    this.name = "农码爱妹子";
} 

var singlePersonA = getSingle(PersonA);//获取PersonA的单例
var singlePersonB = getSingle(PersonB);//获取PersonB的单例
var a1 = singlePersonA();
var a2 = singlePersonA();
var a3 = singlePersonB();
var a4 = singlePersonB();
console.log(a1 === a2);//true
console.log(a3 === a4);//true
console.log(a1 === a3);//false 
有没有头晕晕的，习惯就好了。你会说，我直接用最开始的全局变量字面量对象得了，可你不要忘记会造成变量名的污染。
JS使用场景
我们在做Tab也切换的时候就可以用到单例模式。在此，我们做个非单例和单例的比较
示例6非单例：
//获取tab1的html数据
var getTab1Html = function () {
    this.url = "/tab/tab1.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
}

var getTab2Html = function () {
    this.url = "/tab/tab2.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
} 

//点击tab1的时候加载tab1的数据
$("#tab1").on("click", function () {
    getTab1Html();
})
$("#tab2").on("click", function () {
    getTab2Html();
})
我们发现没点击一次tab的时候会请求一次后台数据，然后加载页面。这是不是有点傻。正确的姿势应该是第一次点击的时候加载，后面不在请求加载。那么我们就可以使用单例模式了。
示例7单例：
//获取tab1的html数据
var getTab1Html = function () {
    this.url = "/tab/tab1.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
}

var getTab2Html = function () {
    this.url = "/tab/tab2.json";
    //$.get(this.url, function (data) {
    //    //这里获取请求到的数据，然后加载到tab页面
    //}, "json");
    console.log("执行");
} 

var loadTab1 = getSingle(getTab1Html);
var loadTab2 = getSingle(getTab2Html);

//点击tab1的时候加载tab1的数据
$("#tab1").on("click", function () {
    loadTab1();
})
$("#tab2").on("click", function () {
    loadTab2();
})

此时，我们无论点击多少此tab。它也只会在第一次点击的时候请求加载页面数据了。
 
注意：

JS中不建议使用全局变量来达到单例的效果

其一，会引起变量名的全局污染


其二，不能惰性加载。

C#中不建议使用静态类来达到单例的效果

其一，不能继承类和接口


其二，内部变量和方法必须静态。

单例模式中实例变量要慎用。因为一个单例很可能被多处操作（修改了变量），从而影响的预期效果。
 

设计模式之所以能成为设计模式，也是在不断尝试、改进后得到的最佳实践而已。所以，我们不需要生搬硬套，适合的才是最好的。在此，关于单例模式的学习到此结束。谢谢您的阅读。
本文已同步至索引目录：《设计模式学习》
本文demo：https://github.com/zhaopeiym/BlogDemoCode

article  16
title: 面向对象编程思想(前传)--你必须知道的javascript
body: 
在写面向对象编程思想-设计模式中的js部分的时候发现很多基础知识不了解的话，是很难真正理解和读懂js面向对象的代码。为此，在这里先快速补上。然后继续我们的面向对象编程思想-设计模式。
什么是鸭子类型
javascript是一门典型的动态类型语言，也就弱类型语言。
那什么是鸭子类型：【如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子】
var 鸭子 = {
    走路: function () { },
    咕咕咕: function () { }
}

var 鹦鹉 = {
    走路: function () { },
    咕咕咕: function () { }
}
这只鹦鹉同样有“走路”和“咕咕咕”的方法，那在js的世界里就可以把它当成鸭子。
可以这样调用：
var 鸭子们 = [];
鸭子们.push(鸭子);
鸭子们.push(鹦鹉);

for (var i = 0; i < 鸭子们.length; i++) {
    鸭子们[i].走路();
}
所以js的世界没有抽象和接口，但可以约定“我们都是鸭子”。
javascript的面向对象
javascript不仅是直译式脚本语言、动态类型、弱类型语言、函数为一等公民的语言，它还是基于原型的面向对象语言。面向对象三大特性：封装、继承、多态，下面我们用js分别实现。
封装
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();

虽然老的js语法没有提供private等关键字，但是我们可以利用闭包来实现私有字段，达到封装的目的。
继承

字面量表示：
var Person = {
name: "农码一生",
getName: function () {
    console.log(this.name);
}
};
var obj = Person;
obj.getName();

函数构造器：

var Person = function () {
    this.name = "农码一生";    
}
Person.prototype.getName = function () {
    console.log(this.name);
}

var obj = function () { };
obj.prototype = new Person();//obj继承于Person

var o = new obj();
o.getName();//直接调用原型中的getName（类似于C#中的调用父类方法）

多态
对于多态，其实上面的鸭子类型已经表现的很清楚了。
var 鸭子们 = [];
鸭子们.push(鸭子);
鸭子们.push(鹦鹉);

for (var i = 0; i < 鸭子们.length; i++) {
    鸭子们[i].走路();//对于鹦鹉来说，它可能是跳着走。对于鸭子来说，它可能左右摇摆着走。这就是多态的表现。
}
对于鹦鹉来说，它可能是跳着走。对于鸭子来说，它可能左右摇摆着走。这就是多态的表现。
原型
什么是原型？在js中是没有类的，那它怎么创建对象。在C#中我们可以通过new关键字实例化一个对象，在js中我们用new关键字构造一个原型对象。C#中一切对象继承于Object，js中一切对象的原型是Object。
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
};
console.log(Person.prototype);

我们很多时候给一个对象添加方法的时候就是写在原型上，这是为什么？直接写在对象里会有问题吗？下面我们试试：
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
    this.getInfo = function () {
        console.log("name:" + this.name + ",sex:" + this.sex);
    }
};

好像并看不出什么问题。其实不然...

我们发现，每次构造出来的对象中的方法都会去开辟一个空间。但是对象的方法都是一样的，完全没有必要。 我们可以把方法放入原型。

这样一来，不过我们构造多少对象，其方法都是公用的（单例的）。
可是为什么会这样呢？
首先，想想原型这个词，很形象，原本的模型。我们来看一个继承的例子：
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";
    this.getInfo = function () {
        console.log("name:" + this.name + ",sex:" + this.sex);
    }
};
var Student = function () { };
Student.prototype = new Person();//继承
var s1 = new Student();
var s2 = new Student();
console.log(s1.getInfo === s2.getInfo);

虽然getInfo在Person里面是直接实现的，但是到了Student的原型(prototype)里面就是一个Person对象的单例了。也就是说无论构造多少个Student对象其中的getInfo方法都是同一个。
但是，构造多个Person就有多个getInfo方法。所以，我们应该把getInfo方法放入Person的原型中。
var Person = function () {
    this.name = "农码一生";
    this.sex = "纯爷们";   
};
Person.prototype.getInfo = function () {
    console.log("name:" + this.name + ",sex:" + this.sex);
};
我们仔细推敲下这句话“把getInfo方法放入Person的原型中”，Person的原型是Object，那也就是说getInfo方法放到Object里面去了？
是的，不信请看：

如果原型和原型的原型都实现了同样的方法呢？我们来猜猜下面会打印哪个版本
var Person = function () {
    this.name = "农码一生"; 
};
var Student = function () { }; 
Student.prototype = new Person();//继承
var stu = new Student();

Student.prototype.getName = function () {
    console.log("我的名字:" + this.name);
}
Person.prototype.getName = function () {
    console.log("My name is:" + this.name);
}

stu.getName();

如果注释掉中文版呢？

有没有觉得特神奇，具体原因我们用图来回答：

从另个一角度说，如果对象实现了原型中已有的方法那就等效于C#中虚方法重写了。
this指向
var name = "张三";
var obj = {
    name:"李四",
    getName: function(){
        console.log(this.name);
    }
}

obj.getName();

这个结果大家应该没什么疑问。
接着看下面的：
window.name = "张三";
var obj = {
    name:"李四",
    getName: function(){
        console.log(this.name);
    }
} 
//obj.getName();
window.func = obj.getName;
window.func();

晕了没有？没关系，告诉大家一个简单实用的方法：方法是被谁“.”出来的，this就指向的谁。
call
"方法是被谁“.”出来的，this就指向的谁"，这个口诀不一定适用所有方法。为什么这么说呢？请看下面：
window.name = "张三";
var obj = {
    name: "李四",
    getName: function () {
        console.log(this.name);
    }
}
//obj.getName();
window.func = obj.getName;
window.func.call(obj);

虽然还是window点的，但this已经指向了obj。
因为call可以改变this执行。
这个特性非常有用。比如，我们要编写一个下拉选中事件。
function func() {
    console.log("我点击了" + $(this).find("option:selected").text());
}

$("#element1").change(function () {
    func.call(this);
});
$("#element2").change(function () {
    func.call(this);
});
在写func方法的时候不用考虑具体是那个下拉框元素。
apply
apply和call区别不大。
function func(age, sex) {
    console.log("name:" + this.name + ",age:" + age + ",sex:" + sex);
}

var obj = {
    name: "晓梅"
}

func.call(obj, "18", "妹子");
func.apply(obj,["18","小美女"]);

call和apply第一个参数都是this指向的对象。call第二个和以后的参数对应方法func的参数。而apply的第二个参数是个数组，包含方法的所有参数。
band
function func(age, sex) {
    console.log("name:" + this.name + ",age:" + age + ",sex:" + sex);
}

var obj = {
    name: "晓梅"
}
var func1 = func.bind(obj, "18", "妹子");
func1();
和apply、call的区别是，只是改变this指向并不执行。且参数传入方式和call一样。
js中的闭包
什么是闭包？我的理解是存在不能被回收的变量就是闭包。
最常见最大的一个闭包就是全局变量，定义了就不会被销毁，除非自动设为null。
而我们平时说的和使用的闭包却非如此，但同样会产生不会被销毁的变量。比如我们之前说的私有变量示例：
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();
之所以说它是闭包，那是因为sex这个字段是永远不会被销毁。你想想，如果被销毁了，那我们调用getInfo的时候岂不是找不到sex字段了。所以不是不会销毁，而是不能销毁。
闭包的作用不仅仅是私有化。我们再来一例：
for (var i = 0; i < 10; i++) {
    var t = setTimeout(function () {
        console.log(i);
    }, 100);
}

并不是我们想象的那样打印0到9。
因为计时器还没开始循环就执行完了。而此时变量i已经是10。
我们可以通过闭包为每次循环保存一个闭包变量。
for (var i = 0; i < 10; i++) {
    (function (i) {
        var t = setTimeout(function () {
            console.log(i);
        }, 100);
    })(i);
}

什么是高阶函数
“高阶函数”名字特牛逼。其实我们在js中经常使用。
还是私有变量的例子：
var Person = (function () { 
    var sex = "纯爷们";
    return {
        name: "农码一生",
        getInfo: function () {
            console.log("name:" + this.name + ",sex:" + sex);
        }
    };
})();

当函数做被return时，那么就是高阶函数。

var getInfo = function (callback) {
    $.ajax('url', function (data) {
        if (typeof callback === 'function') {
            callback(data);
        }
    });
}
getInfo(function (data) {
    alert(data.userName);
});

getInfo在执行的时候，传入的参数是个函数。

当函数被当成参数传递时，那么这也是高阶函数。

 
本文已同步至索引目录：《设计模式学习》
【demo】：https://github.com/zhaopeiym/BlogDemoCode
【推荐】：深入理解javascript原型和闭包系列
 

生命在于运动，静止是[ ]。


article  17
title: 面向对象编程思想(2)--策略模式
body: 
定义
策略模式
官方定义：定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。
个人理解：选择执行多个规则中的某个规则。
C#实现
需求1: 开发一个商场收银系统v1.0
三下五除二搞定

代码实现：
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额

var money = price * number;//本次计算金额
labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1},金额：{2}", price, number, money + "\r\n");

系统简单、方便、实用、性能好。...几个月过去，马上要国庆长假，老板为了促销决定全场8.8折。
需求2： 加入打折功能
因为项目工期紧，三下五除二又搞定
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额
var discount = 0.88;//折扣(新增代码)

var money = price * number * discount;//本次计算金额
labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，折扣：{2},实际金额：{2}", price, number, discount, money + "\r\n");

很是自豪，我开发效率就是这么高。老板也甚是高兴。
...转眼假期就要过去了，打折的活动也要取消了。但是，由于这次的促销效果收益还不错。老板决定继续打折活动，折扣率要成为9.8折，且只是部分商品。不打折的商品则实行满300返40，满600返100。
不对劲啊，又的改代码。到了明年是不是又要8.8？老板的心思猜不透，但程序可以写得更灵活。所以我们要好好构思下。让系统可以选择优惠策略。
需求3： 修改打折，并加入返现功能

代码实现如下
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额            
var money = price * number;//本次计算金额
switch (cmBstrategy.Text)//下拉框
{

    case "8.8折":
        money *= 0.88;
        break;
    case "9.8折":
        money *= 0.98;
        break;
    case "满300返40":
        if (money >= 300)
        {
            money -= 40;
        }
        break;
    case "满600返100":
        if (money >= 600)
        {
            money -= 100;
        }
        break;
}

labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，促销：{2},实际金额：{3}", price, number, cmBstrategy.Text, money + "\r\n");
现在我们的收银员可以灵活切换优惠活动，且保留的原有的优惠策略。不过我们从代码层面考虑的话，还有多处不足。

switch条件分支语句难以阅读和维护。
如果我们需要修改新增优惠策略的话，需在界面代码里面修改。

根据面向对象的思想，应该封装变化。于是，我们的策略模式可以登场了。
代码重构 使用策略模式实现以上需求
var price = Convert.ToDouble(txtPrice.Text);//单价
var number = Convert.ToDouble(txtNumber.Text);//数量
var lastTotal = Convert.ToDouble(labTotal.Text);//已购买金额      
 
var context = new Context(cmBstrategy.Text);//新增代码
var money = context.Calculation(price, number);//新增代码

labTotal.Text = (lastTotal + money).ToString();
txtContent.Text += string.Format("单价：{0},数量：{1}，促销：{2},实际金额：{3}", price, number, cmBstrategy.Text, money + "\r\n");

我们发现中间那段条件分支不见了，多了一个Context类。
public class Context
{
    //策略抽象类
    private AmountCalculation amountCalculation;

    public Context(string type)
    {
        switch (type)
        {
            case "8.8折":
                amountCalculation = new Rebate(0.88);
                break;
            case "9.8折":
                amountCalculation = new Rebate(0.98);
                break;
            case "满300返40":
                amountCalculation = new Cashback(300, 40);
                break;
            case "满600返100":
                amountCalculation = new Cashback(600, 100);
                break;
        }
    }
    //计算金额
    public double Calculation(double price, double number)
    {
        return amountCalculation.Calculation(price, number);
    }
}
里面有类Rebate折扣计算、Cashback返现计算。
//折扣计算
public class Rebate : AmountCalculation
{
    private double discountRate;
    public Rebate(double discountRate)
    {
        this.discountRate = discountRate;
    }

    public override double Calculation(double price, double number)
    {
        return price * number * discountRate;
    }
}
// 返现
public class Cashback : AmountCalculation
{
    //满多少
    private double exceed;
    //返多少
    private double retreat;
    public Cashback(double exceed, double retreat)
    {
        this.exceed = exceed;
        this.retreat = retreat;
    }
    public override double Calculation(double price, double number)
    {
        var momoney = price * number;
        if (momoney >= exceed)
        {
            return momoney - retreat;
        }
        return momoney;
    }
}
看到这里，是不是明白了策略模式呢？
如果现在老板再需要我们价格折扣或是返现的活动，相比之前需要在长段的界面逻辑代码里面修改，现在要方便得多了。
第一、先在界面添加一个活动如加一个7.8折，然后界面代码就不用动了。
第二、在Context类里面加一个7.8折
switch (type)
{
    //新增
    case "7.8折":
        amountCalculation = new Rebate(0.78);
        break;
JS实现
上面用C#实现了策略模式，接下来我们尝试使用js来实现。还是借用用上面的商场活动业务。
js不同于传统的面向对象，无类、不需要实现抽象类。
//策略计算
var strategies = {
    //返现  exceed：满多少  retreat:返多少  momoney：应付金额
    cashBack: function (exceed, retreat, momoney) {
        if (momoney >= exceed) {
            return (momoney - retreat).toFixed(2);
        }
        return momoney;//返现后实付金额
    },
    //打折 discountRate：折扣率  momoney：应付金额
    rebate: function (discountRate, momoney) {
        return (discountRate * momoney).toFixed(2);//折扣后实付金额
    }
}
//上下文
var context = {
    "7.8折": function (price, number) {
        var momoney = price * number;
        return strategies.rebate(0.78, momoney);
    },
    "9.8折": function (price, number) {
        var momoney = price * number;
        return strategies.rebate(0.98, momoney);
    },
    "满300返40": function (price, number) {
        var momoney = price * number;
        return strategies.cashBack(300, 40, momoney);
    },
    "满600返100": function (price, number) {
        var momoney = price * number;
        return strategies.cashBack(600, 100, momoney);
    }
}
//计算结果
var calculateBonus = function (level, price, number) {
    return context[level](price, number);
};
//调用
console.log(calculateBonus('7.8折', 12, 3));//计算
console.log(calculateBonus('满600返100', 12, 3));//计算
console.log(calculateBonus('满300返40', 2, 23));//计算
console.log(calculateBonus('9.8折', 2, 33));//计算
结果如下：

相对于面向对象语言的实现要更加的清晰明了。
那么js可以模拟面向对象的实现吗？答案是肯定的。
首先定义返现实现类：
//返现  exceed：满多少  retreat:返多少
var CashBack = function (exceed, retreat) {
    this.exceed = exceed;
    this.retreat = retreat;
};
//计算方法
CashBack.prototype.calculate = function (price, number) {
    var momoney = price * number;
    if (momoney >= this.exceed) {
        return (momoney - this.retreat).toFixed(2);
    }
    return momoney;//返现后实付金额
}
打折类
//打折 discountRate：折扣率  momoney：应付金额
var Rebate = function (discountRate) {
    this.discountRate = discountRate;
};
//计算方法
Rebate.prototype.calculate = function (price, number) {
    return (price * number * this.discountRate).toFixed(2);//折扣后实付金额
}
策略上下文
//上下文
var Context = function (type) {
    this.type = type; 
}
Context.prototype.calculation = function (price, number) {
    var AmountCalculation;
    switch (this.type) {
        case "7.8折":
            AmountCalculation = new Rebate(0.78);
            break;
        case "9.8折":
            AmountCalculation = new Rebate(0.98);
            break;
        case "满300返40":
            AmountCalculation = new CashBack(300, 40);
            break;
        case "满600返100":
            AmountCalculation = new CashBack(600, 100);
            break;
    }
    return AmountCalculation.calculate(price, number);
}
调用如下：
//调用
var context = new Context("7.8折");  
console.log(context.calculation(12, 3));
var context = new Context("9.8折");  
console.log(context.calculation(12, 3));//计算
var context = new Context("满300返40");  
console.log(context.calculation(300, 2));//计算
var context = new Context("满600返100");  
console.log(context.calculation(300, 3));//计算

虽然对于js语言特性直接实现策略模式来说，面向对象的代码量比较多。可是对于我们后端人员new一个对象的使用方式应该更习惯。
 
策略模式场景

排序算法的选择冒泡排序、选择排序、快速排序、插入排序
压缩算法的选择zip、rar、rar5...
旅游交通工具的选择飞机、火车、汽车...
 

总结
策略模式通过Context上下文对具体策略进行封装，供高层直接调用而不用关系策略的具体实现。然后Context本身通过不同情况实例不同的抽象实现类（具体策略类），来执行具体策略。从而实现了具体策略的自由切换，易于新策略的扩展。
本文已同步至索引目录：《设计模式学习》
本文demo：https://github.com/zhaopeiym/BlogDemoCode

article  18
title: 那些年搞不懂的术语、概念：协变、逆变、不变体
body: 
简述什么是协变性、逆变性、不变性

协变性，如：string->object （子类到父类的转换）
逆变性，如：object->string （父类到子类的转换）
不变性，基于上面两种情况，不可变。具体下面再做分析。

泛型委托的可变性
先使用框架定义的泛型委托Func和Action做例子（不了解的请戳）
协变：(string->object)

Func<string> func1 = () => "农码一生";
Func<object> func2 = func1;

逆变：(object->string)

Action<object> func3 = t => { };
Action<string> func4 = func3;

上面代码没有任何问题。
接着我们自己定义委托试试：

我X，看人不来哦。为什么自定义的委托却不能协变呢。
我看看系统定义的Func到底和我们自定义的有什么不同：

public delegate TResult Func<out TResult>();

多了一个out，什么鬼:

out：对于泛型类型参数，out 关键字指定该类型参数是协变的。 可以在泛型接口和委托中使用 out 关键字。（来源）
in：对于泛型类型参数，in 关键字指定该类型参数是逆变的。 可以在泛型接口和委托中使用 in 关键字。（来源）

那么我们可以修改自定义委托：

完美！
那如果我们要实现逆变性呢：

直接逆变是不可行的，我们需要修改泛型类型参数：

我们发现整个委托参数都变了。本来的返回值，改成输入参数才行。
结论：

in->输入参数->可逆变（父类到子类的转变[如 object->string]）
out->返回值->可协变（子类到父类的转变[如 string->object]）

 
假设：如果泛型参数中既存在in又存在out改如何：

delegate Tout MyFunc<in Tin, out Tout>(Tin obj);


MyFunc<object, string> str1 = t => "农码一生";
MyFunc<string, string> str2 = str1;//第一个泛型的逆变（object->string）
MyFunc<object, object> str3 = str1;//第二个泛型的协变（string->object）
MyFunc<string, object> str4 = str1;//第一个泛型的逆变和第二个泛型的协变

以上都是没有问题的。 
然后我们看看编译后的C#代码：

结论：

所谓的逆变其实只是编译后进行了强制类型转换而已。

以上代码也可以直接写成：

//delegate Tout MyFunc<in Tin, out Tout>(Tin obj);
MyFunc<string, string> str5 = t => "农码一生";
MyFunc<object, object> str6 = t => "农码一生";
MyFunc<string, object> str7 = t => "农码一生";

泛型接口的可变性
接着看框架默认接口：
协变：(子类->父类)

IEnumerable<string> list = new List<string>();
IEnumerable<object> list2 = list;

逆变：（父类-> 子类）

IComparable<object> list3 = null;
IComparable<string> list4 = list3;

接下来我们试试自定泛型接口：
首先定义测试类型、接口：

// 人
public class People
{ }
//老师(继承People[人])
public class Teacher : People
{ }
//运动
public interface IMotion<T>
{ }
//跑步
public class Run<T> : IMotion<T>
{ }

然后我们测试协变性：

同样我们需要把接口 interface IMotion<T> 定义为 interface IMotion<out T> 

//运动
public interface IMotion<out T>{}


IMotion<Teacher> x = new Run<Teacher>();
IMotion<People> y = x;

如果我们要测试逆变性，则需要把 interface IMotion<T>  定义为 interface IMotion<in T> 

//运动
public interface IMotion<in T>{}


IMotion<People> x2 = new Run<People>();
IMotion<Teacher> y2 = x2;

泛型接口的逆变，编译后同样进行了强制转换：

当然，我们也可以直接写成：

IMotion<Teacher> y3 = new Run<People>();

不变性
从上面我们知道逆变性的代码编译后都会进行强制转换。假设：那我们不用out、in直接手动强制转换是否可以？：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People { }
//运动
public interface IMotion<T> { }
//跑步
public class Run<T> : IMotion<T> { }


//协变
IMotion<Teacher> x = new Run<Teacher>();
IMotion<People> y = (IMotion<People>)x;

//逆变
IMotion<People> x2 = new Run<People>();
IMotion<Teacher> y2 = (IMotion<Teacher>)x2;
IMotion<Teacher> y3 = (IMotion<Teacher>)new Run<People>();

天才的我发现编译成功了，没有任何问题！且还可以同时协变、逆变？？不对，真的天才了吗？我们运行试试：


看来我还是太单纯了，如果真的这么容易绕过去，Microsoft又何必去搞个out、in关键字。
对于同一个泛型参数，我们既想有协变性又想逆变性，咋办？答案是不可行。这就会出现第三种情况，既不可以协变又不可以逆变。称为不变性。
如（我们在IMotion定义两个方法）：

//运动
public interface IMotion<T>
{
    T Show();
    void Match(T t);
}

上面我们测试过，代码直接强制转换是不能实现协变、逆变的。那么我们只能通过out、in来实现。如果现在我们在泛型参数添加out或in属性会如何？：


我们发现out和in都不能用。在用out时，有个传入参数为泛型 void Match(T t) 的方法。使用in时，有个返回参数为泛型 T Show() 的方法。现在就出现了是矛更锋利，还是盾更坚硬的问题了。
最后结果是：都不能用，既不能协变，也不能逆变。此为不变体。
小知识：
C#4.0之前 IEnumerable<T> 、 IComparable<T> 、 IQueryable<T> 等接口都不支持可变性，在4.0及之后才支持。因为4.0之前定义的泛型接口没有添加out、in关键字，有兴趣可以切换版本看看。
延伸思考
为什么in[输入参数]就只能逆变？分析如下：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People
{
    //薪水
    public decimal Salary { get; set; }
}

//运动
public interface IMotion<in T>
{
    void Match(T t);
}
//跑步
public class Run<T> : IMotion<T>
{
    public void Match(T t)
    {
        //假设中间有很多逻辑.....       
    }
}


为什么out[返回值]只能协变？分析如下：

// 人
public class People { }
//老师(继承People[人])
public class Teacher : People
{
    //薪水
    public decimal Salary { get; set; }
}

//运动
public interface IMotion<out T>
{
    T Show();
    //void Match(T t);
}
//跑步
public class Run<T> : IMotion<T>
{
    public T Show()
    {
        return default(T);
    }
    //public void Match(T t)
    //{
    //    //假设中间有很多逻辑.....         
    //}
}


这里有两个关键点：

传入参数（in）是把参数当成父类来用，显然可以逆变（子类当成父类来用[里氏替换原则]），但是却不可以把父类当子类来用（如：子类存在有而父类没有的方法或属性）。
返回值（out）返回值类型用父类来接收，显然可以协变（父类可以接收一切子类），但却不可用子类接收父类数据（如：父类代表的对象不能强制转给子类[string str = (string)objcet]）。

。。。是不是有点越想越头晕，想不明白就慢慢想。自己动动手。
如果实在想的头大，就把它当成是乌龟的屁股（龟腚\规定）吧，知道是C#做的一种安全限制！
总结
关于泛型接口、泛型委托的可变性：

协变 -> 比较和谐正常的变化 -> 子类转父类 [如 string转object] -> 必须有out标识 [返回值]
逆变 -> 逆天的变化 -> 父类转子类 [如object转string] -> 必须有in标识 [传入参数]  （父亲变儿子，越活越年轻，还不够逆天吗？）
所谓的逆变，会在编译后的C#代码中进行强制类型转换。
示例：


IEnumerable<string> list = new List<string>();  IEnumerable<object> list2 = list; //协变IEnumerable<object> list2 = new List<string>();  //(也可以直接写成这样)


IComparable<object> list3 = null;IComparable<string> list4 = list3; //逆变  编译后 [ IComparable<string> list4 = (IComparable<string>) list3;]



注意：

不支持类的类型参数的可变性
只有泛型接口和泛型委托可以拥有可变的类型参数（out、in）
可变性只支持引用转换。（不能用于值类型）
类型参数使用了 out 或者 ref 将禁止可变性

 
好了，今天就到这里。没啥高深的技术知识，主要为理解协变、逆变、不变体等术语和概念。
本文已同步至索引目录：《C#基础知识巩固》
 
同类文章推荐：
http://www.cnblogs.com/haoyifei/p/5760959.html
http://www.cnblogs.com/LoveJenny/archive/2012/03/13/2392747.html
http://www.cnblogs.com/Ninputer/archive/2008/11/22/generic_covariant.html
 
article  19
title: 农码一生博文索引
body: 
《.NET Core》

ASP.NET Core 快速入门【第一弹-环境篇】
ASP.NET Core 快速入门【第二弹-实战篇】

《Linux学习》

Linux学习(1)-常用快捷键、文件管理和查询

《C#基础知识巩固》

特性是什么东东
什么是反射、反射可以做些什么
依赖注入是什么
可空类型Nullable<T>到底是什么鬼
谈扩展方法的理解
你必须知道的EF知识和经验【推荐】
你知道C#中的Lambda表达式的演化过程吗 
Linq表达式、Lambda表达式你更喜欢哪个 
先说IEnumerable，我们每天用的foreach你真的懂它吗【推荐】
再讲IQueryable<T>，揭开表达式树的神秘面纱【推荐】
那些年搞不懂的术语、概念：协变、逆变、不可变
C#异步的世界【上】
C#异步的世界【下】【推荐】
C#单元测试，带你快速入门
权限管理学习 一、ASP.NET Forms身份认证
文件下载之断点续传（客户端与服务端的实现）
文件各种上传，离不开的表单

 
《一步步学习javascript基础篇》


一步步学习javascript基础篇（1）：基本概念


一步步学习javascript基础篇（2）：作用域和作用域链


一步步学习javascript基础篇（3）：Object、Function等引用类型


一步步学习javascript基础篇（4）：面向对象设计之创建对象（工厂、原型和构造函数等模式）


一步步学习javascript基础篇（5）：面向对象设计之对象继承（原型链继承）


一步步学习javascript基础篇（6）：函数表达式之【闭包】


一步步学习javascript基础篇（7）：BOM和DOM


一步步学习javascript基础篇（8）：事件【推荐】


一步步学习javascript基础篇（9）：ajax请求的回退


 
《一步步开发自己的博客 .NET版》

一步步开发自己的博客 .NET版（1、基本显示）
一步步搭建自己的博客 .NET版（2、评论功能）
一步步开发自己的博客 .NET版（3、注册登录功能）
一步步开发自己的博客 .NET版（4、文章发布功能）百度编辑器
一步步开发自己的博客 .NET版（5、Lucenne.Net 和 必应站内搜索）
一步步开发自己的博客 .NET版（6、响应式布局 和 自定义样式）【推荐】
一步步开发自己的博客 番外篇（7、异步记录日志 和 文章阅读量统计）
一步步开发自己的博客 番外篇（8、第三方登录及问题记录）
一步步开发自己的博客 .NET版（9、从model first替换成code first 问题记录）
一步步开发自己的博客 .NET版（10、前端对话框和消息框的实现）
一步步开发自己的博客 .NET版（11、Web.config文件的读取和修改）

 
《设计模式学习》
 

面向对象编程思想(前传)--你必须知道的javascript
面向对象编程思想--单例模式 [创建型]
面向对象编程思想--工厂模式 [创建型]
面向对象编程思想--组合模式 [结构型]
面向对象编程思想--适配器模式 [结构型]
面向对象编程思想--装饰模式 [结构型]
面向对象编程思想--享元模式 [结构型]
面向对象编程思想--代理模式 [结构型]
面向对象编程思想--策略模式 [行为型]
面向对象编程思想--观察者模式 [行为型]
面向对象编程思想--模板方法模式 [行为型]
面向对象编程思想--命令模式 [行为型]
面向对象编程思想--状态模式 [行为型]
面向对象编程思想--责任链模式 [行为型]
面向对象编程思想--中介者模式 [行为型]
面向对象编程思想--迭代器模式 [行为型]


 
《一些没有分类的文章》

我们为什么要坚持写博客【推荐】
各大招聘网站信息实时查询浏览
各大招聘网站信息实时查询浏览【二】

 
《推荐书单》

深入理解C#
大话设计模式
.net之美
你必须知道的.net
JavaScript高级程序设计
JavaScript设计模式与开发实践

 
article  20
title: UML类图学习
body: 

下载Visio 地址

下载完毕，自行安装。至于破解，生在天朝的你必有的技能。
右键，新建 Microsoft Visio 绘图（我安装的是2013）
双击打开


现在我们就可以使用UML类图了。

最常用也就这几种了。
斜体【抽象类】
+公有（pubic）-私有（private）
《》【接口】
虚线空间三级【实现接口】
虚线箭头【依赖关系】
实线空心三角箭头【继承关系】

还有一些

其实很简单，Visio上都有明确的提示。画几次就熟悉了。
 

另外，vs中可以自动为已有的类创建UML类图。



效果还不错。
可能有人会说，vs17的查看类图取消了。
no，这么好的功能怎么会取消呢。那是因为你安装的时候没有安装这个组件。

怪不得17的安装速度要比之前的vs快那么多，好多东西都没有默认安装了。


article  21
title: 再讲IQueryable<T>，揭开表达式树的神秘面纱
body: 
接上篇《先说IEnumerable，我们每天用的foreach你真的懂它吗？》
最近园子里定制自己的orm那是一个风生水起，感觉不整个自己的orm都不好意思继续混博客园了（开个玩笑）。那么在此之前我们有必要仔细了解下 IQueryable<T> ，于是就有了此文。
什么是树？
什么是树？这个问题好像有点白痴。树不就是树嘛。看图：

我们从最下面的主干开始往上看，主枝-分支-分支....可以说是无限分支下去。我们倒过来看就是这样：

平时我们用得最多的树结构数据就是XML了，节点下面可以无限添加子节点。我们想想平时还用过什么树结构数据，比如：菜单无限分级、评论区的楼层。
这和我们今天讲的有毛关系啊。... 我们今天主要就是来分析表达式树的。、
lambda表达式和表达式树的区别：
Lambda表达式：

Func<Student, bool> func = t => t.Name == "农码一生";

表达式树： 

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生"; 

 咋一看，没啥区别啊。表达式只是用Expression包了一下而已。那你错了，这只是Microsoft给我们展示的障眼法，我们看编译后的C#代码：

第一个lambda表达式编译成了匿名函数，第二个表达式树编译成一了一堆我们不认识的东西，远比我们原来写的lambda复杂得多。
结论：

我们平时使用的表达式树，是编写的lambda表达式然后编译成的表达式树，也就是说平时一般情况使用的表达式树都是编译器帮我们完成的。（当然，我们可以可以手动的主动的去创表达式树。只是太麻烦，不是必要情况没有谁愿意去干这个苦活呢）

我们来看看表达式树到底有什么神奇的地方：

有没有看出点感觉来？Body里面有Right、Left，Right里面又有Right、Left，它们的类型都是继承自 Expression 。这种节点下面有节点，可以无限附加下去的数据结构我们称为树结构数据。也就是我们的表达式树。
补：上面的 Student 实体类：


public class Student
{
    public string Name { get; set; }

    public int Age { get; set; }

    public string Address { get; set; }

    public string Sex { get; set; }
}

View Code
解析表达式树
上面我们看到了所谓的表达式树，其他也没有想象的那么复杂嘛。不就是一个树结构数据嘛。如果我们要实现自己的orm，免不了要解析表达式树。一般说到解析树结构数据都会用到递归算法。下面我们开始解析表达式树。
先定义解析方法：

//表达式解析
public static class AnalysisExpression
{
    public static void VisitExpression(Expression expression)
    {
        switch (expression.NodeType)
        {
            case ExpressionType.Call://执行方法
                MethodCallExpression method = expression as MethodCallExpression;
                Console.WriteLine("方法名:" + method.Method.Name);
                for (int i = 0; i < method.Arguments.Count; i++)
                    VisitExpression(method.Arguments[i]);
                break;
            case ExpressionType.Lambda://lambda表达式
                LambdaExpression lambda = expression as LambdaExpression;
                VisitExpression(lambda.Body);
                break;
            case ExpressionType.Equal://相等比较
            case ExpressionType.AndAlso://and条件运算
                BinaryExpression binary = expression as BinaryExpression;
                Console.WriteLine("运算符:" + expression.NodeType.ToString());
                VisitExpression(binary.Left);
                VisitExpression(binary.Right);
                break;
            case ExpressionType.Constant://常量值
                ConstantExpression constant = expression as ConstantExpression;
                Console.WriteLine("常量值:" + constant.Value.ToString());
                break;
            case ExpressionType.MemberAccess:
                MemberExpression Member = expression as MemberExpression;
                Console.WriteLine("字段名称:{0}，类型:{1}", Member.Member.Name, Member.Type.ToString());
                break;
            default:
                Console.Write("UnKnow");
                break;
        }
    }

}

调用解析方法：

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生" && t.Sex == "男";
AnalysisExpression.VisitExpression(expression);

我们来看看执行过程：

一层一层的往子节点递归，直到遍历完所有的节点。最后打印效果如下：

基本上我们想要的元素和值都取到了，接着怎么组装就看你自己的心情了。是拼成sql，还是生成url，请随意！
实现自己的IQueryable<T>、IQueryProvider
仅仅解析了表达式树就可以捣鼓自己的orm了？不行，起码也要基于 IQueryable<T> 接口来编码吧。
接着我们自定义个类 MyQueryable<T> 继承接口 IQueryable<T> ：

 public class MyQueryable<T> : IQueryable<T>
 {
     public IEnumerator<T> GetEnumerator()
     {
         throw new NotImplementedException();
     }
     IEnumerator IEnumerable.GetEnumerator()
     {
         throw new NotImplementedException();
     }
     public Type ElementType
     {
         get { throw new NotImplementedException(); }
     }
     public Expression Expression
     {
         get { throw new NotImplementedException(); }
     }
     public IQueryProvider Provider
     {
         get { throw new NotImplementedException(); }
     }
 }

我们看到其中有个接口属性 IQueryProvider ，这个接口的作用大着呢，主要作用是在执行查询操作符的时候重新创建 IQueryable<T> 并且最后遍历的时候执行sql远程取值。我们还看见了 Expression  属性。
现在我们明白了 IQueryable<T> 和 Expression （表达式树）的关系了吧：

 IQueryable<T> 最主要的作用就是用来存储 Expression（表达式树）

下面我们也自定义现实了 IQueryProvider 接口的类 MyQueryProvider ：

public class MyQueryProvider : IQueryProvider
{
    public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
    {
        throw new NotImplementedException();
    }
    public IQueryable CreateQuery(Expression expression)
    {
        throw new NotImplementedException();
    }
    public TResult Execute<TResult>(Expression expression)
    {
        throw new NotImplementedException();
    }
    public object Execute(Expression expression)
    {
        throw new NotImplementedException();
    }
}

上面全是自动生成的伪代码，下面我们来填充具体的实现：


    public class MyQueryProvider : IQueryProvider
    {
        public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
        {
            return new MyQueryable<TElement>(expression);
        }

        public IQueryable CreateQuery(Expression expression)
        {
            throw new NotImplementedException();
        }

        public TResult Execute<TResult>(Expression expression)
        {
            return default(TResult);
        }

        public object Execute(Expression expression)
        {
            return new List<object>();
        } 
    }  
    public class MyQueryable<T> : IQueryable<T>
    {
        public MyQueryable()
        {
            _provider = new MyQueryProvider();
            _expression = Expression.Constant(this);
        }

        public MyQueryable(Expression expression)
        {
            _provider = new MyQueryProvider();
            _expression = expression;
        }
        public Type ElementType
        {
            get { return typeof(T); }
        }

        private Expression _expression;
        public Expression Expression
        {
            get { return _expression; }
        }

        private IQueryProvider _provider;
        public IQueryProvider Provider
        {
            get { return _provider; }
        }

        public IEnumerator GetEnumerator()
        {
            return (Provider.Execute(Expression) as IEnumerable).GetEnumerator();
        }

        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            var result = _provider.Execute<List<T>>(_expression);
            if (result == null)
                yield break;
            foreach (var item in result)
            {
                yield return item;
            }
        }
    }

View Code
执行代码：

 var aa = new MyQueryable<Student>();
 var bb = aa.Where(t => t.Name == "农码一生");
 var cc = bb.Where(t => t.Sex == "男");
 var dd = cc.AsEnumerable();
 var ee = cc.ToList(); 

接着我们看看执行过程：

结论：

每次在执行 Where 查询操作符的时候 IQueryProvider 会为我们创建一个新的 IQueryable<T> 
调用 AsEnumerable() 方法的时候并不会去实际取值（只是得到一个IEnumerable）[注意：在EF里面查询不要先取IEnumerable后滤筛，因为AsEnumerable()会生成查询全表的sql]
执行 ToList() 方法时才去真正调用迭代器 GetEnumerator() 取值
真正取值的时候，会去执行 IQueryProvider 中的 Execute 方法。（就是在调用这个方法的时候解析表达式数，然后执行取得结果）

我们看到真正应该办实事的 Execute  我们却让他返回默认值了。

现在估计有人不爽了，你到是具体实现下 Execute 。好吧！（其实通过上面说的解析表达式树，你可以自己在这里做想做的任何事了。）
首先为了简单起见，我们用一个集合做为数据源：

//构造Student数组
public static List<Student> StudentArrary = new List<Student>()
{
        new Student(){Name="农码一生", Age=26, Sex="男", Address="长沙"},
        new Student(){Name="小明", Age=23, Sex="男", Address="岳阳"},
        new Student(){Name="嗨-妹子", Age=25, Sex="女", Address="四川"}
};

然后，重新写一个VisitExpression2方法：（和之前的区别： 现在目的是取表达式树中的表达式，而不是重新组装成sql或别的）

public static void VisitExpression2(Expression expression, ref List<LambdaExpression> lambdaOut)
{
    if (lambdaOut == null)
        lambdaOut = new List<LambdaExpression>();
    switch (expression.NodeType)
    {
        case ExpressionType.Call://执行方法
            MethodCallExpression method = expression as MethodCallExpression;
            Console.WriteLine("方法名:" + method.Method.Name);
            for (int i = 0; i < method.Arguments.Count; i++)
                VisitExpression2(method.Arguments[i], ref  lambdaOut);
            break;
        case ExpressionType.Lambda://lambda表达式
            LambdaExpression lambda = expression as LambdaExpression;
            lambdaOut.Add(lambda);
            VisitExpression2(lambda.Body, ref  lambdaOut);
            break;
        case ExpressionType.Equal://相等比较
        case ExpressionType.AndAlso://and条件运算
            BinaryExpression binary = expression as BinaryExpression;
            Console.WriteLine("运算符:" + expression.NodeType.ToString());
            VisitExpression2(binary.Left, ref  lambdaOut);
            VisitExpression2(binary.Right, ref  lambdaOut);
            break;
        case ExpressionType.Constant://常量值
            ConstantExpression constant = expression as ConstantExpression;
            Console.WriteLine("常量值:" + constant.Value.ToString());
            break;
        case ExpressionType.MemberAccess:
            MemberExpression Member = expression as MemberExpression;
            Console.WriteLine("字段名称:{0}，类型:{1}", Member.Member.Name, Member.Type.ToString());
            break;
        case ExpressionType.Quote:
            UnaryExpression Unary = expression as UnaryExpression;
            VisitExpression2(Unary.Operand, ref  lambdaOut);
            break;
        default:
            Console.Write("UnKnow");
            break;
    }
}

然后重新实现方法 Execute ：

public TResult Execute<TResult>(Expression expression)
{
    List<LambdaExpression> lambda = null;
    AnalysisExpression.VisitExpression2(expression, ref lambda);//解析取得表达式数中的表达式
    IEnumerable<Student> enumerable = null;
    for (int i = 0; i < lambda.Count; i++)
    {
        //把LambdaExpression转成Expression<Func<Student, bool>>类型
        //通过方法Compile()转成委托方法
        Func<Student, bool> func = (lambda[i] as Expression<Func<Student, bool>>).Compile(); 
        if (enumerable == null)
            enumerable = Program.StudentArrary.Where(func);//取得IEnumerable
        else
            enumerable = enumerable.Where(func);
    }
    dynamic obj = enumerable.ToList();//（注意：这个方法的整个处理过程，你可以换成解析sql执行数据库查询，或者生成url然后请求获取数据。）
    return (TResult)obj;
}

执行过程：

个人对 IQueryable 延迟加载的理解：

前段部分的查询操作符只是把逻辑分解存入表达式树，并没有远程执行sql。
foreache执行的是 IEnumerable<T> ，然而 IEnumerable<T> 同样具有延迟加载的特性。每次迭代的时候才真正的取数据。且在使用导航属性的时候会再次查询数据库。(下次说延迟加载不要忘记了 IEnumerable 的功劳哦！)

小知识：
表达式树转成Lambda表达式：

Expression<Func<Student, bool>> expression = t => t.Name == "农码一生";
Func<Student, bool> func = expression.Compile();

总结：
表达式树的分析就告一段落了，其中还有很多细节或重要的没有分析到。下次有新的心得再来总结。
感觉表达式树就是先把表达式打散存在树结构里（一般打散的过程是编译器完成），然后可以根据不同的数据源或接口重新组装成自己想要的任何形式，这也让我们实现自己的orm成为了可能。
今天主要是对表达式树的解析、和实现自己的IQueryable<T>、IQueryProvider做了一个记录和总结，其中不定有错误的结论或说法，轻点拍！
demo下载：http://pan.baidu.com/s/1nvAksgL 
本文以同步至索引目录：《C#基础知识巩固》
 
推荐阅读：
http://www.cnblogs.com/jesse2013/p/expressiontree-part1.html
http://www.cnblogs.com/jesse2013/p/expressiontree-part2.html
http://www.cnblogs.com/jesse2013/p/expressiontree-Linq-to-cnblogs.html
园友@风口上的猪推荐：
http://www.cnblogs.com/Ninputer/archive/2009/09/08/expression_tree3.htmlhttp://blog.zhaojie.me/2009/03/expression-cache-1.html
 
article  22
title: C#异步的世界【上】
body: 
新进阶的程序员可能对async、await用得比较多，却对之前的异步了解甚少。本人就是此类，因此打算回顾学习下异步的进化史。 
本文主要是回顾async异步模式之前的异步，下篇文章再来重点分析async异步模式。
APM
APM 异步编程模型，Asynchronous Programming Model
早在C#1的时候就有了APM。虽然不是很熟悉，但是多少还是见过的。就是那些类是BeginXXX和EndXXX的方法，且BeginXXX返回值是IAsyncResult接口。
在正式写APM示例之前我们先给出一段同步代码：

//1、同步方法
private void button1_Click(object sender, EventArgs e)
{          
    Debug.WriteLine("【Debug】线程ID:" + Thread.CurrentThread.ManagedThreadId);

    var request = WebRequest.Create("https://github.com/");//为了更好的演示效果，我们使用网速比较慢的外网
    request.GetResponse();//发送请求    

    Debug.WriteLine("【Debug】线程ID:" + Thread.CurrentThread.ManagedThreadId);
    label1.Text = "执行完毕！";
}

【说明】为了更好的演示异步效果，这里我们使用winform程序来做示例。（因为winform始终都需要UI线程渲染界面，如果被UI线程占用则会出现“假死”状态）
【效果图】

看图得知：

我们在执行方法的时候页面出现了“假死”，拖不动了。
我们看到打印结果，方法调用前和调用后线程ID都是9（也就是同一个线程）

下面我们再来演示对应的异步方法：（BeginGetResponse、EndGetResponse所谓的APM异步模型）

private void button2_Click(object sender, EventArgs e)
{
    //1、APM 异步编程模型，Asynchronous Programming Model
    //C#1[基于IAsyncResult接口实现BeginXXX和EndXXX的方法]             
    Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);

    var request = WebRequest.Create("https://github.com/");
    request.BeginGetResponse(new AsyncCallback(t =>//执行完成后的回调
    {
        var response = request.EndGetResponse(t);
        var stream = response.GetResponseStream();//获取返回数据流 

        using (StreamReader reader = new StreamReader(stream))
        {
            StringBuilder sb = new StringBuilder();
            while (!reader.EndOfStream)
            {
                var content = reader.ReadLine();
                sb.Append(content);
            }
            Debug.WriteLine("【Debug】" + sb.ToString().Trim().Substring(0, 100) + "...");//只取返回内容的前100个字符 
            Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            label1.Invoke((Action)(() => { label1.Text = "执行完毕！"; }));//这里跨线程访问UI需要做处理
        }
    }), null);

    Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId); 
}

【效果图】
 
看图得知：

启用异步方法并没有是UI界面卡死
异步方法启动了另外一个ID为12的线程

上面代码执行顺序：

前面我们说过，APM的BebinXXX必须返回IAsyncResult接口。那么接下来我们分析IAsyncResult接口：
首先我们看：

确实返回的是IAsyncResult接口。那IAsyncResult到底长的什么样子？：

并没有想象中的那么复杂嘛。我们是否可以尝试这实现这个接口，然后显示自己的异步方法呢？
首先定一个类MyWebRequest，然后继承IAsyncResult：（下面是基本的伪代码实现）

public class MyWebRequest : IAsyncResult
{
    public object AsyncState
    {
        get { throw new NotImplementedException(); }
    }

    public WaitHandle AsyncWaitHandle
    {
        get { throw new NotImplementedException(); }
    }

    public bool CompletedSynchronously
    {
        get { throw new NotImplementedException(); }
    }

    public bool IsCompleted
    {
        get { throw new NotImplementedException(); }
    }
}

这样肯定是不能用的，起码也得有个存回调函数的属性吧，下面我们稍微改造下：

然后我们可以自定义APM异步模型了：（成对的Begin、End）

public IAsyncResult MyBeginXX(AsyncCallback callback)
{
    var asyncResult = new MyWebRequest(callback, null);
    var request = WebRequest.Create("https://github.com/");
    new Thread(() =>  //重新启用一个线程
    {
        using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream()))
        {
            var str = sr.ReadToEnd();
            asyncResult.SetComplete(str);//设置异步结果
        }

    }).Start();
    return asyncResult;//返回一个IAsyncResult
}

public string MyEndXX(IAsyncResult asyncResult)
{
    MyWebRequest result = asyncResult as MyWebRequest;
    return result.Result;
}

调用如下:

 private void button4_Click(object sender, EventArgs e)
 {
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
     MyBeginXX(new AsyncCallback(t =>
     {
         var result = MyEndXX(t);
         Debug.WriteLine("【Debug】" + result.Trim().Substring(0, 100) + "...");
         Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
     }));
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
 }

效果图：

我们看到自己实现的效果基本上和系统提供的差不多。

启用异步方法并没有是UI界面卡死
异步方法启动了另外一个ID为11的线程

【总结】
个人觉得APM异步模式就是启用另外一个线程执行耗时任务，然后通过回调函数执行后续操作。
APM还可以通过其他方式获取值，如：

while (!asyncResult.IsCompleted)//循环，直到异步执行完成 (轮询方式)
{
    Thread.Sleep(100);
}
var stream2 = request.EndGetResponse(asyncResult).GetResponseStream();

或

asyncResult.AsyncWaitHandle.WaitOne();//阻止线程，直到异步完成 （阻塞等待）
var stream2 = request.EndGetResponse(asyncResult).GetResponseStream();

 
补充：如果是普通方法，我们也可以通过委托异步：（BeginInvoke、EndInvoke）

 public void MyAction()
 {
     var func = new Func<string, string>(t =>
     {
         Thread.Sleep(2000);
         return "name:" + t + DateTime.Now.ToString();
     });
 
     var asyncResult = func.BeginInvoke("张三", t =>
     {
         string str = func.EndInvoke(t);
         Debug.WriteLine(str);
     }, null); 
 }

EAP
EAP 基于事件的异步模式，Event-based Asynchronous Pattern
此模式在C#2的时候随之而来。
先来看个EAP的例子：

 private void button3_Click(object sender, EventArgs e)
 {            
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);

     BackgroundWorker worker = new BackgroundWorker();
     worker.DoWork += new DoWorkEventHandler((s1, s2) =>
     {
         Thread.Sleep(2000);
         Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
     });//注册事件来实现异步
     worker.RunWorkerAsync(this);
     Debug.WriteLine("【Debug】主线程ID:" + Thread.CurrentThread.ManagedThreadId);
 }

 
【效果图】（同样不会阻塞UI界面）

【特征】

通过事件的方式注册回调函数
通过 XXXAsync方法来执行异步调用

例子很简单，但是和APM模式相比，是不是没有那么清晰透明。为什么可以这样实现？事件的注册是在干嘛？为什么执行RunWorkerAsync会触发注册的函数？
感觉自己又想多了...
我们试着反编译看看源码：

 只想说，这么玩，有意思吗？
TAP
TAP 基于任务的异步模式，Task-based Asynchronous Pattern
到目前为止，我们觉得上面的APM、EAP异步模式好用吗？好像没有发现什么问题。再仔细想想...如果我们有多个异步方法需要按先后顺序执行，并且需要(在主进程)得到所有返回值。
首先定义三个委托：

public Func<string, string> func1()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "name:" + t;
    });
}
public Func<string, string> func2()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "age:" + t;
    });
}
public Func<string, string> func3()
{
    return new Func<string, string>(t =>
    {
        Thread.Sleep(2000);
        return "sex:" + t;
    });
}

然后按照一定顺序执行：

public void MyAction()
{
    string str1 = string.Empty, str2 = string.Empty, str3 = string.Empty;
    IAsyncResult asyncResult1 = null, asyncResult2 = null, asyncResult3 = null;
    asyncResult1 = func1().BeginInvoke("张三", t =>
    {
        str1 = func1().EndInvoke(t);
        Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
        asyncResult2 = func2().BeginInvoke("26", a =>
        {
            str2 = func2().EndInvoke(a);
            Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            asyncResult3 = func3().BeginInvoke("男", s =>
            {
                str3 = func3().EndInvoke(s);
                Debug.WriteLine("【Debug】异步线程ID:" + Thread.CurrentThread.ManagedThreadId);
            }, null);
        }, null);
    }, null);

    asyncResult1.AsyncWaitHandle.WaitOne();
    asyncResult2.AsyncWaitHandle.WaitOne();
    asyncResult3.AsyncWaitHandle.WaitOne();
    Debug.WriteLine(str1 + str2 + str3);
} 

除了难看、难读一点好像也没什么 。不过真的是这样吗？

asyncResult2是null?由此可见在完成第一个异步操作之前没有对asyncResult2进行赋值，asyncResult2执行异步等待的时候报异常。那么如此我们就无法控制三个异步函数，按照一定顺序执行完成后再拿到返回值。（理论上还是有其他办法的，只是会然代码更加复杂）
 
是的，现在该我们的TAP登场了。

只需要调用Task类的静态方法Run，即可轻轻松松使用异步。
获取返回值：

var task1 = Task<string>.Run(() =>
{
    Thread.Sleep(1500);
    Console.WriteLine("【Debug】task1 线程ID:" + Thread.CurrentThread.ManagedThreadId);
    return "张三";
});
//其他逻辑            
task1.Wait();
var value = task1.Result;//获取返回值
Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);

现在我们处理上面多个异步按序执行：

Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);
string str1 = string.Empty, str2 = string.Empty, str3 = string.Empty;
var task1 = Task.Run(() =>
{
    Thread.Sleep(500);
    str1 = "姓名：张三,";
    Console.WriteLine("【Debug】task1 线程ID:" + Thread.CurrentThread.ManagedThreadId);
}).ContinueWith(t =>
{
    Thread.Sleep(500);
    str2 = "年龄：25,";
    Console.WriteLine("【Debug】task2 线程ID:" + Thread.CurrentThread.ManagedThreadId);
}).ContinueWith(t =>
{
    Thread.Sleep(500);
    str3 = "爱好：妹子";
    Console.WriteLine("【Debug】task3 线程ID:" + Thread.CurrentThread.ManagedThreadId);
});

Thread.Sleep(2500);//其他逻辑代码

task1.Wait();

Debug.WriteLine(str1 + str2 + str3);
Console.WriteLine("【Debug】主 线程ID:" + Thread.CurrentThread.ManagedThreadId);

[效果图]

我们看到，结果都得到了，且是异步按序执行的。且代码的逻辑思路非常清晰。如果你感受还不是很大，那么你现象如果是100个异步方法需要异步按序执行呢？用APM的异步回调，那至少也得异步回调嵌套100次。那代码的复杂度可想而知。
 
延伸思考


WaitOne完成等待的原理


异步为什么会提升性能


线程的使用数量和CPU的使用率有必然的联系吗


 
问题1：WaitOne完成等待的原理
在此之前，我们先来简单的了解下多线程信号控制AutoResetEvent类。

var _asyncWaitHandle = new AutoResetEvent(false);
_asyncWaitHandle.WaitOne();

此代码会在 WaitOne 的地方会一直等待下去。除非有另外一个线程执行 AutoResetEvent 的set方法。

var _asyncWaitHandle = new AutoResetEvent(false);
_asyncWaitHandle.Set();
_asyncWaitHandle.WaitOne();

如此，到了 WaitOne 就可以直接执行下去。没有有任何等待。
现在我们对APM 异步编程模型中的 WaitOne 等待是不是知道了点什么呢。我们回头来实现之前自定义异步方法的异步等待。

public class MyWebRequest : IAsyncResult
{
    //异步回调函数（委托）
    private AsyncCallback _asyncCallback;
    private AutoResetEvent _asyncWaitHandle;
    public MyWebRequest(AsyncCallback asyncCallback, object state)
    {
        _asyncCallback = asyncCallback;
        _asyncWaitHandle = new AutoResetEvent(false);
    }
    //设置结果
    public void SetComplete(string result)
    {
        Result = result;
        IsCompleted = true;
        _asyncWaitHandle.Set();
        if (_asyncCallback != null)
        {
            _asyncCallback(this);
        }
    }
    //异步请求返回值
    public string Result { get; set; }
    //获取用户定义的对象，它限定或包含关于异步操作的信息。
    public object AsyncState
    {
        get { throw new NotImplementedException(); }
    }
    // 获取用于等待异步操作完成的 System.Threading.WaitHandle。
    public WaitHandle AsyncWaitHandle
    {
        //get { throw new NotImplementedException(); }

        get { return _asyncWaitHandle; }
    }
    //获取一个值，该值指示异步操作是否同步完成。
    public bool CompletedSynchronously
    {
        get { throw new NotImplementedException(); }
    }
    //获取一个值，该值指示异步操作是否已完成。
    public bool IsCompleted
    {
        get;
        private set;
    }
}

红色代码就是新增的异步等待。
【执行步骤】

 
问题2：异步为什么会提升性能
比如同步代码：

Thread.Sleep(10000);//假设这是个访问数据库的方法
Thread.Sleep(10000);//假设这是个访问FQ网站的方法

这个代码需要20秒。
如果是异步：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
});
Thread.Sleep(10000);//假设这是个访问FQ网站的方法
task.Wait();

如此就只要10秒了。这样就节约了10秒。
如果是：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
}); 
task.Wait();

异步执行中间没有耗时的代码那么这样的异步将是没有意思的。
或者：

var task = Task.Run(() =>
{
    Thread.Sleep(10000);//假设这是个访问数据库的方法
}); 
task.Wait();
Thread.Sleep(10000);//假设这是个访问FQ网站的方法

把耗时任务放在异步等待后，那这样的代码也是不会有性能提升的。
还有一种情况：
如果是单核CPU进行高密集运算操作，那么异步也是没有意义的。(因为运算是非常耗CPU,而网络请求等待不耗CPU)
 
问题3：线程的使用数量和CPU的使用率有必然的联系吗
答案是否。
还是拿单核做假设。
情况1：

long num = 0;
while (true)
{
    num += new Random().Next(-100,100);
    //Thread.Sleep(100);
}

单核下，我们只启动一个线程，就可以让你CPU爆满。

启动八次，八进程CPU基本爆满。
情况2：


一千多个线程，而CPU的使用率竟然是0。由此，我们得到了之前的结论，线程的使用数量和CPU的使用率没有必然的联系。
虽然如此，但是也不能毫无节制的开启线程。因为：

开启一个新的线程的过程是比较耗资源的。（可是使用线程池，来降低开启新线程所消耗的资源）
多线程的切换也是需要时间的。
每个线程占用了一定的内存保存线程上下文信息。

 
demo：http://pan.baidu.com/s/1slOxgnF
本文已同步至索引目录：《C#基础知识巩固》
对于异步编程了解不深，文中极有可能多处错误描述和观点。
感谢广大园友的指正。
本着相互讨论的目的，绝无想要误导大家的意思。
 
【推荐】
http://www.cnblogs.com/wisdomqq/archive/2012/03/26/2412349.html
article  23
title: 五、谈扩展方法的理解
body: 
为什么要用扩展方法
在说什么是扩展方法之前我们先来说说为什么要用扩展方法。
首先我们定义一个 Person 类：

public class Person
{
    /// <summary>
    /// 出生日期
    /// </summary>
    public DateTime BirthTime { get; set; }
    /// <summary>
    /// 死亡日期
    /// </summary>
    public DateTime? DeathTime { get; set; }
    //、、、、、、
}

加入这个类来自第三方的dll引用，且现在我们需要添加一个方法 GetAge 获取年龄。你可能会想到自己定一个子类继承：

public class MyPerson : Person
{
    public int GetAge()
    {
        if (DeathTime.HasValue)
            return (DeathTime.Value - BirthTime).Days / 365;
        else
            return (DateTime.Now - BirthTime).Days / 365;
    }
}

是的，这样可以实现我们的需求。不过实现新增的方法就去继承真的是最合适的吗（暂且不说）？ 如果上面定义的密封类呢？ public sealed class Person ，这个时候是不能继承的，我们只能另想办法。
随意写个静态类：

public static class ExtensionClass
{
    public static int GetAge(Person person)
    {
        if (person.DeathTime.HasValue)
            return (person.DeathTime.Value - person.BirthTime).Days / 365;
        else
            return (DateTime.Now - person.BirthTime).Days / 365;
    }

然后调用  age = ExtensionClass.GetAge(p); ，是的看似不错。可是这和我们说的扩展方法有什么关系呢？下面就是见证奇迹的时候了。

其他的任何地方都不变，唯一变化的是在参数前面加里this关键字。对，是的，仅仅如此它就变成了我们今天要讲的扩展方法。
调用如：  var age = p.GetAge(); 相比上面的 age = ExtensionClass.GetAge(p); 更简单明了。
这里我们说的是在需要扩展密封类的方法时，我们可以使用到扩展方法。还有一种情况就是，在需要扩展接口的时候时候我们更加需要。比如，需要扩展IList的排序。我们要么写个扩展方法，要么是继承实现接口（会强制要求实现接口下的所有方法）。我想你心中已经有了答案选择哪种方式。
扩展方法到底是什么
我们看到上面使用的扩展方法，有没有感觉很神奇。仅仅多添加了一个this关键字就直接可以当成扩展方法使用了。那扩展方法到底是什么东东，看了上面代码好像和静态方法有着说不清道不明的关系。下面我们继续分析：
分别定义一个静态方法和一个扩展方法

 public static class ExtensionClass
 {
     public static int GetAge2(Person person)
     {
         if (person.DeathTime.HasValue)
             return (person.DeathTime.Value - person.BirthTime).Days / 365;
         else
             return (DateTime.Now - person.BirthTime).Days / 365;
     }

     public static int GetAge(this Person person)
     {
         if (person.DeathTime.HasValue)
             return (person.DeathTime.Value - person.BirthTime).Days / 365;
         else
             return (DateTime.Now - person.BirthTime).Days / 365;
     }

分别调用：

var p = new Person() { BirthTime = DateTime.Parse("1990-07-19") };
var age = p.GetAge();
age = ExtensionClass.GetAge2(p);

编译后的IL代码：

我们看到反编译成IL之后发现两者并无不同。所以，我理解成（扩展方法本质上就是静态方法，之所以出现扩展方法是C#以另外一种形式表现静态方法而已。只有有何妙用下面会继续讲解）。且 编译后同样带上了静态类名。
扩展方法可以做些什么

把已有的静态方法转成扩展方法：如：


public static bool IsNullOrEmpty(this string str)
{
    return string.IsNullOrEmpty(str);
}

调用： 

string str = null;
var isNull = str.IsNullOrEmpty();

 感觉相比期静态方法调用要优雅，更接近我们的自然语言。

 可以编写很多的帮助类，如（以string为例）：



/// <summary>
        /// 转DateTime 
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static DateTime? MyToDateTime(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return null;
            else
                return DateTime.Parse(str);
        }

        /// <summary>
        /// 转double
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static double MyToDouble(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return -1;
            else
                return double.Parse(str);
        }

        /// <summary>
        /// 转int
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static int MyToInt(this string str)
        {
            if (string.IsNullOrEmpty(str))
                return -1;
            else
                return int.Parse(str);
        }

        /// <summary>
        /// 指示指定的字符串是 null 还是 System.String.Empty 字符串。
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static bool IsNullOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str);
        }

        /// <summary>
        /// 如果字符串为null，则返回空字符串。（否则返回原字符串）
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static string GetValueOrEmpty(this string str)
        {
            if (str.IsNullOrEmpty())
                return string.Empty;
            return str;
        }

View Code
上面所有的都只是扩展方法的附加用处，扩展方法真正的威力是为Linq服务的（主要体现于IEnumerable和IQueryable），实现链式编程。下面我们自己来实现所谓的链式编程：
初始化 Person 集合。

List<Person> persons = new List<Person>() 
{
     new Person(){ BirthTime=DateTime.Parse("1990-01-19")},
     new Person(){ BirthTime=DateTime.Parse("1993-04-17")},
     new Person(){ BirthTime=DateTime.Parse("1992-07-19"), DeathTime=DateTime.Parse("2010-08-18")},
     new Person(){ BirthTime=DateTime.Parse("1990-03-14")},
     new Person(){ BirthTime=DateTime.Parse("1991-08-15")},
     new Person(){ BirthTime=DateTime.Parse("1993-07-29")},
     new Person(){ BirthTime=DateTime.Parse("1991-06-19")}
};

需求：1.查询活人。2.按出生日期排序

public static class ExtensionClass
    {
        /// <summary>
        /// 按条件查询
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyWhere<T>(this IList<T> list, Func<T, bool> func)
        {
            List<T> newList = new List<T>();
            foreach (var item in list)
            {
                if (func(item))
                    newList.Add(item);
            }
            return newList;
        }

        /// <summary>
        /// 升序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderBy<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = i + 1; j < list.Count(); j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks > 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
        /// <summary>
        /// 降序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderByDescending<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = 1; j < list.Count() - i; j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks < 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
    }

调用：（这里仅仅为了演示，所以不要讨论实现是否合理、算法是否高效。）

var newPersons = persons.MyWhere(t => t.DeathTime == null).MyOrderByDescending(t => t.BirthTime);
foreach (var item in newPersons)
{
    Console.WriteLine(item.BirthTime);
}

就是如此简单的实现了所谓的函数式编程。结果图如下：

这样一句代码搞定所有逻辑，像自然语言般的流畅。其实.net为IEnumerable实现了这样的扩展，如：

执行结构和上面一模一样。
 
其实扩展方法也可以当成静态方法来使用：

 var p1 = ExtensionClass.MyWhere(persons, t => t.DeathTime == null);
 var p2 = ExtensionClass.MyOrderByDescending(p1, t => t.BirthTime);
 var p3 = ExtensionClass.MyOrderBy(p2, t => t.BirthTime);

（不信？继续看，有图有真相）
 
C#代码：
 
反编译C#的代码：（你是不是看到了，编译后直接就是使用的扩展方法的形式。）

反编译的IL代码：

虽然编译后的代码是一样的，但是做为程序员的我们更喜欢哪种方式呢？
 
总结：
我们在对扩展方法的怎么使用疑惑或者忘记了规则的时候，我们不用去查找资料说：

第一个参数是要扩展或者要操作的类型,这称为"被扩展的类型"
为了指定扩展方法,要在被扩展的类型名称前面附加this修饰符
要将方法作为一个扩展方法来访问,要用using指令导入扩展类型的命名空间,或者使扩展类型和调用代码在同一个命名空间中.

我们只需记住，当你不知道怎么编写或使用扩展方法时，你先把它当成静态方法编写或使用。如果可行，一般都可以转成扩展方法的形式。
 
全部代码：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;
using System.Data.Entity.Utilities;
using System.Diagnostics.CodeAnalysis;
using NPOI.HSSF.UserModel;
using NPOI.SS.UserModel;
using System.IO;

namespace test
{


    class Program
    {
        static void Main(string[] args)
        {
            /*             
             * 1.工具类
             * 2.链式编程
             */
            string str = null;
            var isNull = str.IsNullOrEmpty();

            var p = new Person() { BirthTime = DateTime.Parse("1990-07-19") };
            var age = p.GetAge();
            age = ExtensionClass.GetAge2(p);

            List<Person> persons = new List<Person>() 
            {
                 new Person(){ BirthTime=DateTime.Parse("1990-01-19")},
                 new Person(){ BirthTime=DateTime.Parse("1993-04-17")},
                 new Person(){ BirthTime=DateTime.Parse("1992-07-19"), DeathTime=DateTime.Parse("2010-08-18")},
                 new Person(){ BirthTime=DateTime.Parse("1990-03-14")},
                 new Person(){ BirthTime=DateTime.Parse("1991-08-15")},
                 new Person(){ BirthTime=DateTime.Parse("1993-07-29")},
                 new Person(){ BirthTime=DateTime.Parse("1991-06-19")}
            };

            var newPersons = persons.MyWhere(t => t.DeathTime == null).MyOrderByDescending(t => t.BirthTime);


            var p1 = ExtensionClass.MyWhere(persons, t => t.DeathTime == null);
            var p2 = ExtensionClass.MyOrderByDescending(p1, t => t.BirthTime);
            var p3 = ExtensionClass.MyOrderBy(p2, t => t.BirthTime);

            foreach (var item in newPersons)
            {
                Console.WriteLine(item.BirthTime);
            }
            Console.ReadKey();
        }
    }

    public sealed class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BirthTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public DateTime? DeathTime { get; set; }
    }

    //public class MyPerson : Person
    //{
    //    public int GetAge()
    //    {
    //        if (DeathTime.HasValue)
    //            return (DeathTime.Value - BirthTime).Days / 365;
    //        else
    //            return (DateTime.Now - BirthTime).Days / 365;
    //    }
    //}
    public static class ExtensionClass
    {
        /// <summary>
        /// 按条件查询
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyWhere<T>(this IList<T> list, Func<T, bool> func)
        {
            List<T> newList = new List<T>();
            foreach (var item in list)
            {
                if (func(item))
                    newList.Add(item);
            }
            return newList;
        }

        /// <summary>
        /// 升序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderBy<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = i + 1; j < list.Count(); j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks > 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }
        /// <summary>
        /// 降序排序
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="list"></param>
        /// <param name="func"></param>
        /// <returns></returns>
        public static IList<T> MyOrderByDescending<T>(this IList<T> list, Func<T, DateTime> func)
        {
            if (list.Count() <= 1)
                return list;

            for (int i = 0; i < list.Count(); i++)
            {
                for (int j = 1; j < list.Count() - i; j++)
                {
                    var item1 = list[j - 1];
                    var item2 = list[j];
                    if ((func(item1) - func(item2)).Ticks < 0)
                    {
                        list[j - 1] = item2;
                        list[j] = item1;
                    }
                }
            }
            return list;
        }

        public static int GetAge2(Person person)
        {
            if (person.DeathTime.HasValue)
                return (person.DeathTime.Value - person.BirthTime).Days / 365;
            else
                return (DateTime.Now - person.BirthTime).Days / 365;
        }

        public static int GetAge(this Person person)
        {
            if (person.DeathTime.HasValue)
                return (person.DeathTime.Value - person.BirthTime).Days / 365;
            else
                return (DateTime.Now - person.BirthTime).Days / 365;
        }

        public static bool IsNullOrEmpty(this string str)
        {
            return string.IsNullOrEmpty(str);
        }
    } 
}

View Code
 
本文以同步至《C#基础知识巩固系列》
article  24
title: 一步步开发自己的博客 .NET版（11、Web.config文件的读取和修改）
body: 
Web.config的读取
对于Web.config的读取大家都很属性了。平时我们用得比较多的就是appSettings节点下配置。如：

我们对应的代码是：

= ConfigurationManager.AppSettings[“OAuth_QQ_ClientId”]; 
= ConfigurationManager.AppSettings[“OAuth_QQ_CallbackUrl”];
= ConfigurationManager.AppSettings[“OAuth_QQ_ClientScrert”];
= ConfigurationManager.AppSettings[“OAuth_Sina_ClientId”];
= ConfigurationManager.AppSettings[“OAuth_Sina_ClientScrert”];
= ConfigurationManager.AppSettings[“OAuth_Sina_CallbackUrl”];
........

 是的，很简单、很方便、很清晰。可以总感觉缺少那么一点“面向对象”的感觉。少还无所谓，如果几十个上百个呢？我们是不是可以考虑分类定义，如下：

 <!--自定义配置-->
  <customCon>
    <!--邮件配置-->
    <mail mailPwd="" mailHost="" mailFrom="" />
    <!--QQ登陆-->
    <oAuthQQ OAuth_QQ_ClientId="" OAuth_QQ_ClientScrert="" OAuth_QQ_CallbackUrl="haojima.net/hi_login.html" />
    <!--新浪登录-->
    <oAuthSina OAuth_Sina_ClientId="" OAuth_Sina_ClientScrert="" OAuth_Sina_CallbackUrl="haojima.net/hi_login.html" />
  </customCon>

 可是，你会发现 customCon 编辑器不认，因为这是我自己定义的一个，那如何是好？如下：（申明自定义标签）

如此，是不是感觉分类更清楚了？可是问题又来了，那我们怎么读取自定义标签里面的值呢？
首先：（注意：需要继承ConfigurationSection）

/// <summary>
    /// 自定义配置
    /// </summary>
    public class CustomCon : ConfigurationSection
    {
        /// <summary>
        /// 邮箱设置
        /// </summary>
        [ConfigurationProperty("mail", IsRequired = true)]
        public MailElement Mail
        {
            get { return (MailElement)this["mail"]; }
        }

        /// <summary>
        /// qq登录
        /// </summary>
        [ConfigurationProperty("oAuthQQ", IsRequired = true)]
        public OAuthQQElement OAuthQQ
        {
            get { return (OAuthQQElement)this["oAuthQQ"]; }
        }

        /// <summary>
        /// 新浪登录
        /// </summary>
        [ConfigurationProperty("oAuthSina", IsRequired = true)]
        public OAuthSinaElement OAuthSina
        {
            get { return (OAuthSinaElement)this["oAuthSina"]; }
        }
    } 

然后MailElement、OAuthQQElement、OAuthSinaElement 分别具体定义：


 #region MailElement(邮箱)
    public class MailElement : ConfigurationElement
    {
        /// <summary>
        /// 发件人密码
        /// </summary>
        [ConfigurationProperty("mailPwd", IsRequired = true)]
        public string Pwd
        {
            get { return this["mailPwd"].ToString(); }
            set { this["mailPwd"] = value; }
        }

        /// <summary>
        /// SMTP邮件服务器
        /// </summary>
        [ConfigurationProperty("mailHost", IsRequired = true)]
        public string Host
        {
            get { return this["mailHost"].ToString(); }
            set { this["mailHost"] = value; }
        }

        /// <summary>
        ///发件人邮箱
        /// </summary>
        [ConfigurationProperty("mailFrom", IsRequired = true)]
        public string From
        {
            get { return this["mailFrom"].ToString(); }
            set { this["mailFrom"] = value; }
        }
    }
    #endregion

    #region OAuthQQElement（QQ）
    public class OAuthQQElement : ConfigurationElement
    {

        [ConfigurationProperty("OAuth_QQ_ClientId", IsRequired = true)]
        public string ClientId
        {
            get { return this["OAuth_QQ_ClientId"].ToString(); }
            set { this["OAuth_QQ_ClientId"] = value; }
        }


        [ConfigurationProperty("OAuth_QQ_ClientScrert", IsRequired = true)]
        public string ClientScrert
        {
            get { return this["OAuth_QQ_ClientScrert"].ToString(); }
            set { this["OAuth_QQ_ClientScrert"] = value; }
        }


        [ConfigurationProperty("OAuth_QQ_CallbackUrl", IsRequired = true)]
        public string CallbackUrl
        {
            get { return this["OAuth_QQ_CallbackUrl"].ToString(); }
            set { this["OAuth_QQ_CallbackUrl"] = value; }
        }
    }
    #endregion

    #region OAuthSinaElement(新浪)
    public class OAuthSinaElement : ConfigurationElement
    {

        [ConfigurationProperty("OAuth_Sina_ClientId", IsRequired = true)]
        public string ClientId
        {
            get { return this["OAuth_Sina_ClientId"].ToString(); }
            set { this["OAuth_Sina_ClientId"] = value; }
        }


        [ConfigurationProperty("OAuth_Sina_ClientScrert", IsRequired = true)]
        public string ClientScrert
        {
            get { return this["OAuth_Sina_ClientScrert"].ToString(); }
            set { this["OAuth_Sina_ClientScrert"] = value; }
        }


        [ConfigurationProperty("OAuth_Sina_CallbackUrl", IsRequired = true)]
        public string CallbackUrl
        {
            get { return this["OAuth_Sina_CallbackUrl"].ToString(); }
            set { this["OAuth_Sina_CallbackUrl"] = value; }
        }
    }
    #endregion

View Code
到现在为止，我们在代码层面已经建立和config一一对应的关联了。下面我们来取值：

 CustomCon custom = (CustomCon)ConfigurationManager.GetSection("customCon");
 var url = custom.OAuthQQ.CallbackUrl;//获取值
 var id = custom.OAuthQQ.ClientId;//获取值
 //、、、、、

如此是不是甚爽，比原先的 appSettings 更有“对象”的感觉了吧。且，当你配置过多的时候分类也更加清晰！
Web.config的写入
 对于Web.config的写入需求一般很少，多数都只是读取。那为什么我这里要说写入呢？因为好多人问我“这个博客系统的数据库在哪里？”，每次都解释的'不亦乐乎',"这个是coder first根据代码生成数据库"，后来次数多了实在受不了了。考虑着，是否可以做个引导页面，初次使用的时候提示设置数据库和邮箱什么的（这样的话对于没有编程基础的人搭建自己的博客系统也降低了门槛）。

第一次启动程序的时候检查数据库连接，没有就进入引导页面，设置。（这个过程都不用去编辑Web.config文件了）
好了，看了上面的效果图我们继续来看是怎么把数据写入到Web.config文件的吧。
其实很简单，稍微改下上面代码:

改成通过 WebConfigurationManager.OpenWebConfiguration 来读取代码就可以编辑了。不过不要忘了 config.Save(); 才会真正更新到Web.config里面去。
到这里还只能修改我们自定义的节点数据。我们最最主要的是想更新数据库连接，请看下面对数据库连接的操作：

/// <summary>
/// 修改数据库连接
/// </summary>
/// <param name="key"></param>
/// <param name="connectionString"></param>
/// <param name="providerName"></param>
public static void SetConnectionString(string key, string connectionString, string providerName = "System.Data.SqlClient")
{
    ConnectionStringsSection connectionSetting = (ConnectionStringsSection)config.GetSection("connectionStrings");
    if (connectionSetting.ConnectionStrings[key] == null)//如果不存在此节点,则添加  
    {
        ConnectionStringSettings connectionStringSettings = new ConnectionStringSettings(key, connectionString, providerName);
        connectionSetting.ConnectionStrings.Add(connectionStringSettings);
    }
    else//如果存在此节点,则修改  
    {
        connectionSetting.ConnectionStrings[key].ConnectionString = connectionString;
        connectionSetting.ConnectionStrings[key].ProviderName = providerName;
    }
    config.Save();
}

其实，细看和我们上面的代码大同小异。（只是把我们自定义的类改成了 ConnectionStringsSection .net默认的连接对象） 
 

《一步步搭建自己的博客》
好了，以上都是胡说八道。
主要是说下思路，大家自由发挥。感谢您的阅读，希望对您有一点点作用！
文章首链：http://www.cnblogs.com/zhaopei/p/5677053.html

 
article  25
title: 四、可空类型Nullable<T>到底是什么鬼
body: 
值类型为什么不可以为空
首先我们都知道引用类型默认值都是null，而值类型的默认值都有非null。

为什么引用类型可以为空？因为引用类型变量都是保存一个对象的地址引用（就像一个url对应一个页面）,而引用类型值为null的时候是变量值指向了一个空引用（如同一个空的url）

那为什么值不能有空值呢？其实很简单，因为如int值范围是-2147483648到2147483647。其中根本就没有给null值留那么一个位置。

我们为什么需要用到可空类型
举个栗子吧，我们定义一个人（Person），它有三个属性出生日期（BeginTime）、死亡日期（EndTime）、年龄（Age）。
如果这个人还健在人世，请问怎么给死亡日期赋值？有人很聪明说“为空啊”。是的，这就是我们的需求。
微软在C#2.0的时候就为我们引入了可null值类型（ System.Nullable<T> ），那么下面来定义Person类。

 1 public class Person
 2 {
 3     /// <summary>
 4     /// 出生日期
 5     /// </summary>
 6     public DateTime BeginTime { get; set; }
 7     /// <summary>
 8     /// 死亡日期
 9     /// </summary>
10     public System.Nullable<DateTime> EndTiem { get; set; }
11     public int Age
12     {
13         get
14         {
15             if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
16             {
17                 return (EndTiem.Value - BeginTime).Days;
18             }
19             else//还没挂
20             {
21                 return (DateTime.Now - BeginTime).Days;
22             }
23         }
24     }
25 }

 
这样，我们就可以很容易获得一个人的年龄了。

static void Main(string[] args)
{
    Person p1 = new Person()
    {
        BeginTime = DateTime.Parse("1990-07-19")
    };

    Person p2 = new Person()
    {
        BeginTime = DateTime.Parse("1893-12-26"),
        EndTiem = DateTime.Parse("1976-09-09")
    };

    Console.WriteLine("我今年" + p1.Age + "岁。");
    Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");

    Console.ReadKey();
}

可空类型的实现
我们前面用到了 System.Nullable<DateTime> 来表示可空时间类型，其实平时我们用得更多的是 DateTime? 直接在类型T后面加一个问号，这两种是等效的。多亏了微软的语法糖。
我们来看看 System.Nullable<T> 到底是何物。

搜噶，原来是一个结构。还看到了我们属性的 HasValue和Value属性。原来竟这般简单。一个结构两个属性，一个存值，一个存是否有值。那么下面我们也来试试吧。

不好意思，让大家失望了。前面我们就说过了，值类型是不可以赋值null的(结构也是值类型)。
怎么办！怎么办！不对啊，微软自己也是定义的结构，它怎么可以直接赋值null呢。（奇怪，奇怪，毕竟是人家微软自己搞得，可能得到了特殊的待遇吧）
可是，这样就让我们止步了吗？NO!我们都知道，看微软的IL（中间语言）的时候，就像脱了它的衣服一样，很多时候不明白的地方都可以看个究竟，下面我们就去脱衣服。
首先，我们用几种不同的方式给可空类型赋值。

static void Main(string[] args)
{

    System.Nullable<int> number1 = null;

    System.Nullable<int> number2 = new System.Nullable<int>();

    System.Nullable<int> number3 = 23;

    System.Nullable<int> number4 = new System.Nullable<int>(88);

    Console.ReadKey();
}    

 
然后用reflector看编译后的IL。

原来如此，可空类型的赋值直接等效于构造实例。赋null时其实就是调用空构造函数，有值时就就把值传入带参数的构造函数。(柳暗花明又一村。如此，我们是否可以接着上面截图中的 MyNullable<T> 继续模拟可空类型呢？且继续往下看。)

public struct MyNullable<T> where T : struct
{
    //错误    1    结构不能包含显式的无参数构造函数 
    //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
    //public MyNullable()
    //{
    //    this._hasValue = false;
    //}
    public MyNullable(T value)//有参构造函数
    {
        this._hasValue = true;
        this._value = value;
    }

    private bool _hasValue;

    public bool HasValue//是否不为空
    {
        get { return _hasValue; }
    }

    private T _value;
    public T Value//值
    {
        get
        {
            if (!this._hasValue)//如没有值，还访问就抛出异常
            {
                throw new Exception(" 可为空的对象必须具有一个值");
            }
            return _value;
        }
    }
}

 
哟西，基本上已经模拟出了可空类型出来的。（但是我们还是不能直接赋值，只能通过构造函数的方式来使用自定义的可空类型）。
全部代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 可空类型
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //}
        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new Exception(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))//这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");

            Console.ReadKey();
        }

    }
}

View Code
 
和系统的可空类型得出了相同的结果。

总结

可空类型是结构（也就是值类型）
所以可空类型的null值和引用类型的null是不一样的。（可空类型的并不是引用类型的null，而是用结构的另一种表示方式来表示null）


 

有同学问，怎么样才可以做到直接赋值呢？这个我也没有什么好的办法，或许需要编译器的支持。
以上内容都是胡说八道。希望能对您有那么一点点用处，感谢阅读。
（首发链接：http://www.cnblogs.com/zhaopei/p/5537759.html ）

 
 

 
============== 2016-06-05更新==============
上面我们提出了疑问“怎么样才可以做到直接赋值呢”，本来我是没有好的解决办法。这里要感谢我们的园友@冲杀给我提供了好的解决方案。
implicit（关键字用于声明隐式的用户定义类型转换运算符。）

public static implicit operator MyNullable<T>(T value)
{
       return new MyNullable<T>(value);
}

只需要在 struct MyNullable<T> 中添加以上代码，就可以直接赋值了。（作用等效于是直接重写了“=”赋值符号）


完整代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace test
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //} 

        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new InvalidOperationException(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }

        public static implicit operator MyNullable<T>(T value)
        {
            return new MyNullable<T>(value);
        } 
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = DateTime.Parse("1976-09-09") 
                //new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))
                //这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。"); 

            Console.ReadKey();
        }

    }
}

View Code
 
如此，我们已经完成了自定义可空类型的直接赋值。但只是部分，如果想要赋值null呢？

同样还是出现了最开始的编译错误。我们想到既然上面的值赋值可以重新（隐式转换）,那null应该也可以啊（null是引用类型的一个特定值）。
再加一个重载：

//隐式转换
public static implicit operator MyNullable<T>(string value)
{
    if (value == null)
        return new MyNullable<T>();
    throw new Exception("赋值右边不能为字符串");
    //这里不知道是否可以在编译期间抛出错误(或者怎样限制只能传null)
}

 
如此可以满足我们的需求了（并无异常）。

可惜美中不足，如果给 p2.EndTiem 赋值一个非空字符串时，要运行时才会报错（而系统的可空类型会在编译期就报错）。不知道大神们可有解！！
虽然如此，能做到直接赋值还是让我小小激动了一把。为此，特意查了下关键字 implicit operator ，又是让我小小激动了一把，我们不仅可以“重写”赋值，我们还可以“重写”+ - * / % & | ^ << >> == != > < >= <=等运算符。
下面我们先来“重写”下自定义可空类型的比较（==）运算符。

//"重写"比较运算符
public static bool operator ==(MyNullable<T> operand, MyNullable<T> operand2)
{
    if (!operand.HasValue && !operand2.HasValue)
    {
        return true;
    }
    else if (operand.HasValue && operand2.HasValue)
    {
        if (operand2.Value.Equals(operand.Value))
        {
            return true;
        }
    }
    return false;
}

//"重写"比较运算符
public static bool operator !=(MyNullable<T> operand, MyNullable<T> operand2)
{
    return !(operand == operand2);
}

 

Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
Console.WriteLine("p1.EndTiem == DateTime.Parse(1976-09-09)," + (p1.EndTiem == DateTime.Parse("1976-09-09")).ToString());
Console.WriteLine("p2.EndTiem == DateTime.Parse(1976-09-09)," + (p2.EndTiem == DateTime.Parse("1976-09-09")).ToString());

p1.EndTiem = DateTime.Parse("2016-06-06");
p2.EndTiem = null;
Console.WriteLine();
Console.WriteLine("赋值 p1.EndTiem = DateTime.Parse(2016-06-06)  p2.EndTiem = null 后：");
Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
Console.WriteLine("p1.EndTiem == DateTime.Parse(2016-06-06)," + (p1.EndTiem == DateTime.Parse("2016-06-06")).ToString());
Console.WriteLine("p2.EndTiem == DateTime.Parse(2016-06-06)," + (p2.EndTiem == DateTime.Parse("2016-06-06")).ToString());


结果完全符合！
完整代码如下：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace test
{
    public class Person
    {
        /// <summary>
        /// 出生日期
        /// </summary>
        public DateTime BeginTime { get; set; }
        /// <summary>
        /// 死亡日期
        /// </summary>
        public MyNullable<DateTime> EndTiem { get; set; } //这里改用MyNullable
        /// <summary>
        /// 年龄
        /// </summary>
        public double Age
        {
            get
            {
                if (EndTiem.HasValue)//如果挂了(如果有值，证明死了)
                {
                    return (EndTiem.Value - BeginTime).Days / 365;
                }
                else//还没挂
                {
                    return (DateTime.Now - BeginTime).Days / 365;
                }
            }
        }
    }

    public struct MyNullable<T> where T : struct
    {
        //错误    1    结构不能包含显式的无参数构造函数 
        //还好 bool默认值就是false,所以这里不显示为 this._hasValue = false也不会有影响
        //public MyNullable()
        //{
        //    this._hasValue = false;
        //} 

        public MyNullable(T value)//有参构造函数
        {
            this._hasValue = true;
            this._value = value;
        }

        private bool _hasValue;

        public bool HasValue//是否不为空
        {
            get { return _hasValue; }
        }

        private T _value;
        public T Value//值
        {
            get
            {
                if (!this._hasValue)//如没有值，还访问就抛出异常
                {
                    throw new InvalidOperationException(" 可为空的对象必须具有一个值");
                }
                return _value;
            }
        }

        //隐式转换
        public static implicit operator MyNullable<T>(T value)
        {
            return new MyNullable<T>(value);
        }

        //隐式转换
        public static implicit operator MyNullable<T>(string value)
        {
            if (value == null)
                return new MyNullable<T>();
            throw new Exception("赋值右边不能为字符串");
            //这里不知道是否可以在编译期间抛出错误(或者怎样限制只能传null)
        }

        //"重写"比较运算符
        public static bool operator ==(MyNullable<T> operand, MyNullable<T> operand2)
        {
            if (!operand.HasValue && !operand2.HasValue)
            {
                return true;
            }
            else if (operand.HasValue && operand2.HasValue)
            {
                if (operand2.Value.Equals(operand.Value))
                {
                    return true;
                }
            }
            return false;
        }

        //"重写"比较运算符
        public static bool operator !=(MyNullable<T> operand, MyNullable<T> operand2)
        {
            return !(operand == operand2);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Person p1 = new Person()
            {
                BeginTime = DateTime.Parse("1990-07-19")
            };

            Person p2 = new Person()
            {
                BeginTime = DateTime.Parse("1893-12-26"),
                EndTiem = DateTime.Parse("1976-09-09")
                //new MyNullable<DateTime>(DateTime.Parse("1976-09-09"))
                //这里使用MyNullable的有参构造函数
            };

            Console.WriteLine("我今年" + p1.Age + "岁。");
            Console.WriteLine("毛爷爷活了" + p2.Age + "岁。");
            Console.WriteLine();

            Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
            Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
            Console.WriteLine("p1.EndTiem == DateTime.Parse(1976-09-09)," + (p1.EndTiem == DateTime.Parse("1976-09-09")).ToString());
            Console.WriteLine("p2.EndTiem == DateTime.Parse(1976-09-09)," + (p2.EndTiem == DateTime.Parse("1976-09-09")).ToString());

            p1.EndTiem = DateTime.Parse("2016-06-06");
            p2.EndTiem = null;
            Console.WriteLine();
            Console.WriteLine("赋值 p1.EndTiem = DateTime.Parse(2016-06-06)  p2.EndTiem = null 后：");
            Console.WriteLine("p1.EndTiem == null," + (p1.EndTiem == null).ToString());
            Console.WriteLine("p2.EndTiem == null," + (p2.EndTiem == null).ToString());
            Console.WriteLine("p1.EndTiem == DateTime.Parse(2016-06-06)," + (p1.EndTiem == DateTime.Parse("2016-06-06")).ToString());
            Console.WriteLine("p2.EndTiem == DateTime.Parse(2016-06-06)," + (p2.EndTiem == DateTime.Parse("2016-06-06")).ToString());     

            Console.ReadKey();
        }

    }
}

View Code
 
 
转换关键字：operator、explicit与implicit解析资料：http://www.cnblogs.com/hunts/archive/2007/01/17/operator_explicit_implicit.html
大家还可以玩出更多的花样！！！
 
本文已同步至《C#基础知识巩固系列》
article  26
title: 你必须知道的EF知识和经验
body: 
注意：以下内容如果没有特别申明，默认使用的EF6.0版本，code first模式。
推荐MiniProfiler插件
工欲善其事，必先利其器。
我们使用EF和在很大程度提高了开发速度，不过随之带来的是很多性能低下的写法和生成不太高效的sql。
虽然我们可以使用SQL Server Profiler来监控执行的sql，不过个人觉得实属麻烦，每次需要打开、过滤、清除、关闭。
在这里强烈推荐一个插件MiniProfiler。实时监控页面请求对应执行的sql语句、执行时间。简单、方便、针对性强。
如图：(具体使用和介绍请移步)

数据准备
新建实体：Score（成绩分数表）、Student（学生表）、Teacher（老师表）

后面会给出demo代码下载链接
foreach循环的陷进 
1.关于延迟加载

请看上图红框。为什么StudentId有值，而Studet为null？因为使用code first，需要设置导航属性为virtual，才会加载延迟加载数据。

2.关于在循环中访问导航属性的异常处理（接着上面,加上virtual后会报以下异常）
"已有打开的与此 Command 相关联的 DataReader，必须首先将它关闭。"

解决方案：

方案1、设定ConnectionString加上MultipleActiveResultSets=true,但只适用于SQL 2005以后的版本
方案2、或者先读出放置在List中

3.以上两点仅为热身，我们说的陷阱才刚刚开始！

然后我们点击打开MiniProfiler工具（不要被吓到）


解决方案：使用Include显示连接查询（注意:需要手动导入using System.Data.Entity 不然Include只能传表名字符串）。

再看MiniProfiler的监控（瞬间101条sql变成了1条，这其中的性能可想而知。）

AutoMapper工具
上面我们通过Include显示的执行表的连接查询显然是不错的，但还不够。如果我们只需要查询数据的某些字段呢，上面查询所有字段岂不是很浪费内存存储空间和应用程序与数据库数据传输带宽。
我们可以：

对应监控到的sql：

我们看到生成的sql，查询的字段少了很多。只有我们显示列出来字段的和一个StudentId，StudentId用来连接查询条件的。
是的，这样的方式很不错。可是有没有什么更好的方案或方式呢？答案是肯定的。（不然，也不会在这里屁话了。）如果表字段非常多，我们需要使用的字段也非常多，导航属性也非常多的时候，这样的手动映射就显得不那么好看了。那么接下来我们开始介绍使用AutoMapper来完成映射：
注意：首先需要NuGet下载AutoMapper。（然后导入命名空间 using AutoMapper; using AutoMapper.QueryableExtensions;）


我们看到上面查询语句没有一个个的手动映射，而映射都是独立配置了。其中CreateMap应该是要写到Global.asax文件里面的。（其实也就是分离了映射部分，清晰了查询语句。细心的同学可能注意到了，这种方式还免去了主动Include）

我们看到了生成的sql和前面有些许不同，但只生成了一条sql，并且结果也是正确的。(其实就是多了一条CASE WHEN ([Extent2].[Id] IS NOT NULL) THEN 1 END AS [C1]。看起来这条语句并没有什么实际意义，然而这是AutoMapper生成的sql，同时我也表示不理解为什么和EF生成的不同)
这样做的好处？

避免在循环中访问导航属性多次执行sql语句。
避免了查询语句中太多的手动映射，影响代码的阅读。

关于AutoMapper的其他一些资料：
http://www.cnblogs.com/xishuai/p/3712361.html
http://www.cnblogs.com/xishuai/p/3700052.html
http://www.cnblogs.com/farb/p/AutoMapperContent.html
联表查询统计
要求：查询前100个学生考试类型（“模拟考试”、“正式考试”）、考试次数、语文平均分、学生姓名，且考试次数大于等于3次。（按考试类型分类统计）
代码如下：

看到这样的代码，我第一反应是惨了。又在循环执行sql了。监控如下：

其实，我们只需要稍微改动就把101条sql变成1条，如下：

马上变1条。

我们打开查看详细的sql语句

发现这仅仅只是查询结果集合而已，其中的按考试类型来统计是程序拿到所有数据后在计算的（而不是在数据库内计算，然后直接返回结果），这样同样是浪费了数据库查询数据传输。
关于连接查询分组统计我们可以使用SelectMany，如下：

监控sql如下：（是不是简洁多了呢？）

关于SelectMany资料：
http://www.cnblogs.com/lifepoem/archive/2011/11/18/2253579.html
http://www.cnblogs.com/heyuquan/p/Linq-to-Objects.html
性能提升之AsNonUnicode

监控到的sql

我们看到EF正常情况生成的sql会在前面带上“N”，如果我们加上DbFunctions.AsNonUnicode生成的sql是没有“N”的，当你发现带上“N”的sql比没有带“N”的 sql查询速度慢很多的时候那就知道该怎么办。
（以前用oracle的时候带不带“N”查询效率差别特别明显，今天用sql server测试并没有发现什么差别。还有我发现EF6会根据数据库中是nvarchar的时候才会生成带“N”的sql，oracle数据库没测试，有兴趣的同学可以测试下）
性能提升之AsNoTracking

我们看生成的sql

sql是生成的一模一样，但是执行时间却是4.8倍。原因仅仅只是第一条EF语句多加了一个AsNoTracking。
注意：

AsNoTracking干什么的呢？无跟踪查询而已，也就是说查询出来的对象不能直接做修改。所以，我们在做数据集合查询显示，而又不需要对集合修改并更新到数据库的时候，一定不要忘记加上AsNoTracking。
如果查询过程做了select映射就不需要加AsNoTracking。如：db.Students.Where(t=>t.Name.Contains("张三")).select(t=>new (t.Name,t.Age)).ToList();

多字段组合排序（字符串）
要求：查询名字里面带有“张三”的学生，先按名字排序，再按年龄排序。


咦，不对啊。按名字排序被年龄排序覆盖了。我们应该用ThenBy来组合排序。


不错不错，正是我们想要的效果。如果你不想用ThenBy，且都是升序的话，我们也可以：


生成的sql是一样的。与OrderBy、ThenBy对应的降序有OrderByDescending、ThenByDescending。
看似好像很完美了。其实不然，我们大多数情况排序是动态的。比如，我们会更加前端页面不同的操作要求不同字段的不同排序。那我们后台应该怎么做呢？

当然，这样完成是没问题的，只要你愿意。可以这么多可能的判断有没有感觉非常SB？是的，我们当然有更好的解决方案。要是OrderBy可以直接传字符串？？？
解决方案：

guget下载System.Linq.Dynamic 
导入System.Linq.Dynamic命名空间
编写OrderBy的扩展方法


然后上面又长又臭的代码可以写成：

我们看下生成的sql：

和我们想要的效果完全符合，是不是感觉美美哒！！
【注意】：传入的排序字段后面要加排序关键字 asc或desc
lamdba条件组合
要求：根据不同情况查询，可能情况

查询name=“张三” 的所有学生
查询name=“张三” 或者 age=18的所有学生

实现代码：

是不是味到了同样的臭味。下面我们来灵活组装Lamdba条件。
解决方案：

这段代码我也是从网上偷的，具体链接找不到了。
然后我们的代码可以写成：

有没有美美哒一点。然后我们看看生成的sql是否正确：

EF的预热
http://www.cnblogs.com/dudu/p/entity-framework-warm-up.html
count(*)被你用坏了吗（Any的用法）
要求：查询是否存在名字为“张三”的学生。（你的代码会怎样写呢？）

第一种？第二种？第三种？呵呵，我以前就是使用的第一种，然后有人说“你count被你用坏了”，后来我想了想了怎么就被我用坏了呢？直到对比了这三个语句的性能后我知道了。

性能之差竟有三百多倍，count确实被我用坏了。（我想，不止被我一个人用坏了吧。）
我们看到上面的Any干嘛的？官方解释是：

我反复阅读这个中文解释，一直无法理解。甚至早有人也提出过同样的疑问《实在看不懂MSDN关于 Any 的解释》
所以我个人理解也是“确定集合中是否有元素满足某一条件”。我们来看看any其他用法：
要求：查询教过“张三”或“李四”的老师
实现代码：

两种方式，以前我会习惯写第一种。当然我们看看生成过的sql和执行效率之后，看法改变了。

效率之差竟有近六倍。
我们再对比下count：


得出奇怪的结论：

在导航属性里面使用count和使用any性能区别不大，反而FirstOrDefault() != null的方式性能最差。
在直接属性判断里面any和FirstOrDefault() != null性能区别不大，count性能要差的多。
所以，不管是直接属性还是导航属性我们都用any来判断是否存在是最稳当的。

透明标识符
假如由于各种原因我们需要写下面这样逻辑的语句

我们可以写成这样更好

看生成的sql就知道了

第二种方式生成的sql要干净得多，性能也更好。
EntityFramework.Extended
这里推荐下插件EntityFramework.Extended，看了下，很不错。
最大的亮点就是可以直接批量修改、删除，不用像EF默认的需要先做查询操作。
至于官方EF为什么没有提供这样的支持就不知道了。不过使用EntityFramework.Extended需要注意以下几点：

只支持sql server
批量修改、删除时不能实现事务（也就是出了异常不能回滚）
没有联级删除
不能同EF一起SaveChanges （详见）

http://www.cnblogs.com/GuZhenYin/p/5482288.html
在此纠正个问题EntityFramework.Extended并不是说不能回滚，感谢@GuZhenYin园友的指正（原谅我之前没有动手测试）。
注意：需要NuGet下载EntityFramework.Extended， 并导入命名空间： using EntityFramework.Extensions ;
测试代码如下：（如果注释掉手抛异常代码是可以直接更新到数据库的）

using (var ctxTransaction = db.Database.BeginTransaction())
{
    try
    {
        db.Teachers.Where(t => true).Update(t => new Teacher { Age = "1" });

        throw new Exception("手动抛出异常");

        ctxTransaction.Commit();//提交事务
    }
    catch (Exception)
    {
        ctxTransaction.Rollback();//回滚事务
    }
}

自定义IQueryable扩展方法
 最后整理下自定义的IQueryable的扩展。
 

 
补充1：
First和Single的区别：前者是TOP(1)后者是TOP(2)，后者如果查询到了2条数据则抛出异常。所以在必要的时候使用Single也不会比First慢多少。
补充2: 
已打包nuget提供直接安装 Install-Package Talk.Linq.Extensions 或nuget搜索 Talk.Linq.Extensions 
https://github.com/zhaopeiym/Talk/wiki/Talk.Linq.Extensions_demo
 
结束：
源码下载：http://pan.baidu.com/s/1o8MYozw
本文以同步至《C#基础知识巩固系列》
欢迎热心园友补充！
article  27
title: 一步步学习javascript基础篇（9）：ajax请求的回退
body: 
需求1：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）

ajax异步请求没问题，问题一般出在刷新url后请求的数据没了，这就是因为url没有记录参数。如果我们改变给url添加参数，这样就改变了url，也就会重新请求整个url。这样一来就没有了ajax的优势和作用了。那么，我们应该怎么保持参数而又不重新请求url呢？做过单页面SPA (Single-page Application)的都知道，我们可以使用描点来实现(因为修改描点的时候，不会发送url的重新请求)。
如，博客园的分页就是如此
 
demo1：

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <style type="text/css">
        ul {
            list-style: none;
        }

            ul li {
                float: left;
                margin-left: 10px;
            }
    </style>
</head>
<body>
    <div style="color: red; margin-left: 50px; ">demo1（默认的回退效果）</div>
    <div>
        <ul>
            <li><a href="#tab1">tab1</a></li>
            <li><a href="#tab2">tab2</a></li>
            <li><a href="#tab3">tab3</a></li>
            <li><a href="#tab4">tab4</a></li>
            <li><a href="#tab5">tab5</a></li>
        </ul>

    </div>
    <input style="margin-left:15px" type="button" value="回退" onclick="history.go(-1)" />
    <a href="home.html">主页</a> 
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })
        $("ul").click(function (e) {

            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {//ajax的get请求
                //请求发送成功后修改页面元素内容
                $(".content").html("我是" + value);
            }, "text");
        });
    </script>
</body>
</html>

 
效果图：

我们认真看上面的gif动态图，会发现点击tab的ajax异步加载完全没问题，只是我们点击回退的时候 虽然url的描点变了，可是内容没变。（博客园的分页回退就是这个效果）这肯定是不太好的效果。（对history.go()不太了解的请戳）
 
需求2：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”页面要可以回到“主页”

通过观察上面的gif动图，我们发现回退的顺序正是，url的改变记录顺序。那我们在每次点击一个ajax请求累加一次计数，这样是不是就可以一次性退回“主页”呢？
demo2：

<input style="margin-left:15px" type="button" value="回退" onclick="go()" />
    <a href="home.html">主页</a>
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        var num = -1;
        $("ul").click(function (e) {
            num--;
            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
            }, "text");
        });

        function go() {
            history.go(num)
        }
    </script>

 
效果图：

ok，效果是我们要的。可是需求又说了，感觉这样还是不太好，回退应该是返回上一次的点击效果。
 
需求3：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果

拿到需求开始头痛了，怎么回退到上一次点击效果呢？有没有什么回退事件呢？还好H5给我们准备了 window.onpopstate url监听事件。
demo3:

<input style="margin-left:15px" type="button" value="回退" onclick="history.go(-1)" />
    <a href="home.html">主页</a>
    <div class="content" style="font-size:44px;color:red;margin-top:50px;text-align:center">

    </div>
    
    <script src="../../Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {         

            if (e.target.localName != "a") return;//如果点击的不是a标签直接返回

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
            }, "text");
        });

        if (history.pushState) {            
            window.onpopstate = function () {
                var hash = window.location.hash;
                $("ul").find("a[href='" + hash + "']").click();
            }
        } 
    </script>

效果图：

乍一看，好像很完美了（url和内容同时发生了对应的改变）。其实不然。我们debugger调试一看便知。

仔细看上图，你会发现  $("ul").click( a标签出现了两次点击事件（这明显是有瑕疵的），首先直接点击a标签触发，然后改变了url导致触发onpopstate事件，然后在onpopstate事件里面又一次点击a标签，最后导致了两次执行a标签点击事件。

那么如何，避免执行两次a标签的点击事件呢？思路肯定是怎样在修改url的时候不触发onpopstate事件，只有在前进和回退的时候触发。这里就要用到 history.pushState 了。
 
需求4：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果（但是不能执行多余代码）


 <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = window.location.hash;
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {
            debugger
            e.preventDefault();//不要执行与事件关联的默认动作

            if (e.target.localName != "a") return;//如果点击的不是a标签直接返回

            var value = $(e.target).attr("href");
            $.get("temp.html", value, function (obj) {
                $(".content").html("我是" + value);
                if (e && e.clientX) //用来判断是否是鼠标点击触发
                    history.pushState(null, value, location.href.split("#")[0] + value);//塞入历史记录，并改变当前url
            }, "text");
        });

        if (history.pushState) {
            window.onpopstate = function () {
                debugger;
                var hash = window.location.hash;
                $("ul").find("a[href='" + hash + "']").click();
                debugger
            }
        }
    </script>

（这需要注意  if (e && e.clientX) //用来判断是否是鼠标点击触发 如果没有这句，那么每次触发onpopstate 的时候往历史记录里面塞进去一条，那样就死循环出不来了。）
效果图：

明显可以看出只执行了一次a标签的点击事件，且回退功能也是正常。按道理，现在已经是完美了。不过，我们回过头来想想，我们为什么一定要使用锚点来记录参数呢。以前是因为修改锚点不会重新请求url而巧用了锚点。现在我们通过history.pushState把url塞入历史记录的时候，也改变了当前url且也没有对url发送请求，那我们是不是没有必要使用锚点了呢？答案是确定的。
 
需求4：

ajax异步请求
url标识请求参数（也就是说复制url在新页面打开也会是ajax后的效果）
点击“回退”返回上一次的点击效果（不使用描点）

其实，直接把上面代码修改部分就可以了。
demo4：

 <script type="text/javascript">
        $(function () {
            //刷新url时停留ajax的效果
            var hash = location.href.split("?")[1];
            $("ul").find("a[href='" + hash + "']").click();
        })

        $("ul").click(function (e) {
            e.preventDefault();//不要执行与事件关联的默认动作

            if (e.target.localName != "a") return;

            var value = $(e.target).attr("href");
            if (e && e.clientX) //用来判断是否是鼠标点击触发
                history.pushState(null, null, location.href.split("?")[0] + "?" + value);//塞入历史记录，并改变当前url
            $.get("temp.html", value, function (obj) {
                document.title = value;
                $(".content").html("我是" + value);
            }, "text");
        });

        if (history.pushState) {
            window.addEventListener("popstate", function () {
                var hash = location.href.split("?")[1];
                $("ul").find("a[href='" + hash + "']").click();
            });
        }
    </script>

 
效果图：

 
完整演示地址：http://hi.haojima.net/demo/history/home.html
 

以上内容都是胡说八道。
好了，关于ajax回退效果就分析到这里了。感谢您的阅读，希望对您有一点点作用。
文章首链：http://www.cnblogs.com/zhaopei/p/5637889.html

 
article  28
title: 先说IEnumerable，我们每天用的foreach你真的懂它吗？
body: 
我们先思考几个问题：

为什么在foreach中不能修改item的值？
要实现foreach需要满足什么条件？
为什么Linq to Object中要返回IEnumerable?

接下来，先开始我们的正文。
自己实现迭代器
.net中迭代器是通过IEnumerable和IEnumerator接口来实现的，今天我们也来依葫芦画瓢。
首先来看看这两个接口的定义：


并没有想象的那么复杂。其中IEnumerable只有一个返回IEnumerator的GetEnumerator方法。而IEnumerator中有两个方法加一个属性。
接下来开发画瓢，我们继承IEnumerable接口并实现：

下面使用原始的方式调用：

有朋友开始说了，我们平时都是通过foreache来取值的，没有这样使用过啊。好吧，我们来使用foreach循环：

为什么说基本上是等效的呢？我们先看打印结果，在看反编译代码。


由此可见，两者有这么个关系：

我们可以回答第一个问题了“为什么在foreach中不能修改item的值？”：

我们还记得IEnumerator的定义吗
 
接口的定义就只有get没有set。所以我们在foreach中不能修改item的值。
我们再来回答第二个问题：“要实现foreach需要满足什么条件？”：
必须实现IEnumerable接口？NO

我们自己写的MyIEnumerable删掉后面的IEnumerable接口一样可以foreach（不信？自己去测试）。
所以要可以foreach只需要对象定义了GetEnumerator无参方法，并且返回值是IEnumerator或其对应的泛型。细看下图：

也就是说，只要可以满足这三步调用即可。不一定要继承于IEnumerable。有意思吧！下次面试官问你的时候一定要争个死去活来啊，哈哈！
yield的使用
你肯定发现了我们自己去实现IEnumerator接口还是有些许麻烦，并且上面的代码肯定是不够健壮。对的，.net给我们提供了更好的方式。

你会发现我们连MyIEnumerator都没要了，也可以正常运行。太神奇了。yield到底为我们做了什么呢？

好家伙，我们之前写的那一大坨。你一个yield关键字就搞定了。最妙的是这块代码：

这就是所谓的状态机吧！
我们继续来看GetEnumerator的定义和调用：

我们调用GetEnumerator的时候，看似里面for循环了一次，其实这个时候没有做任何操作。只有调用MoveNext的时候才会对应调用for循环：

现在我想可以回答你“为什么Linq to Object中要返回IEnumerable?”:
因为IEnumerable是延迟加载的，每次访问的时候才取值。也就是我们在Lambda里面写的where、select并没有循环遍历(只是在组装条件)，只有在ToList或foreache的时候才真正去集合取值了。这样大大提高了性能。
如：

这个时候得到了就是IEnumerable对象，但是没有去任何遍历的操作。（对照上面的gif动图看）
什么，你还是不信？那我们再来做个实验，自己实现MyWhere：

现在看到了吧。执行到MyWhere的时候什么动作都没有(返回的就是IEnumerable)，只有执行到ToList的时候才代码才真正的去遍历筛选。
这里的MyWhere其实可以用扩展方法来实现，提升逼格。（Linq的那些查询操作符就是以扩展的形式实现的）[了解扩展方法]。
怎样高性能的随机取IEnumerable中的值

这段代码来源《深入理解C#》，个人觉得非常妙。贴出来给大家欣赏哈。
 
结束：
demo下载：http://pan.baidu.com/s/1dE94c1b
接下篇：《再讲IQueryable<T>，揭开表达式树的神秘面纱》
 
本文以同步至《C#基础知识巩固系列》
article  29
title: Linq表达式、Lambda表达式你更喜欢哪个？
body: 
什么是Linq表达式？什么是Lambda表达式？
如图：

由此可见Linq表达式和Lambda表达式并没有什么可比性。
那与Lambda表达式相关的整条语句称作什么呢？在微软并没有给出官方的命名，在《深入理解C#》中称为点标记。

查询表达式、点标记你更喜欢哪个？
所以，我们的标题的提问根本就不合适。应该是“查询表达式和点标记你更喜欢哪个？”。如：

 //查询表达式
 var students1 = from t in db.Students
                where t.Name == "张三"
                select new { t.Id, t.Name, t.Age };
 //点标记
 var students2 = db.Students
                 .Where(t => t.Name == "张三")
                 .Select(t => new { t.Id, t.Name, t.Age });

为什么选择点标记 
我相信更多的人偏向选择点标记。具体什么原因我也说不清（可能是点标记中的Lambda更加优雅吧）。对于我个人来说，也是更加喜欢点标记这种方式。
1、所有的查询表达式都可以转成对应的点标记。反之，不是所有的点标记都可以转成查询表达式。
为什么？因为查询表达式在编译后就直接变成了点标记：（以下是上面两个语句对应的编译后的反编译C#代码）

生成了一模一样的代码。（由于是编译后的，好多乱七八糟的代码。我们只看Where和Select关键字就知道，使用的都是点标记。）
2、点标记确实比查询表达式更加优雅
例一：

 //查询表达式
 var students1 = from t in db.Students
                 where t.Name == "张三"
                 select t;
 //点标记
 var students2 = db.Students
                 .Where(t => t.Name == "张三");

我为什么一定要 select t 啊，这句没卵用的废话就不能省吗？是的，省了就报错：

例二：
必须需要括号包裹起来才能取结果集？你还能更丑一点吗？

//查询表达式
var students1 = (from t in db.Students
                 where t.Name == "张三"
                 select t).ToList();
//点标记
var students2 = db.Students
                .Where(t => t.Name == "张三")
                .ToList();       

例三：（为什么说："不是所有的点标记都可以转成查询表达式"【此例只适用于IEnumerator】）
此条点标记你能转成查询表达式吗？

var list = new List<string>() { "张三", "张三", "张三", "张三", "李四", "张三", "李四", "张三", "李四" };

var students2 = list
                .Where((item, index) => item == "张三" && index % 2 == 0)
                .Select((item, index) => new { item, index })
                .ToList();

查询表达式你能Reverse吗？

var list = new List<string>() { "张三1", "张三2", "张三3", "张三0", "李四9", "张三3", "李四", "张三2", "李四" };

var students2 = list
             .Where((item, index) => item.Contains("张三"))
             .Select((item, index) => new { item, index })
             .Reverse()//反序
             .ToList();


ListA.Distinct().ToList();//去重
ListA.Except(ListB).ToList();//差集
ListA.Union(ListB).ToList();  //并集
ListA.Intersect(ListB).ToList();//交集

 
什么时候使用查询表达式？
通过上面的对比，好像查询表达式一文不值了。no，不是这样的。
比如下面几种情况我们就可以选择使用查询表达式：
例一：（本例适用于Linq to Object 和 没有建主外键的EF查询）
点标记中的Join需要传四个参数表达式，是不是有点晕了。。。

var list1 = new Dictionary<string, string> { { "1", "张三" }, { "2", "李四" }, { "3", "张三" }, { "4", "张三" } };
var list2 = new Dictionary<string, string> { { "1", "张三" }, { "2", "李四" }, { "3", "李四" }, { "4", "张三" } };

//查询表达式
var obj1 = from l1 in list1
           join l2 in list2
           on l1.Key equals l2.Key
           select new { l1, l2 };
//点标记
var obj = list1.Join(list2, l1 => l1.Key, l2 => l2.Key, (l1, l2) => new { l1, l2 });

例二：
点标记需要区分OrderBy、ThenBy有没有觉得麻烦

//查询表达式
var obj1 = from l1 in list1
           join l2 in list2
           on l1.Key equals l2.Key
           orderby l1.Key, l2.Key descending
           select new { l1, l2 };
//点标记
var obj = list1.Join(list2, l1 => l1.Key, l2 => l2.Key, (l1, l2) => new { l1, l2 })
    .OrderBy(li => li.l1.Key)
    .ThenByDescending(li => li.l2.Key)
    .Select(t => new { t.l1, t.l2 });

总觉得查询表达式更多的只是为了照顾那些写惯了sql的程序员。
联接查询（内联、左联、交叉联）
关于联接查询使用查询表达式会更合适一些这个上面已经说了。
接下来我们写内联、左联、交叉联的查询表达式和对应的点标记代码。（目的：可能有些人不会，同时在这里也给自己做个备忘）
内联：

左联：

交叉联：

其实关于联接查询，如果EF建好了主外键我还是觉得点标记用起来更爽爽的。
 
结束：
本文并不是要改变你的习惯，也不是否定你的观点。仅仅只是表达个人对点标记和查询表达式的些许理解。
关于是使用查询表达式还是点标记，可能起着更大决定性的作用的是团队共同的习惯和规范。
然后还想说说，只要我们对比什么，很可能就会有人跳出了，什么不要比，用好了都一样，什么什么才是最重要的，什么什么的。。。
就像很多人会反感java和C#的对比，其实我个人觉得对比下底层实现、对比下语法简易也不是不可以的，只要我们可以从中学到知识（个人也是不喜欢对比 谁谁谁学什么工资多少多少）。
昨天的自己对比今天的自己，今天的自己对比明天的自己。只要可以进步为什么不要对比呢？
 
本文以同步至《C#基础知识巩固系列》
article  30
title: 一步步开发自己的博客 .NET版（10、前端对话框和消息框的实现）
body: 
关于前端对话框、消息框的优秀插件多不胜数。造轮子是为了更好的使用轮子，并不是说自己造的轮子肯定好。所以，这个博客系统基本上都是自己实现的，包括日志记录、响应式布局、评论功能等等一些本可以使用插件的。好了，废话不多时。我们来实现自己的对话框和消息框。
对话框
要求：可拖动、点击按钮后可回调

画一个简单的模型框


<div class="hi-dialog-box clearfix">
        <div class="hi-dialog-title">系统提示</div>
        <div class="hi-dialog-content">
        </div>
        <div class="hi-dialog-foot">
            <input type="button" class="hi-dialog-determine" value="确定" />
            <input type="button" class="hi-dialog-cancel" value="取消" />
        </div>
</div>

 

添上基本的样式



 div.hi-dialog-box {
            border: 1px #808080 solid;
            width: 350px;
            height: 200px;                    
            border-radius: 3px;
        }

            div.hi-dialog-box div.hi-dialog-title {
                border: 1px #808080 solid;
                margin: 1px;
                padding: 1px;
                background-color: #dedcdc;
                height: 14%;
                cursor: move;
                font-size: 20px;
            }

            div.hi-dialog-box div.hi-dialog-content {
                height: 65%;
                margin: 5px;            
            }

            div.hi-dialog-box div.hi-dialog-foot {
                margin: 1px;
                padding: 1px;
                height: 14%;
            }

                div.hi-dialog-box div.hi-dialog-foot input {
                    float: right;
                    margin-left: 5px;
                    font-size: 16px;
                }

View Code
效果图：

是不是像那么回事了，不过现在还不能拖动。拖动，说白了就是在鼠标移动的时候不停的修改绝对定位。
首先修改以下样式：

用js代码实现拖动效果：

//鼠标按下时
        $("div.hi-dialog-title").mousedown(function (event) {
            $("html").unbind();//首先清除事件方法
            var click_clientX = event.clientX;//记录鼠标按下时相对当前窗口的 x 坐标
            var click_clientY = event.clientY;//记录鼠标按下时相对当前窗口的 y 坐标
            //取的对话框容器
            var dialogBox = $(this).closest("div.hi-dialog-box");
            //记录对话框容器当前位置
            var dialogBoxX = parseInt($(dialogBox).css("left"));
            var dialogBoxY = parseInt($(dialogBox).css("top"));
            //鼠标移动时
            $("html").mousemove(dialog_mousemove = function (event) {
                //鼠标按下后移动量加上原来的位置
                var top = event.clientY - click_clientY + dialogBoxY;
                var left = event.clientX - click_clientX + dialogBoxX;
                //修改对话框位置（这里就实现了移动效果了）
                $(dialogBox).css({ "left": left, "top": top });
            });
            //鼠标按键松开时
            $("html").mouseup(function () {
                //清除鼠标移动事件
                $("html").unbind("mousemove", dialog_mousemove);
            });
        });

如果使用jquery.min.js，拖动一句代码搞定： $("div.hi-dialog-title").draggable(); 
 
以上js代码就实现了对话框的拖动效果。首先，只有当鼠标在对话框标题区域按下鼠标才可以拖动，然后鼠标移动的的时候实时计算和改变容器的位置，最后如果鼠标按键松开这清除鼠标移动事件。


点击按钮后可回调

很多时候，我们点击确定或取消的时候我们需要执行回调（比如“您是否删除”，点击了确定后肯定需要做删除操作）。

如此，我们点击确定的时候会自动关闭对话框并可以执行自己需要执行的一些操作。可以，有同学会说，你这算什么狗屁对话框啊，html代码全都需要直接编码。是的，这只是简单的说下思路，下面我们来简单整理下。

效果图：

全部代码：（当然，这只是简单实现。还有很多需要继续细化的效果，如：背景遮罩、如果实现点击多次对话框）


  1 <!DOCTYPE html>
  2 <html xmlns="http://www.w3.org/1999/xhtml">
  3 <head>
  4     <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  5     <title></title>
  6     <style type="text/css">
  7         * {
  8             box-sizing: border-box;
  9         }
 10 
 11         .clearfix:after {
 12             content: ' ';
 13             display: table;
 14             clear: both;
 15         }
 16 
 17         .clearfix {
 18             *zoom: 1;
 19         }
 20 
 21         div.hi-dialog-box {
 22             border: 1px #808080 solid;
 23             width: 350px;
 24             height: 200px;
 25             position: absolute;
 26             top: 200px;
 27             left: 40%;
 28             border-radius: 3px;
 29         }
 30 
 31             div.hi-dialog-box div.hi-dialog-title {
 32                 border: 1px #808080 solid;
 33                 margin: 1px;
 34                 padding: 1px;
 35                 background-color: #dedcdc;
 36                 height: 14%;
 37                 cursor: move;
 38                 font-size: 20px;
 39             }
 40 
 41             div.hi-dialog-box div.hi-dialog-content {
 42                 height: 65%;
 43                 margin: 5px;
 44                 overflow: auto;
 45             }
 46 
 47             div.hi-dialog-box div.hi-dialog-foot {
 48                 margin: 1px;
 49                 padding: 1px;
 50                 height: 14%;
 51             }
 52 
 53                 div.hi-dialog-box div.hi-dialog-foot input {
 54                     float: right;
 55                     margin-left: 5px;
 56                     font-size: 16px;
 57                 }
 58     </style>
 59 </head>
 60 <body>
 61     <input value="对话框（确定）" onclick="click1();" type="button" />
 62     <input value="对话框（确定、取消）" onclick="click2();" type="button" />
 63     <div class="messg" style="margin: 10px; color: red; font-size: 23px"></div>
 64 
 65     <script src="../../Scripts/jquery-1.8.2.js"></script>
 66     <script type="text/javascript">
 67         var hiDialog = {
 68             init: function (title, messg, determineCallback, cancelCallback) {
 69 
 70                 title = title || "系统提示";
 71                 var determine = "", cancel = "";
 72                 if (typeof (determineCallback) == "function")
 73                     determine = '<input type="button" class="hi-dialog-determine" value="确定" />';
 74                 if (typeof (cancelCallback) == "function")
 75                     cancel = '<input type="button" class="hi-dialog-cancel" value="取消" />';
 76 
 77                 if (!$("div.hi-dialog-box").length) {
 78                     var hi_dialog_box = '<div class="hi-dialog-box clearfix">\
 79                                     <div class="hi-dialog-title"></div>\
 80                                     <div class="hi-dialog-content">\
 81                                     </div>\
 82                                     <div class="hi-dialog-foot">\
 83                                     </div>\
 84                                 </div>';
 85                     $("body").append(hi_dialog_box);
 86                 }
 87 
 88                 var $box = $("div.hi-dialog-box");
 89                 $box.find("div.hi-dialog-title").html(title);
 90                 $box.find("div.hi-dialog-content").html(messg);
 91                 $box.find("div.hi-dialog-foot").html(determine + cancel);
 92                 $("div.hi-dialog-box").show();
 93 
 94                 $box.find(".hi-dialog-determine").click(function () {
 95                     determineCallback();
 96                     hiDialog.close();
 97                 });
 98                 $box.find(".hi-dialog-cancel").click(function () {
 99                     cancelCallback();
100                     hiDialog.close();
101                 });
102 
103                 //鼠标按下时
104                 $("div.hi-dialog-title").mousedown(function (event) {
105                     $("html").unbind();
106                     var click_clientX = event.clientX;
107                     var click_clientY = event.clientY;
108                     var dialogBox = $(this).closest("div.hi-dialog-box");
109                     var dialogBoxX = parseInt($(dialogBox).css("left"));
110                     var dialogBoxY = parseInt($(dialogBox).css("top"));
111                     //鼠标移动时
112                     $("html").mousemove(dialog_mousemove = function (event) {
113                         var top = event.clientY - click_clientY + dialogBoxY;
114                         var left = event.clientX - click_clientX + dialogBoxX;
115                         $(dialogBox).css({ "left": left, "top": top });
116                     });
117                     //鼠标按键松开时
118                     $("html").mouseup(function () {
119                         $("html").unbind("mousemove", dialog_mousemove);
120                     });
121                 });
122             },
123             close: function () {
124                 $("div.hi-dialog-box").hide();
125             }
126         }
127     </script>
128     <script type="text/javascript">
129         function click1() {
130             hiDialog.init("系统提示！", "测试", function () {
131                 //点击确定后的回调执行
132                 $(".messg").text("点击了确定");
133             });
134         }
135 
136         function click2() {
137             hiDialog.init("系统对话框~~", "什么乱七八糟的啊...", function () {
138                 $(".messg").text("点击了确定~~~");
139             }, function () {
140                 $(".messg").text("点击了取消~~");
141             });
142         }
143     </script>
144 </body>
145 </html>

View Code
 
消息框
要求：自动定时关闭消息框、有消息分类（如：警告、错误、成功等）

画一个简单的模型框


<div class="hi-message-box">
        <img class="hi-message-type" src="" />
        <span class="hi-message-messg">你不爱我了~~</span>
    </div>

 

添上基本样式


<style type="text/css">
        div.hi-message-box {
            padding: 10px;
            padding-top: 15px;
            padding-bottom: 20px;
            background-color: #aee0c1;         
            min-width: 200px;
            max-width: 500px;
            font-size: 19px;
            border-radius: 3px;
        }
 </style>

 
效果图：

看上去是不是很简单呢？下面我们给它加上定时关闭消息功能。

定时关闭消息（表骂我，就是这么简单。我也想写复杂的。）


 setTimeout(function () {
            $("div.hi-message-box").fadeOut("slow");
}, 1200);

 
效果图：


加上消息类型（其实就是根据参数加不同的图片而已）


 setTimeout(function () {
            $("div.hi-message-box").fadeOut("slow");
        }, 1200);
  var $box = $("div.hi-message-box");
  $box.find("img.hi-message-type").attr("src", "imgs/Warning_24px.png")

 
 效果图：

加上图标是不是更像那么回事了？
如上，我们同样需要稍微整理下实现代码：

效果图：

全部代码：（同样，消息框也只是进行了简单实现。还有太多没有考虑，如（参数定位消息框位置、设置定时关闭时间、多次触发消息框））


 1 <!DOCTYPE html>
 2 <html xmlns="http://www.w3.org/1999/xhtml">
 3 <head>
 4     <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 5     <title></title>
 6     <style type="text/css">
 7         * {
 8             box-sizing: border-box;
 9         }
10 
11         .clearfix:after {
12             content: ' ';
13             display: table;
14             clear: both;
15         }
16 
17         .clearfix {
18             *zoom: 1;
19         }
20 
21         div.hi-message-box {
22             padding: 10px;
23             padding-top: 15px;
24             padding-bottom: 20px;
25             background-color: #aee0c1;
26             position: absolute;
27             min-width: 200px;
28             max-width: 500px;
29             font-size: 19px;
30             border-radius: 3px;
31             top:200px;
32             left:45%;
33         }
34 
35             div.hi-message-box img {
36                 vertical-align: bottom;
37             }
38     </style>
39 </head>
40 <body>
41     <input type="button" onclick="success();" value="成功消息" />
42     <input type="button" onclick="error();" value="失败消息" />
43     <input type="button" onclick="warn();" value="警告消息" />
44     <script src="../../Scripts/jquery-1.8.2.js"></script>
45     <script type="text/javascript">
46         var hiMessageBox = {
47             init: function (type, messg) {
48                 var hiMessageBox = '<div class="hi-message-box">\
49                                     <img class="hi-message-type" src="" />\
50                                     <span class="hi-message-messg"></span>\
51                                 </div>';
52 
53 
54                 if (!$("div.hi-message-box").length) {
55                     $("body").append(hiMessageBox);
56                 }
57                 var $box = $("div.hi-message-box");
58                 $box.find(".hi-message-messg").text(messg);
59                 switch (type) {
60                     case 0://success 成功
61                         $box.find("img.hi-message-type").attr("src", "imgs/Tick_24px.png")
62                         break;
63                     case 1://warn 警告
64                         $box.find("img.hi-message-type").attr("src", "imgs/Warning_24px.png")
65                         break;
66                     case 2://
67                         $box.find("img.hi-message-type").attr("src", "imgs/Delete_24px.png")
68                         break;
69                 }
70                 $("div.hi-message-box").fadeIn("slow")
71                 setTimeout(function () {
72                     $("div.hi-message-box").fadeOut("slow");
73                 }, 1200);
74             },
75             success: function (messg) {
76                 this.init(0, messg); 
77             },
78             warn: function (messg) {
79                 this.init(1, messg);
80             },
81             error: function (messg) {
82                 this.init(2, messg);
83             }
84         };      
85     </script>
86     <script type="text/javascript">
87         function success() {
88             hiMessageBox.success("成功");
89         }
90         function error() {
91             hiMessageBox.error("失败");
92         }
93         function warn() {
94             hiMessageBox.warn("警告");
95         }
96     </script>
97 </body>
98 </html>

View Code
 
演示地址：对话框演示地址  消息框演示地址
 

《一步步搭建自己的博客》
关于简单实现自己的对话框和消息框就到这里了。感谢您的阅读，希望对您有一点点作用。
文章首链：http://www.cnblogs.com/zhaopei/p/MessageBox_DialogBox.html

 
article  31
title: 你知道C#中的Lambda表达式的演化过程吗？
body: 
那得从很久很久以前说起了，记得那个时候...
懵懂的记得从前有个叫委托的东西是那么的高深难懂。
委托的使用
例一：

什么是委托？
个人理解：用来传递方法的类型。（用来传递数字的类型有int、float、double，用来传递方法的就有委托）
例二：

又经过了很久很久...
匿名方法
很多时候委托接收的方法是一次性的或者方法体是非常简单的...
例三：

我们可以写成：

有没有发现我们每次都要定义委托，很多时候签名可能是一样的。这样就没有必要定义重复的。
然后又过了很久很久...
Func和Action
可能老大也觉得我们每次定义委托有点傻，所以干脆在框架内一次定义好所有可能用到的委托。那千变万化的方法签名怎么可能定义得全？没关系，定义成泛型的不就可以了吗。
先说Func：

细心的朋友可能看到了，Func相对于AddDelegate多定义了一个int。多出了的那个是指的是返回类型。我们F12看对应的定义：

关于上面Func的写法我们可以简写成：（语法糖而已，编译后还是注释的代码）

再看Action：

提醒：以后如果我们写代码的时候如果写到到delegate...，你要马上想到是否可以用Func或者Action来代替呢？C#4中的Action和Func有16个参数，足够你用了。
我们等了又等，又过了好久好久...
Lambda的诞生

我XX，这TM就是亲兄弟啊。直接去掉delegate关键字，然后加一个=>就成了lambda表达式了。（=>读作goes to）
我们继续简化：

丢掉参数类型也是可以的，因为强大的VS可以根据泛型委托Func自己推断出来参数类型。
还可以简化吗？当然：

return关键字也不要了，大括号也不要了。（当然，方法体只有单条语句才能怎么做）
现在看起来已经非常接近我们平时用的Lambda表达式了。
如果传入参数只有一个的话，我们还可以继续简化：

这就是我们平时见得最多的lambda长相了。
要长成这样也是有要求的：

只能有一个传入参数
方法体只能只一条语句。

关于第1点，lambda我们平时用得较多的是基于IEnumerable或IQueryable，所以只能有一个参数也就满足了。
关于第2点，我们使用扩展方法的链式编程来解决。
如：（用链式来解决第二点）

从此，我们过上了幸福的生活...
 
借《深入理解C#》中的一图：

 
小知识：（异步Lambda）

Func<Student, Task<bool>> func = async t =>
{
    await Task.Delay(100);//等待100毫秒
    return false;
};

 
结束：
本文简短的说了下lambda表达式在C#中的一步步演化。说的不一定对，轻拍！
本文以同步至《C#基础知识巩固系列》
article  32
title: 一步步开发自己的博客 .NET版（9、从model first替换成code first 问题记录）
body: 
为什么要改用code first
用过code first的基本上都不会再想用回model first或是db first（谁用谁知道）。不要问我为什么不一开始就直接使用code first，因为那个时候我还不会（甚至还把model first当成了code first）。
因为工作中使用的就是code first，且越用越习惯，越用越喜欢。
原因如果：

再也用为每次生成那个笨重的edmx文件性急了
再也不用当心保存tt文件而丢失特性、注销、扩展方法了
再也不用为了使用微软的验证插件非得写Metadata文件了
再也不用为了扩展tt文件生成的实体类去写（partial）部分类了。
再也不用为了生成满足自己需要的实体而去修改那些坑爹的tt文件里面的语法代码了（如：默认每个实体继承一个父类）
再也不用为了查找edmx文件打不开，去编辑庞大的edmx文件中找那些坑爹的错误了。
等等还有些暂时没想到的....

说改就改
修改前实体：db first（由tt文件生成）

修改后实体：code first（完全手写）

然后把实体更新到数据库对应的表结构。执行命令Enable-Migrations
遇到问题：

 The EntityFramework package is not installed on project ''.（原因：因为没有选择“默认项目”）
继续问题：
 
 The project 'Blogs.Model' failed to build.（原因：没有建一个继承于DbContext的类）
 
 ok，提示已经启用迁移。
然后我们执行命令：Add-Migration blogs

异常： 从数据库中获取提供程序信息时出错。这可能是 Entity Framework 使用的连接字符串不正确导致的。有关详细信息，请查看内部异常并确保连接字符串正确。
我的乖乖，我非常确定我们字符串链接是正确的啊。
最后确定忘记给数据连接上下文在构造函数中传入配置文件的数据库链接名。


  public BlogDbContext()
            : base("HiBlogsTest")
        {
        }

 
再执行（Add-Migration blogs），再出错：
 
 异常：无法加载指定的元数据资源。（百度之，原来是链接字符串有问题。http://www.cnblogs.com/chengxiaohui/articles/2106765.html）

 <add name="HiBlogsTest" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=System.Data.SqlClient;
         provider connection string=&quot;
         data source=.;
         initial catalog=HiBlogsTest;
         user id=sa;
         password=123qwe;
         MultipleActiveResultSets=True;
         App=EntityFramework&quot;" providerName="System.Data.EntityClient" />

 
改成：（那一堆csdl、ssdl、msl什么都不要了，就留个简单的链接。干净）

<add name="HiBlogsTest" connectionString="Data Source=.;Initial Catalog=HiBlogsTest;User ID=sa;Password=123qwe;" providerName="System.Data.SqlClient" />

 
ok，终于没有看见红色的字了。

且看到了一个自动生成的blogs文件。且不管，看看数据库是否有表结构。

空空如也。（屁都没看到一个）（原因：BlogDbContext上下文中没有添加实体，没有告诉程序要生成哪些实体到数据库）
给BlogDbContext类添加数据代码：

  public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        }       
        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

 
然后执行 ：Add-Migration blogs 再执行 update-database

终于看到表数据了。
有了表还不行，我们还没有主外键。
修改BlogDbContext如下:


public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        } 
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            var entityBlogUser = modelBuilder.Entity<BlogUser>();

            entityBlogUser.HasMany(p => p.BlogInfos).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")); 
          
            entityBlogUser.HasRequired(p => p.BlogUserInfo).WithRequiredPrincipal(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")); 

            entityBlogUser.HasMany(p => p.BlogTags).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            entityBlogUser.HasMany(p => p.BlogTypes).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            entityBlogUser.HasMany(p => p.BlogComments).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId"));

            var entityBlogInfo = modelBuilder.Entity<BlogInfo>();

            entityBlogInfo.HasMany(p => p.BlogTags).WithMany(t => t.BlogInfos)
           .Map(m => m.ToTable("BlogInfo_BlogTag"));

            entityBlogInfo.HasMany(p => p.BlogTypes).WithMany(t => t.BlogInfos)
            .Map(m => m.ToTable("BlogInfo_BlogType"));

            entityBlogInfo.HasMany(p => p.BlogComments).WithRequired(t => t.BlogInfo)
              .Map(m => m.MapKey("BlogInfoId"));

            entityBlogInfo.HasMany(p => p.BlogReadInfos).WithRequired(t => t.BlogInfo)
             .Map(m => m.MapKey("BlogInfoId")); 
        }


        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

View Code
 
然后重新命令：Add-Migration blogs 再执行 update-database

又见错误：
将 FOREIGN KEY 约束 'FK_dbo.BlogInfo_dbo.BlogUser_BlogUserId' 引入表 'BlogInfo' 可能会导致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。无法创建约束。请参阅前面的错误消息。
于是，一个一个的外键删掉，又一个个的来建。终于发现：（下图是数据库关系图，mssql生成的）

百度之:(原来是为了约束联级删除数据做的约束。实在话，还没玩过联级删除了，说明这个需求应该不是很常用。找个方法禁用可否？)
直接加一个.WillCascadeOnDelete(false)就可以了。（http://www.cnblogs.com/chear/archive/2012/11/09/2762145.html）


public class BlogDbContext : DbContext
    {
        public BlogDbContext()
            : base("HiBlogsTest")
        {
        } 
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            var entityBlogUser = modelBuilder.Entity<BlogUser>();

            entityBlogUser.HasMany(p => p.BlogInfos).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //与上面等效
            //modelBuilder.Entity<BlogInfo>().HasRequired(p => p.BlogUser).WithMany(t => t.BlogInfos)  

            //以BlogUser为主表（BlogUserInfo为从表，建立外键）
            entityBlogUser.HasRequired(p => p.BlogUserInfo).WithRequiredPrincipal(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //等效于HasRequired(p => ).WithOptional(i => );

            ////以BlogUserInfo为主表（BlogUser为从表，建立外键）
            //modelBuilder.Entity<BlogUser>().HasRequired(p => p.BlogUserInfo).WithRequiredDependent(t => t.BlogUser) 
            //.Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);
            //等效于 HasOptional(p => ).WithRequired(i => ); 

            entityBlogUser.HasMany(p => p.BlogTags).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            entityBlogUser.HasMany(p => p.BlogTypes).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            entityBlogUser.HasMany(p => p.BlogComments).WithRequired(t => t.BlogUser)
            .Map(m => m.MapKey("BlogUserId")).WillCascadeOnDelete(false);

            var entityBlogInfo = modelBuilder.Entity<BlogInfo>();

            entityBlogInfo.HasMany(p => p.BlogTags).WithMany(t => t.BlogInfos)
           .Map(m => m.ToTable("BlogInfo_BlogTag"));

            entityBlogInfo.HasMany(p => p.BlogTypes).WithMany(t => t.BlogInfos)
            .Map(m => m.ToTable("BlogInfo_BlogType"));

            entityBlogInfo.HasMany(p => p.BlogComments).WithRequired(t => t.BlogInfo)
              .Map(m => m.MapKey("BlogInfoId")).WillCascadeOnDelete(false);

            entityBlogInfo.HasMany(p => p.BlogReadInfos).WithRequired(t => t.BlogInfo)
             .Map(m => m.MapKey("BlogInfoId")).WillCascadeOnDelete(false); 
        }


        public DbSet<BlogInfo> BlogInfos { get; set; }
        public DbSet<BlogComment> BlogComments { get; set; }
        public DbSet<BlogReadInfo> BlogReadInfos { get; set; }
        public DbSet<BlogTag> BlogTags { get; set; }
        public DbSet<BlogType> BlogTypes { get; set; }
        public DbSet<BlogUser> BlogUsers { get; set; }
        public DbSet<BlogUserInfo> BlogUserInfos { get; set; }
    }

View Code
 
然后重新命令：Add-Migration blogs 再执行 update-database

完美，表结构过来了。表关系过来了。（接下来就是该代码了，因为表名做了小的改动，字段也做了少许调整所以改的东西还真不少。整整改了一天时间。）
现在回过头来想想，之前是先model first之后小许改动就用的db first。以前怎么没有遇到过（将 FOREIGN KEY 约束 'FK_dbo.BlogInfo_dbo.BlogUser_BlogUserId' 引入表 'BlogInfo' 可能会导致循环或多重级联路径。请指定 ON DELETE NO ACTION 或 ON UPDATE NO ACTION，或修改其他 FOREIGN KEY 约束。无法创建约束。请参阅前面的错误消息。）这个错误。好奇心驱使，觉得看看以前的代码的edmx是怎么管理这种关系的。

很惊奇的发现，完全没有问题。于是，不死心看看数据库里面是不是有什么蹊跷。


搜噶，原来如此。通过model first生成的主外键关系默认就没有设计联级删除，而code first默认设置就是联级删除。
 

以上内容，都是我胡说八道。谢谢您的阅读，希望对您有那么一点点作用。
Hi-Blogs源码地址：http://git.oschina.net/zhaopeiym/Hi-Blogs
最近因为工作实在太慢，开源博客长久没有更新。今天突然来回翻了好几遍，发现半年前的自己写的代码是如此的不堪入目。
今天仅仅只是把db first改成了code first，发霉的代码我还得找个时间好好重构重构。
首发地址：http://www.cnblogs.com/zhaopei/p/5540532.html 

 
article  33
title: 一步步学习javascript基础篇（6）：函数表达式之【闭包】
body: 
 
回顾前面介绍过的三种定义函数方式
1. function sum (num1, num2) { return num1 + num2; }  //函数声明语法定义
2. var sum = function(num1, num2){ return num1 + num2; }; //函数表达式定义 
3. var sum = new Function("num1", "num2", "return num1 + num2"); //Function 构造函数 
 
在分析闭包之前我们先来看看，定义和调用函数容易犯的错误。
例1：

sayHi(); //错误：函数还不存在
var sayHi = function () {
    alert("test");
};

例2：

if (true) {
    function sayHi() {
        alert("1");
    }
} else {
    function sayHi() {
        alert("2");
    }
}
sayHi();//打印结果并不是我们想要的

例3：

var fun1 = function fun2() {
    alert("test");
}
fun2();//错误：函数还不存在

在例1中，我们不能在使用函数声明式语法定义之前调用函数。解决方案：
1.如果使用函数表达式定义函数的话，需要在表达式定义后调用。

var sayHi = function () {
    alert("test");
};
sayHi()

2.使用函数声明式。（这里浏览器引擎会函数声明提升,在所有代码执行之前先读取函数声明）

sayHi(); 
function sayHi () {
    alert("test");
};

在例2中，我们预期的结果应该是打印1，实际结果是打印2。
if (true) {
    function sayHi() {
      alert("1");
    }
    } else {
    function sayHi() {
      alert("2");
    }
}
sayHi();//打印结果并不是我们想要的

     
为什么会这样？正因为函数声明提升，所以浏览器在预解析的时候不会判断if条件，直接解析第二个函数定义的时候覆盖了第一个。
解决方案：
var sayHi;
if (true) {
    sayHi = function () {
      alert("1");
    }
    } else {
    sayHi = function () {
      alert("2");
    }
}
sayHi();

     
在例3中，发现只能只用fun1()调用，而不能使用fun2()调用。
我自己的理解，真正原因不知道。没找到资料。 
因为1： function fun3() { }; 等效与 var fun3 = function fun3() { }; 如图：

所以只能只用fun1()调用，而不能使用fun2()调用。
其实这里我还是有疑问的？哪位大神知道，望告知。
既然，fun2在外面不能调用为什么在函数内部能调用？虽然在debugger还是得不到fun1。

 
好了，通过上面的三道题目热身。我们继续今天的主题“闭包”。
1.什么是闭包？
定义：就是有权访问另一个函数作用域的变量的函数
我们先从一个示例函数开始：
例1：

function fun() {
    var a = "张三";
}
fun();//在我们执行完后，变量a就被标记为销毁了

例2：

function fun() {
    var a = "张三";
    return function () {
        alert("test");
    }
}
var f = fun();//同样，在我们执行完后，变量a就被标记为销毁了

例3：

function fun() {
    var a = "张三";
    return function () {
        alert(a);
    }
}
var f = fun();//【现在情况发生变化了，如果a被销毁，显然f被调用的话就不能访问到变量a的值了】
f();//【然后变量a的值正常的被访问到了】
//这就是闭包，当函数A 返回的函数B 里面使用到了函数A的变量，那么函数B就使用了闭包。

示例：
function fun() {
    var a = "张三";
    return function () {
     alert(a);
    }
}
var f = fun();//【现在情况发生变化了，如果a被销毁，显然f被调用的话就不能访问到变量a的值了】
f();//【然后变量a的值正常的被访问到了】

     
显然，滥用闭包会增大内存的使用。所以非特殊情况尽量不要使用闭包。如果用到了，记得手动设置空引用，内存才能被回收 f = null; 
图解：（不了解作用域链的同学请先看前面的文章作用域和作用域链）

补充：例4：（闭包的实例应用）

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title></title>
    <style type="text/css">
        .tempBut {
            display: none;
        }
    </style>
</head>
<body>
    <div class="mydiv">
        <input value="but" type="button" class="tempBut" />
    </div>
    <script src="Scripts/jquery-1.8.2.js"></script>
    <script type="text/javascript">
      
        for (var i = 0; i < 10; i++) {
            var tempHtml = $(".tempBut").clone().removeClass("tempBut"); 
            //tempHtml.click(function (i) {
            //    alert(i);//怎样打印 0 到 9
            //});
            (function (num) {//使用闭包传值
                tempHtml.click(function () {
                    alert(num);
                });
            })(i);
            $(".mydiv").append(tempHtml);
        }
    </script>
</body>
</html>

 
 
2.什么是匿名函数？(仅仅只是解释这个概念)
如：（即，没有名字的函数）
 
 
关于对象中函数的返回值是匿名函数时，this的怪异现象 
讲解之前，先清醒下头脑，不要越看越迷糊了。如果迷糊了，那就直接忽略下面的。

var name1 = "张三";
var obj = {
    name1: "李四",            
    fun2: function () {
        alert(this.name1);
    },
    fun3: function () {
        return function () {
            alert(this.name1);
        }
    }
}
obj.fun2();//打印结果"李四"意料之中的。
obj.fun3()();//因为这里返回的是一个函数，所以要再加一对()来调用。打印结果是"张三"，意料之外。
//真是百事不得其解啊，什么this指向了全局？

我们前面讲过“哪个对象点出来的方法，this就是哪个对象”，那我们的 obj.fun3()() 打印的是“张三”也就是说this执行了全局作用域。
我们看看下面的示例也许就知道为什么了。

var name1 = "张三";
var obj = {
    name1: "李四",            
    fun2: function () {
        alert(this.name1);
    },
    fun3: function () {
        return function () {
            alert(this.name1);
        }
    }
}       
//obj.fun3()();
var obj2 = {};
obj2.name1 = "test";
obj2.fun = obj.fun3();
obj2.fun();//打印结果"test",再次证明了“哪个对象点出来的方法，this就是哪个对象”.

var name1 = "张三";
var obj = {
    name1: "李四",
    fun2: function () {
      alert(this.name1);
    },
    fun3: function () {
        return function () {
          alert(this.name1);
        }
    }
}
//obj.fun3()();
var obj2 = {};
obj2.name1 = "test";
obj2.fun = obj.fun3();
obj2.fun();//打印结果"test",再次证明了“哪个对象点出来的方法，this就是哪个对象”.

     
我们来分解下 obj.fun3()() 先是 obj.fun3() 返回一个匿名函数到了window作用域，然后接着调用this就指向了window了。（感觉解释有点勉强，也不知道对不，暂时自己先是这么理解的） 
 
 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/519.html
本文已同步至目录索引：一步步学习javascript
欢迎对个人博客感兴趣的道友加入群：【嗨-博客】469075305 入群须知

 
article  34
title: 一步步学习javascript基础篇（7）：BOM和DOM
body: 
一、什么是BOM、什么是DOM
BOM即浏览器对象模型，主要用了访问一些和网页无关的浏览器功能。如：window、location、navigator、screen、history等对象。
DOM即文档对象模型，针对HTML（或XML）文档的API（应用程序编程接口）。描绘的一个层次化的节点树，开发人员可以添加、修改和删除页面的某一部分。
二、细说BOM对象
1、window对象
window对象表示浏览器的一个实例，同时也是ECMAScript 规定的 Global 对象。（Global ：所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。在浏览器中Global对象实际上就是window对象实现的 ）全局作用域(所有全局对象都可以通过window来访问)

var str = "张三";
function fun() {
    alert(str);
}
//全局对象都可以通过window的属性方式来访问
alert(window.str);
window.fun(); 

弹出窗口

window.open("http://www.baidu.com", "NewWin", "height=400,width=400");

第三个参数还可能有的值如： 

超时调用和间歇调用（setTimeout、setInterval）
我们都知道javascript是单线程的，但我们可以通过间歇调用和超时调用在特定时间执行指定的代码。

超时调用（setTimeout）

如： setTimeout(function() { alert("Hello world!"); }, 1000);//会在1000毫秒后执行 

如果在超时时间之前想要取消执行，我们可以


//设置超时调用
var timeoutId = setTimeout(function() {
 alert("Hello world!");
}, 1000);
//注意：把它取消
clearTimeout(timeoutId);


同样我们也可以通过超时调用模拟实现间歇调用


function fun() {
    //....这里可以实现某些逻辑
    setTimeout(fun(), 100);
}
fun();

当然通过模拟的间歇调用和实际的setInterval还是有区别的，下面我们会分析。

间歇调用（setInterval）


setInterval (function() {
 alert("Hello world!");
}, 1000);//每隔1秒 执行一遍


如果想要取消执行，我们可以


var i = 1;
var timeId = setInterval(function () {
    i++;    //...这里可以执行某些逻辑
    if (i >= 100) {
        clearInterval(timeId);//注意和取消超时调用不一样（clearTimeout）
    }
}, 1000);//每隔1秒 执行一遍

我们仔细看看上面的代码，如果说执行逻辑的部分的运行时间超过了间隔时间（1000毫秒）会是什么情况。这里我们需要谨记javascript是单线程的。不能说到了1000又开启一个进程来执行循环，上一个进程接着执行正在运行的逻辑。而是到了1000毫秒后直接断开了正在执行的逻辑部分，开始执行下一次的调用。当然这肯定不是我们想要看到的情况。所以，我们可以使用上面的setTimeout模拟的间歇调用，这样就是调用是中间逻辑执行时间不算，等到执行完成后，再等待间隔时间接着执行下一次调用。（所以，在实际开发中，我们也是建议使用setTimeout来模拟间歇调用的）
2、location对象
location对象说来也是奇怪，它既是window的属性也是document属性，且同时指向了同一个对象。
window和document的关系：浏览器中的html成为了document对象，使我们可以通过javascript来访问、操作html的元素。且，documnet对象是window对象的一部分，可以通过window.document属性来访问。
我们来看看location都有哪些属性：

有了上面这些属性，我们可以非常方便的修改url，如：

//假设初始 URL 为 http://www.wrox.com/WileyCDA/
//将 URL 修改为 "http://www.wrox.com/WileyCDA/#section1"
location.hash = "#section1";
//将 URL 修改为 "http://www.wrox.com/WileyCDA/?q=javascript"
location.search = "?q=javascript";
//将 URL 修改为 "http://www.yahoo.com/WileyCDA/"
location.hostname = "www.yahoo.com";
//将 URL 修改为 "http://www.yahoo.com/mydir/"
location.pathname = "mydir";
//将 URL 修改为 "http://www.yahoo.com:8080/WileyCDA/"
location.port = 8080;


每次修改 location 的属性（ hash 除外），页面都会以新 URL 重新加载。也就是说，浏览器会生成一天后退的历史记录。如果我们不想能够回退可以使用replace（）方法，如：
 location.replace("http://www.baidu.com"); 如此就不会有回退记录了。
除了replace方法外还有个比较重要的方法。reload，用来刷新。

location.reload(); //重新加载（有可能从缓存中加载）
location.reload(true); //重新加载（从服务器重新加载）也就是强制刷新

3、navigator对象、screen对象
navigator对象主要用来识别客户端浏览器，但是由于各类浏览器对navigator对象的实现各有不同，这里就不细分析了。
screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每种浏览器对其的支持程度也是不同的，这里也不分析了。
5、history对象
history对象主要保存当前也网页的历史记录。但出于安全考虑，程序员不能够知道详细的url。我们可以得到或操作如下：

history.length//历史记录的数量


//后退一页
history.back();
//前进一页
history.forward();


//后退一页
history.go(-1);
//前进一页
history.go(1);
//前进两页
history.go(2);


//跳转到最近的 wrox.com 页面
history.go("wrox.com");
//那么可能是前进也可能是后退，如果历史记录中不存在worx.com那么这个方法什么也不会做

 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://www.cnblogs.com/zhaopei/p/5080108.html
本文已同步至目录索引：一步步学习javascript

article  35
title: 三、依赖注入是什么？
body: 
 
接口
在说依赖注入之前，先了解下什么是接口。
我们在学编程的时候都知道，接口的相关规则：（来源百度百科）

1. 接口是一个引用类型，通过接口可以实现多重继承。
2. C#中接口的成员不能有new、public、protected、internal、private等修饰符。
3. 接口中只能声明"抽象"成员（所以不能直接下一步对接口进行实例化（即不能使用new操作符声明一个接口的实例对 象）），而不能声明共有的域或者私有的成员变量。
4. 接口声明不包括数据成员，只能包含方法、属性、事件、索引等成员。
5. 接口名称一般都以“I”作为首字母（当然不这样声明也可以），这也是接口和类的一个区别之一。
6. 接口成员的访问级别是默认的（默认为public），所以在声明时不能再为接口成员指定任何访问修饰符，否则 编译器会报错。
7. 接口成员不能有static、abstract、override、virtual修饰符，使用new修饰符不会报错，但会给出警告说不需要关键字new。
8. 在声明接口成员的时候，不准为接口成员编写具体的可执行代码，也就是说，只要在对接口进行声明时指明接口的成员名称和参数就可以了。
9. 接口一旦被实现，实现类必须实现接口中的所有成员，除非实现类本身是抽象类（通过具体的可执行代码实现接口抽象成员的操作）。

                                                                                                                            
很多时候看到这么多的概念，也是云里雾里的。项目中的接口使用也是按照老代码依葫芦画瓢。如果是自己练手的代码或者demo，也是没有使用接口。（给自己的借口就是，我只是做些小的东西，根本就不需要使用接口一样可以跑很溜啊。）
 
接口是什么？（说说我自己的理解，不一定对）
接口就是为了更换一个可能过时或者错误的实现而准备的。就想我们的电脑，里面就到处都是接口。usb、内存条、硬盘、电池、键盘...等等都是有各自的接口。我们可以通过硬盘接口换个更大的硬盘或者换个更快的固态硬盘。如果键盘坏了，也可以通过键盘接口买个新的键盘换上去。这就是接口明显的好处。接口也可以理解成大家的约定。约定了特定接口的大小功能等等。
 
那么我们写代码也是一样，在某些地方可能会经常变动，逻辑会经常修改的地方使用接口约定。下面我们就用硬盘的接口来做示例吧。
首先定义一个硬盘接口。（一个name属性，一个读一个写的方法）

/// <summary>
/// 硬盘接口
/// </summary>
interface IHardDisk
{
    /// <summary>
    /// 硬盘的名字属性
    /// </summary>
    string name { get; }
    /// <summary>
    /// 读取数据方法
    /// </summary>
    void read();
    /// <summary>
    /// 写数据
    /// </summary>
    void write(string str);
}

然后我们买了一个200G的硬盘，它实现了上面的接口。

public class HardDisk200 : IHardDisk
{
    public string name
    {
        get
        {
            return "我是200G硬盘";
        }
    }

    public void read()
    {
        Console.WriteLine("我可以写入数据哦....");
    }

    public void write(string str)
    {
        Console.WriteLine(str);
    }

}

在电脑中使用这个硬盘。

static void Main(string[] args)
{
    //这里的h就是一个插在接口上的设备
    IHardDisk h = new HardDisk200();
    h.read();
    h.write(h.name + "，我可以写入数据哦");


    Console.ReadKey();
}

 
某天，我们发现这个硬盘太小了，需要换个1T的。（那样我们可以存很多很多的电影>_<），那么买吧。

public class HardDisk1T : IHardDisk
{
    public string name
    {
        get
        {
            return "我是1T硬盘";
        }
    } 
    public void read()
    {
        Console.WriteLine("我可以写入数据哦....");
    } 
    public void write(string str)
    {
        Console.WriteLine(str);
    }
}

然后怎么使用了？只要在电脑上的接口直接插上新的硬盘就ok了，其他的什么地方都不用改。


 
这就是使用接口的好处。当某天我们发现电脑太慢了，我们可以买个固态硬盘，直接在接口使用的地方换上就可以了，其他地方完全不用修改。

这样，我们就可以在不同时期或不同情况下灵活更换继承实现了接口的任何对象，而不用修改其它地方的代码。
又或者说，实现了这个接口的设备就是存储设备。（它一定有存也一定可以储，也就是一定可以写入和读出数据。）
 
依赖注入
在我们了解了什么是接口之后，我们接着来说说今天主要的主题吧。
还是先从例子入手，且是我们学过编程都知道的例子，三层。（什么？你不知道什么是三层？那你别看了，先补习了再过来）
我们先来写个简单的三层伪代码。
DAL：

 public class DALMsSqlHelper
 {
     public int add(string str)
     {
         //...省略具体实现
         return 1;
     }
     //...省略具体实现,如修改 删除 查询
 }

BLL:

public class BLLAddStudent
{
    DALMsSqlHelper mssql = null;
    public BLLAddStudent()
    {
        mssql = new DALMsSqlHelper();
    }
    public int addStudent()
    {
        string str = "";  //...省略具体实现
        return mssql.add(str);
    }
}

UI:

 public class UI
 {
     BLLAddStudent s = new BLLAddStudent();
     public UI()
     {
         s.addStudent();
     }
 }

应该说简单得不能在简单的三层。
就在系统用了一年之后，老板说：”听说oracle很牛逼，大公司都是用的oracle。咱们也换上吧。“。 好，那就换吧。
DAL：

public class DALOracleSqlHelper
{
    public int addOracle(string str)
    {
        //...省略具体实现
        return 1;
    }
    //...省略具体实现,如修改 删除 查询
}

显然BLL也要进行修改，因为BLL引用了DAL的查询类。
BLL：

public class BLLAddStudent
{
    DALOracleSqlHelper mssql = null;
    public BLLAddStudent()
    {
        mssql = new DALOracleSqlHelper();
    }
    public int addStudent()
    {
        string str = "";  //...省略具体实现
        return mssql.addOracle(str);
    }
}

不就换个数据库吗？为何修改这么大，要是老板哪天又要换回oracle怎么办？这得好好想个办法。
首先，我们定义一个数据访问的接口。

public interface ISqlHelper
{
    int add();
    //...省略具体实现,如修改 删除 查询
 }

DAL修改如下：

public class DALMsSqlHelper : ISqlHelper
{
    public int add(string str)
    {
        //...省略具体实现
        return 1;
    }
    //...省略具体实现,如修改 删除 查询
}

public class DALOracleSqlHelper : ISqlHelper
{
    public int addOracle(string str)
    {
        //...省略具体实现
        return 1;
    }
    //...省略具体实现,如修改 删除 查询

    public int add(string str)
    {
        //...省略具体实现
        return 1;
    }
}

BLL：

 public class BLLAddStudent
 {
     ISqlHelper mssql = null;
     public BLLAddStudent(ISqlHelper sqlhelper)
     {
         mssql = sqlhelper;
     }
     public int addStudent()
     {
         string str = "";  //...省略具体实现
         return mssql.add(str);
     }
 }

UI：

public class UI
{       
    public UI()
    {
        ISqlHelper sqlhelper = new DALOracleSqlHelper();
        BLLAddStudent s = new BLLAddStudent(sqlhelper);
        s.addStudent();
    }
}

如果哪天老板又要换会mssql怎样办。那么仅仅只要修改UI
 
又过一年之后，因为公司不景气。所以又来需求了。老板：”唉，算了。我们还是用mysql吧。免费的，为公司节省点“。那么我们又要修改了。
首先需要重新写个mysql的实现。
DAL：

public class DALMySqlHelper : ISqlHelper
{
    public int add(string str)
    {
        //...省略具体实现
        return 1;
    }
    //...省略具体实现,如修改 删除 查询
}

UI实现如下：

public class UI
{       
    public UI()
    {
        ISqlHelper sqlhelper = new DALMySqlHelper();
        BLLAddStudent s = new BLLAddStudent(sqlhelper);
        s.addStudent();
    }
}

我们有没有发现。我们只是在DAL新增了一个mysql的实现和修改了下UI层的接口构造。其中BLL我们根本就没有动它的。
是的，这样我们就可以说这里的UI对于BLL来说就是”依赖注入“，BLL对于UI来说就是”控制反转“。所以，我觉得依赖注入和控制反转是同一个概念，只是立场不同。
 
上面，我们看到了虽然BLL层已经不需要变动就可以新增一个数据源的访问。那么我们能不能也不修改UI层呢？
这里就可以用到我们上篇讲的反射了。

 
然后，不管老板想怎么折腾，我只需要改改配置文件就可以了。甚至都不用动代码。（如果需要新增一个数据源操作，也只要重新实现下，然后改改配置文件）。
 
本文以同步至《C#基础知识巩固系列》
article  36
title: 无限分级和tree结构数据增删改【提供Demo下载】
body: 
无限分级
很多时候我们不确定等级关系的层级，这个时候就需要用到无限分级了。
说到无限分级，又要扯到递归调用了。（据说频繁递归是很耗性能的），在此我们需要先设计好表机构，用来存储无限分级的数据。当然，以下都是自己捣鼓的结果，非标准。谁有更好的设计望不吝啬赐教。
说来其实也简单，就是一个ID和父ID的关系。

以此类推，Id需要是唯一的，ParenId需要是Id列里面存在即可。这样我们就实现无限分级了，如果再加一列Sort排序就更完美了。
jstree插件
官方地址：https://www.jstree.com/
为什么要用这个插件？因为有方便的api给我们做数据绑定，且支持节点拖动来实现增删改，个人觉得这个功能挺强大的。
Demo
下面我们来基于jstree插件来实现无限分级数据操作。以区域数据操作为例，用Code First的方式来编写demo代码。

创建Region实体
为了配合插件自动生成的节点id，我们这里使用的Node和ParentNode来存储上下级关系（而不是上面说的id和parentid，但是实际效果是一样的）。

/// <summary>
/// 区域
/// </summary>
public class Region
{
    /// <summary>
    /// 主键id
    /// </summary>
    public int Id { get; set; }
    /// <summary>
    /// 名称
    /// </summary>
    public string Name { get; set; }
    /// <summary>
    /// 节点
    /// </summary>
    public string Node { get; set; }
    /// <summary>
    /// 父节点
    /// </summary>
    public string ParentNode { get; set; }

}

 
满足jstree插件的数据对象Dto
为了适应jstree插件的数据要求，我们需要把上面的数据转换成树状的数据对象。 


/// <summary>
/// Dto
/// </summary>
public class RegionsTreeOutput
{
    /// <summary>
    /// Id
    /// </summary>
    public int RegionsId { get; set; }
    /// <summary>
    /// tree显示文本（对应region的name）
    /// </summary>
    public string text { get; set; }
    /// <summary>
    /// tree的id（对应Node）
    /// </summary>
    public string id { get; set; }      
    /// <summary>
    /// 子节点数据（此属性就体现的数据的层级关系）
    /// </summary>
    public List<RegionsTreeOutput> children { get; set; }
}

View Code
 
数据转换


  #region GetRegionTree 初始化数据获取 的辅助方法
        public RegionsTreeOutput LoadRegions(string id, List<Region> inRegions, RegionsTreeOutput outRegions)
        {

            List<Region> regions = inRegions.Where(t => t.ParentNode == id).ToList();
            if (outRegions == null)//加载父节点
            {
                outRegions = ToTreeData(regions[0]);
                LoadRegions(outRegions.id, inRegions, outRegions);
            }
            else//加载子节点
            {
                outRegions.children = ToTreesData(regions);
                if (regions.Count > 0)
                {
                    for (int i = 0; i < regions.Count; i++)
                    {
                        LoadRegions(regions[i].Node, inRegions, outRegions.children[i]);//递归调用
                    }
                }
            }
            return outRegions;
        }

        public RegionsTreeOutput ToTreeData(Region region)
        {
            var treeData = new RegionsTreeOutput();
            treeData.id = region.Node;
            treeData.text = region.Name;
            treeData.RegionsId = region.Id;            
            return treeData;
        }
        public List<RegionsTreeOutput> ToTreesData(List<Region> listRegion)
        {
            var regions = new List<RegionsTreeOutput>();
            for (int i = 0; i < listRegion.Count; i++)
            {
                regions.Add(ToTreeData(listRegion[i]));
            }
            return regions;
        }
        #endregion

View Code
 
初始化获取转换后的数据

 /// <summary>
 /// 初始化数据获取
 /// </summary>
 /// <returns></returns>
 public JsonResult GetResultData()
 {
     TreeDbContext db = new TreeDbContext();
     var regions = db.Regions.Where(t => true).ToList();
     var regionObj = LoadRegions("-1", regions, null);
     return Json(regionObj);
 }

以上后台的数据差不多就完成了。
前台数据加载


 $(function () {
            $.post("/Home/GetResultData", null, function (sData) {
                treeObj = $('#jstree_demo').jstree({
                    //, "checkbox"
                    'plugins': ["contextmenu", "dnd", "search", "state", "types", "wholerow"],
                    'core': {
                        "animation": 0,
                        "check_callback": true,
                        'force_text': true,
                        "themes": { "stripes": true },
                        'data': sData
                    },
                    "types": {
                        "default": {
                            "icon": "fa fa-folder icon-state-warning icon-lg"
                        },
                        "file": {
                            "icon": "fa fa-file icon-state-warning icon-lg"
                        }
                    },
                    "contextmenu": {
                        select_node: false,
                        show_at_node: true,
                        items: function (o, cb) {
                            //因为这里我们之后需要定义多个项,所以通过对象的方式返回
                            var actions = {};
                            //添加一个"新增"右键菜单
                            actions.create = {//这里的create其实阔以随意命名,关键是里面的 这里面的 action回调方法
                                "separator_before": false,//Create这一项在分割线之前
                                "separator_after": true,//Create这一项在分割线之后
                                "_disabled": false, //false表示 create 这一项可以使用; true表示不能使用
                                "label": "新增",  //Create这一项的名称 可自定义
                                "action": function (data) {  //点击Create这一项触发该方法,这理还是蛮有用的
                                    var inst = $.jstree.reference(data.reference),
                                         obj = inst.get_node(data.reference);//获得当前节点,可以拿到当前节点所有属性
                                    //新加节点,以下三行代码注释掉就不会添加节点
                                    inst.create_node(obj, {}, "last", function (new_node) {
                                        setTimeout(function () { inst.edit(new_node); }, 0);//新加节点后触发 重命名方法,即 创建节点完成后可以立即重命名节点
                                    });
                                }
                            };
                            if (o.id != "0001")//屏蔽对根节点的操作  “0001”改成根节点对应的真是id
                            {
                                //添加一个"重命名"右键菜单
                                actions.rename = {
                                    "separator_before": false,
                                    "separator_after": false,
                                    "_disabled": false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
                                    "label": "重命名",
                                    "action": function (data) {
                                        var inst = $.jstree.reference(data.reference),
                                                obj = inst.get_node(data.reference);
                                        inst.edit(obj);
                                    }
                                }
                                //添加一个"删除"右键菜单
                                actions.delete = {
                                    "separator_before": false,
                                    "icon": false,
                                    "separator_after": false,
                                    "_disabled": false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
                                    "label": "删除",
                                    "action": function (data) {
                                        var inst = $.jstree.reference(data.reference),
                                                obj = inst.get_node(data.reference);
                                        if (inst.is_selected(obj)) {
                                            inst.delete_node(inst.get_selected());
                                        }
                                        else {
                                            inst.delete_node(obj);
                                        }
                                    }
                                };
                            }
                            return actions;//返回右键菜单项
                        }
                    },
                });
            });
        });

View Code
 
其他操作

//删除节点
$('#jstree_demo').on('delete_node.jstree', function (e, data) {            
            var id = data.node.original.RegionsId;          
            $.ajax({
                type: "get",
                url: "/Home/DeleteRegion?id=" + id,
                success: function (sData) {

                }
            }); 
        });
//移动节点
$('#jstree_demo').on('move_node.jstree', function (e, data) {
            saveRegions(data);
        });
//修改名
$('#jstree_demo').on('rename_node.jstree', function (e, data) {            
            saveRegions(data);
        });
//保存
function saveRegions(data) {            
            var id = data.node.original.RegionsId;
            var name = data.node.text;//修改后的name
            //var oldName = data.old;//原name           
            //var pNode = $('#jstree_demo').jstree().get_node(data.node.parent).original.RegionsId;
            var josnData = { "Id": id, "Node": data.node.id, "ParentNode": data.node.parent, "Name": name };
            $.ajax({
                url: "/Home/SaveRegions",
                data: josnData,
                success: function (sData) {                   
                    data.node.original.RegionsId = sData;
                    data.node.state.opened = false;//是否展开
                }
            });
        }

当然，记得修改或是删除要取RegionsId这个对应后台实体的ID。
通过按钮来操作增删改

function createTree() {   
    var ref = $('#jstree_demo').jstree(true),
        sel = ref.get_selected();
    if (!sel.length) { return false; }
    sel = sel[0];
    sel = ref.create_node(sel, { "type": "file" });
    if (sel) {
        ref.edit(sel);
    }
};

function renameTree() {
    var ref = $('#jstree_demo').jstree(true),
        sel = ref.get_selected();
    if (!sel.length) { return false; }
    sel = sel[0];
    ref.edit(sel, function () {
        
    });
};

function deleteTree() {
    var ref = $('#jstree_demo').jstree(true),
        sel = ref.get_selected();
    if (!sel.length) { return false; }
    ref.delete_node(sel);
};

 
更加详细的细节请看demo。
链接：http://pan.baidu.com/s/1hrN5QvU 密码：c6b7
 

 2016.08.26更新
以上方式有问题：如果多个用户同时新建节点，会有重复的。（因为节点data.node.id是前端页面自动生成的） 
解决方法：(更改data.node.id的值从后台赋值)
前端：

$(function () {
            treeObj = $('#jstree_demo').jstree({
                //, "checkbox"
                'plugins': ["contextmenu", "dnd", "search", "state", "types", "wholerow"],
                'core': {
                    "animation": 0,
                    "check_callback": true,
                    'force_text': true,
                    "themes": { "stripes": true },
                    //修改点（1）  【可以给插件刷新】
                    'data': function (obj, callback) {
                        $.ajax({
                            "type": "post",
                            "url": "/Home/GetResultData",
                            "data": {},
                            "success": function (sData) {
                                callback(sData);//回调传请求得到的数据（这里可以把数据组装成插件需要的数据格式）
                            }
                        });
                    }
                },


//保存
function saveRegions(data) {
    var id = data.node.original.RegionsId;
    var name = data.node.text;//修改后的name
    //var oldName = data.old;//原name
    //var pNode = $('#jstree_demo').jstree().get_node(data.node.parent).original.RegionsId;
    //修改点（2）   【取自定义的父节点】
    var ParentNode = ($('#jstree_demo').jstree().get_node(data.node.parent).original.MyNode || data.node.parent);// data.node.parent;
    //修改点（3）   【取自定义的节点】
    var pNode = (data.node.original.MyNode || data.node.id);
    var josnData = { "Id": id, "Node": pNode, "ParentNode": ParentNode, "Name": name };
    $.ajax({
        url: "/Home/SaveRegions",
        data: josnData,
        type: "post",
        success: function (sData) { 
            data.node.original.RegionsId = sData.Id;
            //data.node.state.opened = true;//是否展开
            data.node.original.MyNode = sData.Node;

            //修改点（4）
            $.jstree.reference("#jstree_demo").refresh();//刷新jstree控件，重新加载数据（）

        }
    });
} 

 后台：

input.Node = Guid.NewGuid().ToString();

 更新demo：http://pan.baidu.com/s/1gfdmQoN
 
【注意】

不能使用select控件，可以使用div、input

article  37
title: 一步步学习javascript基础篇（8）：细说事件
body: 

终于学到事件了，不知道为何听到“事件”就有一种莫名的兴奋。可能是之前的那些知识点过于枯燥无味吧，说起事件感觉顿时高大上了。今天我们就来好好分析下这个高大上的东西。
可以说，如果没有事件我们的页面就只能阅读了。有了事件，我们可以通过键盘或是鼠标和页面交互了，通过我们不同的操作页面给出不同的响应。好了，开始我们今天的分析吧。

DOM0级事件处理方式
什么是DOM0级？
其实世上本来没有DOM0级，叫的人多了就有了DOM0级。
在1998 年 10 月 DOM1级规范成为 W3C 的推荐标准，在此之前的实现我们就习惯称为DOM0级，其实本是没有这个标准的。

<input type="button" value="but" id="but" />
<script type="text/javascript">
    document.getElementById("but").onclick = function () {
        alert("点击了按钮1");
    }
    document.getElementById("but").onclick = function () {
        alert("点击了按钮2");
    } 
</script>

上面代码，我们发现点击按钮时，仅仅只弹出了“点击了按钮2”。上一个定义的方法被覆盖了。这种会覆盖上一次事件定义的方式我们称为DOM0级事件。
如果我们使用Jquery来添加事件的话：

<script src="../Scripts/jquery-1.8.2.js"></script>
<input type="button" value="but" id="but" />
<script type="text/javascript">
    $("#but").click(function () {
        alert("点击了按钮1");
    });
    $("#but").click(function () {
        alert("点击了按钮2");
    });

我们会发现依次弹出了“点击了按钮1”，“点击了按钮2”，这是怎么做到的？为什么没有覆盖上一次的定义，我猜应该是使用到了DOM2级事件机制。（我没有看过Jquery的源码，暂时还看不懂）。
DOM2级事件处理方式

<input type="button" value="but" id="but" />
<script type="text/javascript">      
    document.getElementById("but").addEventListener("click", function () {
        alert("点击了按钮1");
    });
    document.getElementById("but").addEventListener("click", function () {
        alert("点击了按钮2");
    });        
</script>

如此通过元素对象的addEventListener添加的方法就是2级事件。这里需要注意，与0级事件不同的是事件名前面不能带“on”了。点击按钮弹出的结果和前面的Jquery添加方式一样。
有人可能要问了，怎么没有DOM1级事件。我能说的是没有就是没有，没有为什么。在确定DOM1级标准的时候不需要扩展事件定义机制，DOM0级的事件就够用了。
我们刚才通过2级事件添加了方法，那么如果我们想要删除其中的一个怎么办。如果是上面的那种匿名方法，我可以很明确的告诉你没办法移除。下面我们来说说可以移除的添加方式吧：

<input type="button" value="but" id="but" />
<script type="text/javascript">      
    document.getElementById("but").addEventListener("click", fun1);//给click事件添加方法fun1
    document.getElementById("but").addEventListener("click", fun2);//给click事件添加方法fun2

    function fun1() {
        alert("点击了按钮1");
    }
    function fun2() {
        alert("点击了按钮2");
    }

    document.getElementById("but").removeEventListener("click", fun1);//给click事件移除方法fun1
</script>

如此就通过removeEventListener方法进行移除操作了。
以上只是DOM2级的标准实现，当然除了IE这个怪胎非得当搅屎棍。在IE下，有同效的实现函数：

<input type="button" value="but" id="but" />
<script type="text/javascript">      
    document.getElementById("but").attachEvent("onclick", fun1, false);//给click事件添加方法fun1
    document.getElementById("but").attachEvent("onclick", fun2, false);//给click事件添加方法fun2

    function fun1() {
        alert("点击了按钮1");
    }
    function fun2() {
        alert("点击了按钮2");
    }

    document.getElementById("but").detachEvent("onclick", fun1);//给click事件移除方法fun1

注意：attachEvent() 和 detachEvent() 替换了addEventListener()和removeEventListener()，且第一个参数是事件名前面加了"on"。
DOM3级事件
可能有人觉得很奇怪，哪来的DOM3级事件啊。其实上面我们说的DOM0级和DOM2级事件说的是事件的处理方式而已，而这里说的DOM3级事件是说的在DOM3级中新增的一些事件。
至于DOM1级事件，那我就真的没听过。
DOM3级事件是在DOM2级事件的基础上重新定义了或是新增了某些事件。如鼠标事件：
DOM2有，click、mousedown、mousemove、mouseout、mouseover、mouseup而DOM3级中却有，click、dblclick、mousedown、mouseenter、mouseleave、mousemove、mouseout、mouseover、mouseup
(其中dblclick、mouseenter、mouseleave是DOM3中新增的)DOM3级事件实现方式可以用DOM0和DOM2级中的方式，只是新增了写事件类型。这里就不一一列举了。
事件冒泡
什么是事件冒泡?我们先来看个例子。

<div onclick="divfun();" style="border:1px dashed red;padding:50px">
    <span onclick="spanfun();" style="border: 1px dashed #00ff21; padding: 30px; ">
        <input type="button" value="but" onclick="butfun();" style="border: 1px dashed #0094ff" />
    </span>
</div>
<script type="text/javascript">
    function butfun() {
        alert("按钮被点击了");
    }
    function spanfun() {
        alert("span被点击了");
    }
    function divfun() {
        alert("div被点击了");
    }
</script>

一个div包了一个span,然后span里面包了一个button。我们在点击按钮的时候会先触发按钮事件，然后触发span的点击事件，然后触发div的点击事件。这就是事件冒泡。（使用DOM0级事件默认是事件冒泡方式）
效果图：

示意图：

事件捕获
什么是事件捕获？其实就是事件冒泡的逆向。

那我们怎么实现这个效果呢？我们可以通过DOM2级事件。上面我们已经简单的讲解过了DOM2级事件的实现方式
通过addEventListener和removeEventListener给事件添加和删除函数。上面我们讲addEventListener的时候如果你再回头看看，我们只给了两个参数，第一个是事件名，第二个是要添加的方法，其实还有第三个参数一个布尔值用来表示事件流方向（true为事件捕获方向，false为事件冒泡方向）。那么我们完全可以通过DOM2级事件来实现事件捕获的效果，如：

<div id="mydiv" style="border:1px dashed red;padding:50px">
    <span id="mysapn" style="border: 1px dashed #00ff21; padding: 30px; ">
        <input id="mybut" type="button" value="but" style="border: 1px dashed #0094ff" />
    </span>
</div>
<script type="text/javascript">
    document.getElementById("mydiv").addEventListener("click", divfun, true);
    document.getElementById("mysapn").addEventListener("click", spanfun, true);
    document.getElementById("mybut").addEventListener("click", butfun, true);

    function butfun() {
        alert("按钮被点击了");
    }
    function spanfun() {
        alert("span被点击了");
    }
    function divfun() {
        alert("div被点击了");
    }
</script>

效果图：

同样，我们也可以通过DOM2级事件实现事件冒泡，就上面的代码仅仅只需要把addEventListener的第三那个参数改成false就可以了，有兴趣的同学可以自己试试。
然后IE这个搅屎棍又开始不服了，我就不实现事件捕获你能把我怎么着。IE中等效实现的attachEvent的根本就没给第三个参数，所以为了兼容，我们一般只用事件冒泡（IE只支持事件冒泡）。
事件冒泡的使用

取消事件冒泡

通过上面，我们知道只要点击了按钮，那么按钮的上层元素中的点击事件都会触发。那我们会想如果我TM就只想点击某个元素的时候才 触发，不想让它往上冒怎么办，请看下面：

<div id="mydiv" style="border:1px dashed red;padding:50px">
    <span id="mysapn" style="border: 1px dashed #00ff21; padding: 30px; ">
        <input id="mybut" type="button" value="but" style="border: 1px dashed #0094ff" />
    </span>
</div>
<script type="text/javascript">
    //第三个参数是false，那么就是事件冒泡了
    document.getElementById("mydiv").addEventListener("click", divfun, false);
    document.getElementById("mysapn").addEventListener("click", spanfun, false);
    document.getElementById("mybut").addEventListener("click", butfun, false);

    function butfun(event) {
        event.stopPropagation();//在点击按钮时，取消事件冒泡
        alert("按钮被点击了");
    }
    function spanfun() {
        //这里没有取消事件冒泡，所以点击span的时候还是会继续冒泡到div
        alert("span被点击了");
    }
    function divfun() {
        alert("div被点击了");
    }
</script>

效果图：

您如果仔细看了效果图，那么你会发现。点击按钮的时候并没有冒泡，而点击span的时候还是冒泡了。那是因为我们代码里面在按钮事件的方法里面加了 event.stopPropagation()//取消冒泡 。

事件委托

既然可以如此，我们可以在每个事件方法里面都加上取消冒泡，那么所有的元素都只实现自己的事件对应的方法了。我们发现这个事件冒泡反而把事情搞麻烦了，好好的一个元素对应一个事件干嘛要冒泡啊，还要手动去取消冒泡。既然有这个东西，它总是有它的作用的。我们看到上面我们定义事件方法时，取到了每个元素，然后给每个元素定义方法。那我们可以通过事件冒泡定义一个方法来实现吗，先看看下面的代码：

<div id="mydiv" style="border:1px dashed red;padding:50px">
    <span id="mysapn" style="border: 1px dashed #00ff21; padding: 30px; ">
        <input id="mybut" type="button" value="but" style="border: 1px dashed #0094ff" />
    </span>
</div>
<script type="text/javascript">
    //第三个参数是false，那么就是事件冒泡了
    document.getElementById("mydiv").addEventListener("click", divfun, false);   function divfun(event) {
        var targetID = event.target.id 
        if (targetID == "mybut") {
            alert("按钮被点击了");
        } else if (targetID == "mysapn") {
            alert("span被点击了"); 
        } else if (targetID == "mydiv") {
            alert("div被点击了"); 
        } 
    }
</script>

 
效果图：

仔细观察的你，会发现我们点击每个元素会触发对应消息。这就是我们上面为每个元素添加方法然后取消冒泡同样的效果。那么我们再来分析下实现代码，会发现这里反而是使用了冒泡。
 event.target//返回事件的目标节点（触发该事件的节点）  var targetID = event.target.id //返回事件的目标节点的id（触发该事件的节点的Id） 
因为我们为最外面的div添加了事件的方法，所以我们在点击按钮的时候会依次触发按钮、span、div的点击事件，然按钮和span都没有定义事件方法，所以不管是点击按钮、span还是div都会冒泡到div的点击事件，然后我们就可以根据上面的target属性来得知到底是由那个节点触发的。请看示意图：

有人会这，这么麻烦有什么好处呢？我们仔细看看这个通过冒泡实现的个节点点击事件，你有没有发现我们仅仅只是通过getElementById取了一个最外层的div元素，且我们也仅仅只用了一个方法（虽然方法里面的逻辑会更加复杂点）。这只是3个元素，如果有30个呢？甚至上百个呢？我们只定义最外层的元素，这样就减少了大量的DOM引用了（这样就直接减少了检索元素需要花的时间）,同时也可以减少内存的占用。直接提升了性能。（虽然很多时候我们不会这样来定义事件，我自己就很少这样来定义事件，可能是习惯问题吧。>_<）
 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文首链：http://www.haojima.net/zhaopei/531.html
本文已同步至目录索引：一步步学习javascript

 
article  38
title: 一、特性是什么东东
body: 
前言
我们初学C#的时候看到类上面一对中括号里面有个高亮了的关键字，不知道那是什么有什么用。想问人又不知道它叫什么。纠结的要命。其实，它就是特性。如：

这就是我们今天要分析的主题。
特性是什么？
个人理解，特性就是修饰对象元数据的修饰符。
那么什么是“元数据”？
元数据就是用来描述数据的数据。（挺拗口的）
如：

图中的1.是特性 2.是访问修饰符 3.声明修饰符 4.数据类型 5.变量名 6.变量数据值，其中1、2、3、4、5就是元数据，用来描述数据（6）的数据。
特性到底是什么？
如上面的 Obsolete  ,会不会也是一个如 public  static 这样类似的修饰符呢，我们且看看反编译后的中间语言。

意料之外，我们看到了上面的2、3、4、5，而1（特性）怎么跑到里面去了，且是一种看不懂的东东，反正我们知道了不是类似的修饰符。
然后我们接着在vs里面把光标移到 Obsolete  上按F12，如：

原来只是一个继承了 Attrbute 的一个类（class）。那么上面我们看不懂的部分应该就是这个 ObsoleteAttribute 类的实例化了。
我们来回答上面问题：特性到底是什么？特性只是一个类而已。
我们自定义一个特性玩玩
我们看到上面系统特性 Obsolete 上面还有特性，如：Serializable、AttributeUsage、Camvisible等。像这种特性我们称之为“元数据的元数据”（元元数据）。
1.我们分别来解释性上面的三个特性。
Serializable：表示类型支持序列化。
ComVisible：微软定义“控制程序集中个别托管类型、 成员或所有类型对COM的可访问性”。
AttributeUsage：这个比较重要了，基本上每个特性定义都用到了它。它就是用来表示当前这个特性可用于哪些对象。如：类、方法、属性...等等。(只需要用到这个我们就可以自定义特性了)
2.上面有个问题，不知道大家发现没有。
就是我们特性名明明是 Obsolete  ，为什么我们F12进去后变成了 ObsoleteAttribute 呢？这其实只是一个微软的约定而已，没有为什么。
其实我们可以两种写法： [ObsoleteAttribute("已过时")] 和 [Obsolete("已过时")] 是等效的，只是我们一般都用后面这种。
3.定义的特性必须继承于 Attribute 。
4.属性没有set方法。只能通过构造函数赋值。（这是因为特性语法所致，因为特性的定义只存在单行的中括号中，不能实例化之后在设置属性，所以全部的设置都在后面的小括号里进行的。如果需要有set属性，我们就要用到命名参数，下面会继续讲到）
好了，我们通过这四点完全可以自己定义个特性来玩玩了。我们来定义一个给机器看的注释。我们平时的注释都只是给程序员看的，编译之后就全没了。那我们想在代码运行时，弹出我们的注释怎么办，接下来我们用自定义特性来实现，如：

[AttributeUsage(AttributeTargets.All)]//3.设置可用于哪些对象
public class TMessgAttribute : Attribute//1.定义类TMessg加上后缀TMessgAttribute 2.继承Attribute。
{
    public TMessgAttribute() { }

    /// <param name="createTime">创建时间</param>
    /// <param name="createName">创建人</param>
    public TMessgAttribute(string createTime, string createName, string mess)
    {
        this._createName = createName;
        this._createTime = createTime;
        this._mess = mess;
    }

    private string _createTime;
    public string createTime
    {
        get { return _createTime; }//4.只能有get方法
    }
    private string _createName;
    public string createName
    {
        get { return _createName; }
    }
    private string _mess;
    public string mess { get { return _mess; } }
}

好了，上面就是我们自定义的特性。那我们怎样使用呢。和系统特性一样。我们先定义一个测试类TClass，然后在类上面定义特性，如：

[TMessg("2015-12-20", "zhaopei", "我只是测试自定义特性，不要报错哦，求求你了。")]
public class TClass
{
    //................
}

我们定义了特性，也使用了特性，然我们却不知道怎么看效果。我们想看到效果怎么办。可以使用反射(下篇博问继续分析反射)看看 TClass 类的元数据，如：

static void Main(string[] args)
{
    System.Reflection.MemberInfo info = typeof(TClass); //通过反射得到TClass类的信息
    TMessgAttribute hobbyAttr = (TMessgAttribute)Attribute.GetCustomAttribute(info, typeof(TMessgAttribute));
    Console.WriteLine("类名：{0}", info.Name);
    Console.WriteLine("创建时间：{0}", hobbyAttr.createTime);
    Console.WriteLine("创建人：{0}", hobbyAttr.createName);
    Console.WriteLine("备注消息：{0}", hobbyAttr.mess);
    Console.ReadKey();
}

打印效果如：

什么是命名参数？
上面的自定义特性都是通过构造函数设置字段私有字段，然后通过只提供了get的属性来访问。那么可否直接在特性里面定义拥有get和set的属性吗？答案是肯定的。那怎么在使用特性的时候设置这个属性呢？我们接着往下看。
我们接着在自定义特性里面添加一个属性。

/// <summary>
/// 修改时间
/// </summary>
public string modifyTime { get; set; }

使用自定义特性。

[TMessg("2015-12-20", "zhaopei", "我只是测试自定义特性，不要报错哦，求求你了。", modifyTime = "2015-12-21")]
public class TClass
{
    //................
}

我们发现，直接在输入了构造函数之后接着设置属性就可以。（这就相当于可选参数了，属性当然可以随便你是否设置了。不过这里需要注意了，前面的参数一定要按照定义的特性构造函数的参数顺序）
这种参数，我们成为命名参数。
我们来继续要看看AttributeUsage（这个描述特性的特性--“元元数据”）
我们F12看看AttributeUsage的定义

看上去，同样也只是普通的特性。实际上也只是个普通的特性。>_<
我们来看看他的这几个属性是干嘛的。从最后一个开始看。
1.AttributeTargets，我们在上面其实就已经看到并也已经使用了。

我们设置的是可用于所有对象。AttributeTargets其实是个枚举，每个值对于一个类型对象。
你可以直接在 AttributeTargets F12进去：
 我们看到了每个值代表可以用于所对于的对象类型。
2.Inherited(是一个布尔值):“如果该属性可由派生类和重写成员继承，则为 true，否则为 false。 默认值为 true”
如下，我们设置 Inherited = false 那么继承TClass的T2Class无法访问到TClass中设置的特性元数据。


namespace net
{
    [AttributeUsage(AttributeTargets.All, Inherited = false)]//3.设置可用于哪些对象    
    public class TMessgAttribute : Attribute//1.定义类TMessg加上后缀TMessgAttribute 2.继承Attribute。
    {
        public TMessgAttribute() { }

        /// <param name="createTime">创建时间</param>
        /// <param name="createName">创建人</param>
        public TMessgAttribute(string createTime, string createName, string mess)
        {
            this._createName = createName;
            this._createTime = createTime;
            this._mess = mess;
        }

        private string _createTime;
        public string createTime
        {
            get { return _createTime; }//4.只能有get方法
        }
        private string _createName;
        public string createName
        {
            get { return _createName; }
        }
        private string _mess;
        public string mess { get { return _mess; } }
        /// <summary>
        /// 修改时间
        /// </summary>
        public string modifyTime { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Reflection.MemberInfo info = typeof(T2Class); //通过反射得到TClass类的信息
            TMessgAttribute hobbyAttr = (TMessgAttribute)Attribute.GetCustomAttribute(info, typeof(TMessgAttribute));
            Console.WriteLine("类名：{0}", info.Name);
            if (hobbyAttr != null)
            {
                Console.WriteLine("创建时间：{0}", hobbyAttr.createTime);
                Console.WriteLine("创建人：{0}", hobbyAttr.createName);
                Console.WriteLine("备注消息：{0}", hobbyAttr.mess);
                Console.WriteLine("修改时间：{0}", hobbyAttr.modifyTime);

            }
            Console.ReadKey();
        }
    }

    [TMessg("2015-12-20", "zhaopei", "我只是测试自定义特性，不要报错哦，求求你了。", modifyTime = "2015-12-21")]
    public class TClass
    {
        //................
    }

    public class T2Class : TClass
    {
        //...........
    }
}

View Code

反之，我们设置 Inherited = true （或者不设置任何，因为默认就是true）打印如下：

3.AllowMultiple(也是一个布尔值):“如果允许指定多个实例，则为 true；否则为 false。 默认值为 false。”
我们设置两个特性试试，如：

如果我们想要这样设置怎么办。在AttributeUsage中设置 AllowMultiple = true 如：

那么上面报错的地方将会打印：

注意：上面的打印地方的代码需要修改。因为之前是打印一个特性信息，这里是打印一个特性数组集合的信息。

static void Main(string[] args)
{
    System.Reflection.MemberInfo info = typeof(T2Class);
    TMessgAttribute[] hobbyAttr = (TMessgAttribute[])Attribute.GetCustomAttributes(info, typeof(TMessgAttribute));//修改1.这里需要取特性数据的集合了
    Console.WriteLine("类名：{0}", info.Name);
    for (int i = 0; i < hobbyAttr.Count(); i++)//修改2.这里需要循环打印了
    {
        Console.WriteLine("================================================");
        Console.WriteLine("创建人：{0}", hobbyAttr[i].createName);
        Console.WriteLine("创建时间：{0}", hobbyAttr[i].createTime); 
        Console.WriteLine("备注消息：{0}", hobbyAttr[i].mess);
        Console.WriteLine("修改时间：{0}", hobbyAttr[i].modifyTime);
    }

    Console.ReadKey();

全部代码：


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace net
{
    [AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = true)]//3.设置可用于哪些对象    
    public class TMessgAttribute : Attribute//1.定义类TMessg加上后缀TMessgAttribute 2.继承Attribute。
    {
        public TMessgAttribute() { }

        /// <param name="createTime">创建时间</param>
        /// <param name="createName">创建人</param>
        public TMessgAttribute(string createTime, string createName, string mess)
        {
            this._createName = createName;
            this._createTime = createTime;
            this._mess = mess;
        }

        private string _createTime;
        public string createTime
        {
            get { return _createTime; }//4.只能有get方法
        }
        private string _createName;
        public string createName
        {
            get { return _createName; }
        }
        private string _mess;
        public string mess { get { return _mess; } }
        /// <summary>
        /// 修改时间
        /// </summary>
        public string modifyTime { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            System.Reflection.MemberInfo info = typeof(T2Class);
            TMessgAttribute[] hobbyAttr = (TMessgAttribute[])Attribute.GetCustomAttributes(info, typeof(TMessgAttribute));//修改1.这里需要取特性数据的集合了
            Console.WriteLine("类名：{0}", info.Name);
            for (int i = 0; i < hobbyAttr.Count(); i++)//修改2.这里需要循环打印了
            {
                Console.WriteLine("================================================");
                Console.WriteLine("创建人：{0}", hobbyAttr[i].createName);
                Console.WriteLine("创建时间：{0}", hobbyAttr[i].createTime); 
                Console.WriteLine("备注消息：{0}", hobbyAttr[i].mess);
                Console.WriteLine("修改时间：{0}", hobbyAttr[i].modifyTime);
            }

            Console.ReadKey();
        }
    }

    [TMessg("2015-12-20", "zhaopei", "我只是测试自定义特性，不要报错哦，求求你了。", modifyTime = "2015-12-21")]
    [TMessg("2015-12-21", "zhaopei", "我再次测试，还能给我面子显示出来吗？", modifyTime = "2015-12-22")]
    public class TClass
    {
        //................
    }

    public class T2Class : TClass
    {
        //...........
    }
}

View Code
自定义特性可以干什么？
上面我们通过反编译，发现自定义特性实际上就是一个对象调用的最前面加了一段实例化的代码。

那么我们可以做的事可多了，除了像上面一样为对象设置“注释”，我们还可以自定义个特性，给某些方法或是某些类做“操作日志记录”，或者给需要在执行某些方法的时候需要权限，我们可以做个权限认证的特性等等。
这里就需要大家自己去扩展了。
 
本文已同步至《C#基础知识巩固系列》 
article  39
title: 一步步学习javascript基础篇（5）：面向对象设计之对象继承（原型链继承）
body: 
上一篇介绍了对象创建的几种基本方式，今天我们看分析下对象的继承。
一、原型链继承
1.通过设置prototype指向“父类”的实例来实现继承。

function Obj1() {
    this.name1 = "张三";
}
function Obj2() {
}
Obj2.prototype = new Obj1();
var t2 = new Obj2();
alert(t2.name1);


这里有个明显的缺点就是：（如果父类的属性是引用类型，那么我们在对象实例修改属性的时候会把原型中的属性修改，这样会在每个实例对象中改变数据，而这不是我们想要的效果）

function Obj1() {
    this.arr = ["张三"];
}
function Obj2() {
}
Obj2.prototype = new Obj1();
var t2 = new Obj2();
alert(t2.arr);//打印“张三”
t2.arr[t2.arr.length] = "李四";
var t1 = new Obj2();
alert(t1.arr);//打印“张三,李四”

例：
function Obj1() {
  this.arr = ["张三"];
}
function Obj2() {
}
Obj2.prototype = new Obj1();
var t2 = new Obj2();
alert(t2.arr);//打印“张三”
t2.arr[t2.arr.length] = "李四";
var t1 = new Obj2();
alert(t1.arr);//打印“张三,李四”

     
那我们怎样规避这种问题呢？接着往下看。
2. 利用构造函数来实现继承

function Obj1() {
    this.arr = ["张三"];
}
function Obj2() {
    Obj1.call(this);//【1.新增】
}
//Obj2.prototype = new Obj1();【2.注释这行】
var t2 = new Obj2();
alert(t2.arr);//打印“张三”
t2.arr[t2.arr.length] = "李四";
var t1 = new Obj2();
alert(t1.arr);//打印“张三,李四”

我们看到上面代码，就注释了一行，新增了以后。打印出来的效果完全不一样了。现在的arr属性是每个实例对象独有的了。（之前是定义到原型上的，而原型的属性对每个实例都是共享的）
 

例：
function Obj1() {
this.arr = ["张三"];
}
function Obj2() {
  Obj1.call(this);//【1.新增】
}
//Obj2.prototype = new Obj1();【2.注释这行】
var t2 = new Obj2();
alert(t2.arr);//打印“张三”
t2.arr[t2.arr.length] = "李四";
var t1 = new Obj2();
alert(t1.arr);//打印“张三,李四”

     
同样，单纯的这种方式也是有问题的。因为我们这样就无法继承对象的方法了。如：

function Obj1() {
    this.arr = ["张三"];
}
Obj1.prototype.sayHi = function () { alert(this.arr); }////【1.新增】
function Obj2() {
    Obj1.call(this);
}        
var t2 = new Obj2();
//t2里面是没有sayHi方法的

我们可以使用原型和构造的混用来解决，如下：
3.通过原型和构造来实现继承

function Obj1() {
    this.arr = ["张三"];
}
Obj1.prototype.sayHi = function () { alert(this.arr); }
function Obj2() {
    Obj1.call(this);
}
Obj2.prototype = new Obj1();//【1.新增】
var t2 = new Obj2();
t2.sayHi();

如上，通过构造函数中的  Obj1.call(this); 和设置原型属性 Obj2.prototype = new Obj1(); 结合使用，完美解决问题。
这里需要注意一个地方,如果把 Obj2.prototype = new Obj1(); 改成 Obj2.prototype = Obj1.prototype ; 的话，会有你想不到的问题。如：

function Obj1() {
    this.arr = ["张三"];
}
Obj1.prototype.sayHi = function () { alert(this.arr); }
function Obj2() {
    Obj1.call(this);
}
Obj2.prototype = Obj1.prototype;//【1.新增】
var t2 = new Obj2();
t2.constructor.prototype.sayHi = function () { alert("test") };//修改Obj2中的原型的方法
var t1 = new Obj1();
t1.sayHi();
//影响到了Obj1中的原型的方法。因为 Obj2.prototype = Obj1.prototype;让两个对象的原型指向了同一处。
//所以还是只能用Obj2.prototype = new Obj1();

 例：
function Obj1() {
 this.arr = ["张三"];
}
Obj1.prototype.sayHi = function () { alert(this.arr); }
function Obj2() {
 Obj1.call(this);
}
Obj2.prototype = Obj1.prototype;//【1.新增】
var t2 = new Obj2();
t2.constructor.prototype.sayHi = function () { alert("test") };//修改Obj2中的原型的方法
var t1 = new Obj1();
t1.sayHi();

     
4.什么是原型链 
如：

//*************Obj1****
function Obj1() {
    this.arr = ["张三"];
}
Obj1.prototype.sayHi = function () { alert(this.arr); }

//*************Obj2****
function Obj2() {
    Obj1.call(this);
    this.name = "张三";
}
Obj2.prototype = new Obj1();
Obj2.prototype.sayHi2 = function () { alert(this.name); };

//*************Obj3****
function Obj3() {
    Obj2.call(this);
}
Obj3.prototype = new Obj2();
Obj3.prototype.sayHi3 = function () { };

//*******************
var t3 = new Obj3();
t3.sayHi();

 Obj3继承Obj2，Obj2继承Obj1。我们的Obj3的实例对象访问sayHi的时候，会先去Obj3的实例对象中找sayHi方法（没找到），然后去Obj3的原型中找（没找到），然后去父类Obj2的原型中找（没找到），然后去Obj1的原型中找（找到了）。这个找的路径就是原型链。

 

 
（补充分割线20151230） 
以上，我们在说继承的时候，我们都是 obj2.prototype = new obj1(); 原型指向父类构造函数。其实这样有一个问题。如：

function obj1() {
    this.name2 = "张三";
}
obj1.prototype.sayhi = function () {
    alert(this.name2);
}

function obj2() {
    obj1.call(this);//继承属性
}
obj2.prototype = new obj1();
var obj = new obj2();


我们看到name2这个属性，并不是我们想要在prototype中的prototype.name2中继承过来的。（感觉不是那么干净）
然而，我们可以：

function obj1() {
    this.name2 = "张三";
}
obj1.prototype.sayhi = function () {
    alert(this.name2);
}

function obj2() {
    obj1.call(this);//继承属性
}
//obj2.prototype = new obj1();
obj2.prototype = Object.create(obj1.prototype);//继承原型中的方法【E5中才有的一种新的对象创建方式】
var obj = new obj2();


 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/517.html
本文已同步至目录索引：一步步学习javascript
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知
欢迎对个人博客感兴趣的道友加入群：【嗨-博客】469075305 入群须知
如果您觉得文章对您有那么一点点帮助，那么麻烦您轻轻的点个赞，以资鼓励。

 
article  40
title: 分享个人博客皮肤【兼容移动端】
body: 

我真正开始写博客也有一年了，记得最开始写博客之前做的第一件事就是自定义皮肤样式，还为此写过一篇博文《博客园页面设置》。当然从现在的我看那个时候的我是那么的菜，也许一年之后看现在的我也会同样的想法（其实这样也挺好的，证明自己进步了）。为什么要自定义皮肤样式？当然是为了编写出来的博文让人更有阅读欲，自己看着也舒服。很多时候没有一个好的皮肤样式也会成为我们不写博文的一个借口《我们为什么应该坚持写博客》。
其实，很多时候我是很懒的。不是实在看不下去了一般我也不会去动原来的样式。早就有写这篇博文的冲动，因为懒一直拖到现在。现在大冷天的周末躺在被子里面实在不想起床，拿着手机逛着博客园。可惜的是阅读体验非常的不好（我并没有装客户端）,有的甚至无法阅读。实在是受不了，今天决定编写此文，大家有空都让自己的博客兼容移动端吧。其实，我想很多园友并不是不会，也只是因为懒才没有兼容（分分钟的事，为了你的读者。）。本文最主要的目的就是想发动大家都来使用自定义样式来兼容移动端，顺便把自己一些其他自定义也分享了。

一、兼容移动端（img自动滚动条）
兼容移动端，其实非常简单，要做的事情也不多。在《一步步开发自己的博客 .NET版 剧终篇（6、响应式布局 和 自定义样式）》文中我已经分析过了，今天再次分析下吧。

在head中增加一个meta

使用过bootstrap的同学都知道，必须在head标签内加上 <meta name="viewport" content="width=device-width, initial-scale=1"> （参数1：设置屏幕宽度为设备宽度，参数2：缩放值为1。这样做是为了防止根据不同屏幕的像素密度对你的页面进行缩放），然我们博客园并没有默认加上这个meta。所以，我们只能通过javascript动态加上去了。

$("head").prepend("<meta name='viewport' content='width=device-width, initial-scale=1'>");


在css中加一个移动端的media


/*在屏幕宽度小于992px的时候（假设是移动端）*/
@media (max-width: 992px) {
     /*
           这里定义的样式只有在屏幕下于992px的时候才会起作用
           可以在这里定义，在移动端应该要设置的样式。
     */
}


样式中设置大图或固定宽度容器可以左右滚动

在移动端显示最大的问题应该就是屏幕太小，导致有些内容不能完全显示吧。我们可以让其左右滚动。

* {
    overflow: auto;/*溢出内容自动滚动*/
    word-wrap: hyphenate;
}

直接暴力决绝，任何元素只要溢出都让自动滚动。
如此简单的两步就实现了移动端的兼容，容易吧。所以，同志们都来兼容移动端吧。我们开始吧：
1.首先在我的后台页面http://i.cnblogs.com/Configure.aspx
 
2.javascript部分的代码
 $("head").prepend("<meta name='viewport' content='width=device-width, initial-scale=1'>"); 
3.css部分的代码


/*移动端*/
@media (max-width: 992px) {
    .footer {
        margin-right: 5px;
    }

    .divyoulian, #footer {
        margin-right: 5px;
        padding-bottom: 5px;
    }

    #mymainContent {
        margin: 8px;
    }

    #mainContent {
        margin-right: 5px;
        margin-left: 5px;
    }

    .forFlow {
        margin: 0px;
    }

    /*#sideBar, #header {
        display: none;
    }*/
    #sideBar, #div_digg {
        position: initial;
    }

    * {
        overflow: auto;
        word-wrap: hyphenate;
    }

    #sideBar li {
        text-indent: initial;
    }

    /*#cnblogs_post_body p, #cnblogs_post_body li {
        font-size: 33px;
    }*/
    .myadd_left {
        display: none;
    }

    .myadd_right {
        float: none;
        width: 100%;
    }

        .myadd_right div {
            line-height: 50px;
        }

    .myadd {
        margin: 0px;
    }

    /*.myadd_right div a {
                font-size: 10px;
            }*/
}

View Code
效果图：
         
二、历史评论记录移动效果
效果图：

1.http://i.cnblogs.com/Preferences.aspx 中
 尽量选多点显示的评论量。
2.固定最新评论的区域大小，并让其溢出内容隐藏。

#RecentCommentsBlock {
    max-height: 400px;
    overflow: hidden;
}

 3.用javascript动态改变滚动条位置。

//移动一个单位 评论
function nextRecTop() {
    var rec = $("#RecentCommentsBlock");
    if (rec.length) {
        var top = rec.scrollTop();
        top++;
        rec.scrollTop(top);
        if (top != rec.scrollTop())
            rec.scrollTop(0);
    }
}
//移动评论
function MobileComment() {
    var RecCommentTime = 30;//间隔时间
    var RecintervalId = setInterval(function () {
        nextRecTop();
    }, RecCommentTime);

    //鼠标移动时
    $("#RecentCommentsBlock").hover(function () {//移进
        clearInterval(RecintervalId);
    }, function () {//移出
        RecintervalId = setInterval(function () {
            nextRecTop();
        }, RecCommentTime);
    });
}

三、评论区域
1.显示头像
很多人问我头像怎么出来的，其实你知道仔细观察过就会发现默认已经加载了图像，只是没显示出来而已。以dudu的博文评论为例：

然后我们在利用javascript动态组装就可以了。
2.评论区“温馨提示”

其实这只是一张图片而已，在textarea取的焦点时隐藏背景图片。
1.设置类样式（背景图）

.tbCommentBody_bg {
    background: url('http://images2015.cnblogs.com/blog/208266/201510/208266-20151018182003319-279061587.png') no-repeat;
}

2.javascript添加类

function focusoutCommentBody_bg() {
    $("#tbCommentBody").focusout(function () { addtbCommentBody_bg(); });
}

//添加评论区 背景
function addtbCommentBody_bg() {
    var tbcomment = $("#tbCommentBody");
    if (!tbcomment.hasClass("tbCommentBody_bg")) {
        tbcomment.addClass("tbCommentBody_bg");
        tbcomment.focus(function () {
            removetbCommentBody_bg();
        });
    }
}

//移除评论区 背景
function removetbCommentBody_bg() {
    !$(".tbCommentBody_bg").removeClass("tbCommentBody_bg");
    $("#tbCommentBody").unbind("focus");
}

四、标签搜索

日积月累，如果我们写的博文过多不方便查找时，可以搜索标签。
1.通过读取页面http://www.cnblogs.com/zhaopei/tag的所有标签存在隐藏域。

//读取 标签
function gettag() {
    $.ajax({
        type: "get",
        dataType: 'html',
        url: "http://www.cnblogs.com/zhaopei/tag",
        data: {},
        beforeSend: function (XMLHttpRequest) {//当一个Ajax请求开始时触发。
        },
        complete: function (jqXHR, status, responseText) {//请求完成时触发这个事件
        },
        success: function (data) {
            //设置宽度一致
            $(".select_list_tag").css("width", $(".text_select_tag").css("width"));
            $(".hidden_tag").val("");
            var a = $(data).find("#MyTag1_dtTagList td a");
            var span = $(data).find("#MyTag1_dtTagList td span.small");
            for (var i = 0; i < a.length; i++) {               
                $(".hidden_tag").append(a[i].innerHTML + "&");
            }
            //yuntagF();
            get_list_tag();
        },
        error: function (msg) {
        }
    });
}

2.添加到Html5中的自动补全控件
用法（例）：

<input list="pasta">

<datalist id="pasta">
<option>Bavette</option>
<option>Cannelloni</option>
.......
</datalist>

我们还可以使用必应站内搜索：http://cn.bing.com/search?q=js+site:cnblogs.com/zhaopei 把最后的zhaopei修改成你自己的博客id就可以了。
五、弹出框 
我们在开通js权限的时候，我想大家应该都尝试过alert函数。发现没有效果，还以为是没有开通或是哪里出问题了。其实只是屏蔽了alert而已。
早在IE浏览器如果来个死循环alert，估计就只能杀死页面进程了，不然没完没了。我想就是因为这个原因，博客园才禁用alert的吧。看了其实只是把alert用console.log的方式实现了。代码应该是(猜的)：

window.alert = function (data) {
    console.log(data);
}

这样你 alert("123"); 就会以日志的形式输出了。不信你试试。
可以有时候我们就想有弹出框的效果怎办，比如之前写javascript的学习记录，就需要大量的弹出框效果。如：

我是怎么实现的呢？其实就和当时他们屏蔽alert的形式就可以了。

window.alert = function (data) {    
    //...这里自定义一个弹出框
}

再次覆盖alert的定义就可以了。

//***********因为博客园屏蔽了alert函数，这里自己实现一个消息框******************
   //添加一个消息框div
        $("body").append("<div class='alertMsg'></div>");

        function MyAlert() {
            this.textList = [];
            this.index = 0;
        }
        //定义alert函数
        MyAlert.prototype = {
            tempAlert: function (value) {
                //给消息框赋值，并弹出
                var mythis = this;
                $(".alertMsg").text(String(value)).dialog({
                    buttons: {
                        "确定": function () {
                            $(this).dialog('close');
                            mythis.Hidden();
                        },
                        "关闭": function () {
                            $(this).dialog('close');
                            mythis.textList = [];
                            mythis.index = 0;
                        }
                    }
                });
            },
            Show: function (text) {
                this.index++;
                this.textList.push(text);
                if (this.textList.length == 1) {
                    this.Operater();
                }
            },
            Operater: function (text) {
                if (this.textList.length > 0) {
                    this.tempAlert(this.textList[0]);
                }
            },
            Hidden: function () {
                this.textList.shift();
                if (this.textList.length > 0) {
                    this.Operater();
                }
            }
        }
        var myAlert = new MyAlert();
        alert = function (msg) {
            myAlert.Show(msg);
        }
//***********因为博客园屏蔽了alert函数，这里自己实现一个消息框******************

注意这里的dialog就是jqeruy ui中的弹出框。（有现成的，自己也就懒得去实现了）,所以还需要引入jqeruy ui的js和css

<link href="http://files.cnblogs.com/files/zhaopei/jquery.ui.core.css" rel="stylesheet" type="text/css" />
<link href="http://files.cnblogs.com/files/zhaopei/jquery.ui.dialog.css" rel="stylesheet" type="text/css" />
<script src="http://files.cnblogs.com/files/zhaopei/jquery-ui-1.8.24.min.js"></script>

有了弹出框，我们就可以添加执行代码区域框了。

<textarea class="test_code" style="width: 80%;height:80px; max-height: 200px;">

<!--这里写测试的javascript代码,然后alert想要弹出的结果-->

</textarea>
<input type="button" class="test_code_but" onclick="eval($(this).prev().val());" value="运行" />

搞定，这就实现了上面的效果图了。测试：
for (var i = 0; i < 10; i++) {
   alert(i);
}
 
 
 
还有一些自定义的东西这里就不一一分析了，只要自己想要的效果多试试自然可以慢慢搞定的。如：页首推荐文章三篇、自动加载阅读目录。
这里给出我的样式代码下载。 
 
注意：
1.我是在下面皮肤基础上修改的。你如果要使用我的样式，先选择这个默认皮肤。

2.请不要试图引用新的jqeruy进去，否则你的博客会有你想不到的问题。（因为博客园里面有基于Jquery的插件）。
 （当然，你也可以在评论区分享你的自定义样式。）
 
article  41
title: 二、什么是反射、反射可以做些什么
body: 
什么是反射，反射能干嘛？
反射是：指程序可以访问、检测和修改它本身状态或行为的一种能力
反射是一种能力，所以给的定义就是说明了它能干嘛。
我们平时用反射主要做：

获取类型的相关信息
动态调用方法
动态构造对象
从程序集中获得类型。

获取类型的相关信息
反射的核心Type类，Type对象提供的属性和方法可以获取对象的一切信息，如：方法、字段、属性、事件...等等。
我们获取已加载程序集中类型的Type对象的几种方法：（以StringBuilder 类型为例）

直接使用typeof操作符 Type T1 = typeof(StringBuilder); 
通过类型实例 Type T2 = new StringBuilder().GetType(); 
通过Type类的静态方法 Type T3 = Type.GetType("System.IO.Stream"); 

不管使用那种，我们最终得到的结果都是一样的。
那么我们通过Type又能得到些什么信息呢？
获取类型本身信息（命名空间名、全名、是否是抽象、是否是类、、、等等）

var T1 = typeof(StringBuilder);                      
Console.WriteLine("命名空间名称：" + T1.Namespace);
Console.WriteLine("直接基类型：" + T1.BaseType);
Console.WriteLine("全名：" + T1.FullName);
Console.WriteLine("是抽象类型：" + T1.IsAbstract);
Console.WriteLine("是类：" + T1.IsClass);
//.....等等


获取类型成员信息（通过Tyep中的方法GetMembers）

Type T1 = typeof(TClass);
var Mets = T1.GetMembers();//获取Type对象的所有公有成员           
foreach (var m in Mets)
{
    Console.WriteLine("【" + m.MemberType.ToString()+ "】：" + m.Name);
    // m.MemberType 是成员类型
}


MemberType所能包含的成员类型有哪些呢？如：（可以自己可以F12进去看看）

注意：其中MemberInfo的属性DeclaringType返回的是这个属性定义的类型，而ReflectedType返回的是获取这个属性的对象类型。
如：

Type T2 = typeof(TClass);
var Mets = T2.GetMembers();//获取所有公共成员（返回值是MemberInfo类型集合）
foreach (var m in Mets)
{
    if (m.Name=="Equals")
    {
        Console.WriteLine("【" + m.MemberType.ToString() + "】：" + m.Name);
        // m.MemberType 是成员类型        // m.DeclaringType;//获取申明该成员的类        // m.ReflectedType;//获取用于获取 MemberInfo 的此实例的类对象。 
    } 
}

T2中的Equals，我们知道这个方式是在Objec中定义的，在TClass中调用的，所以：

我们发现获取Type对象的成员大多都是以 isxxx、Getxxx、Getxxxs格式的。
isxxx格式的基本上都是判断是否是某类型。
Getxxx和Getxxxs都是放回某类型和某类型集合。其中主要的类型有：

//FieldInfo封装了关于字段的所有信息   （通过Tyep对象的GetFields或GetField方法）
//PropertyInfo类型，封装了类型的属性信息；（通过Type对象的GetProperties或GetProperty方法）
//ConstructorInfo类型，封装了类型的构造函数信息； （..........）
//MethodInfo类型，封装了类型的方法信息；  (........)//MemberInfo类型，封装了类型的所有公共成员；（**就是我们上面说的GetMembers方法**）
//EventInfo类型，封装了类型的事件信息；(.......)
//ParameterInfo类型，封装了方法和构造函数的参数信息；(........)

它们都在 System.Reflection 命名空间下，其每个isxxx、Getxxx、Getxxxs的细节实例用法就不一一演示了。和上面的GetMembers用法区别不大。
动态调用方法
首先定义个类：

public class TClass
{
    public void fun(string str)
    {
        Console.WriteLine("我是fun方法，我被调用了。" + str);
    }
    public void fun2()
    {
        Console.WriteLine("我是fun2方法，我被调用了。");
    }

    public static void fun3()
    {
        Console.WriteLine("我是fun3静态方法,我被调用了");
    }
}

调用方式一（使用InvokeMember调用方法）
调用带参实例方法fun

Type T1 = typeof(TClass);
T1.InvokeMember("fun", BindingFlags.InvokeMethod, null, new TClass(), new string[] { "test" });


调用无参实例方法fun2

Type T1 = typeof(TClass);
T1.InvokeMember("fun2", BindingFlags.InvokeMethod, null, new TClass(), null);

调用静态方法

Type T1 = typeof(TClass);
T1.InvokeMember("fun3", BindingFlags.InvokeMethod, null, T1, null);

我们发现了一个问题当我们调用实例方法的时候需要传实例对象过去。（有人会说，都实例对象了，我还要你动态掉调用个屁啊。有种情况，在我们实例了对象后，仍不确定应该调用那个方法时可以只有使用。然后有人有说了，那如果实例对象我也不确定呢？那我们下面会分析连实例对象也给动态了。那接着完下看吧。）
我们来说下这几个参数的意思吧。
第一个：要被动态调用的方法名。
第二个：是一个枚举，表示是调用一个方法
第三个：是Binder，传的是null，使用默认值。
第四个：传如实例对象（调用实例方法时）或者Type对象（调用静态方法时）。
第五个：要传给被调用发的参数数组。
调用方式二(使用MethodInfo.Invoke调用方法)

Type T1 = typeof(TClass);
T1.GetMethod("fun", BindingFlags.Instance | BindingFlags.Public).Invoke(new TClass(), new string[] { "testfun1" });
T1.GetMethod("fun2", BindingFlags.Instance | BindingFlags.Public).Invoke(new TClass(), null);
T1.GetMethod("fun3", BindingFlags.Static | BindingFlags.Public).Invoke(T1, null);

 
使用其实和上面的方式一区别不大。
真正的全动态调用
上面的两种方式，在编写代码的时候总是要先确定了已知的对象名和方法名。那么我们在不知道对象和方法名的时候是否也可以调用呢？答案是肯定的，实现如下：

Console.WriteLine("请输入对象类名");
string className = Console.ReadLine();
Console.WriteLine("请输入要执行的方法名");

string funName = Console.ReadLine();
Type T1 = Type.GetType(className);

ConstructorInfo ci = T1.GetConstructors()[0]; //获取构造函数 
var obj = ci.Invoke(null);//实例化构造函数

T1.InvokeMember(funName, BindingFlags.InvokeMethod, null, obj, null);

当然，这个代码只能只是fun2，因为上面的传参写死了。（你也可以自己稍微修改下，就可以执行fun、fun2、fun3了） 
效果如下：（对象名和方法名都是手动输入的）

动态构造对象
我们先定义一个对象：

public class TClass
{
    public TClass()
    {
        Console.WriteLine("构造函数被执行了。。");
    }
    public TClass(string str)
    {
        Console.WriteLine("有参构造函数被执行了。。" + str);
    }        
}

动态构造对象

//动态构造对象，方式一
Assembly asm = Assembly.GetExecutingAssembly();
TClass obj = (TClass)asm.CreateInstance("net.tclass", true);//true：不区分大小写

//动态构造对象，方式二
ObjectHandle handler = Activator.CreateInstance(null, " net.TClass");//null：当前程序集
obj = (TClass)handler.Unwrap();

//动态构造对象，方式三（构造有参构造函数）
Assembly asm2 = Assembly.GetExecutingAssembly();
obj = (TClass)asm2.CreateInstance("net.tclass", true, BindingFlags.Default, null, new string[] { "test" }, null, null);//true：不区分大小写            

执行效果图：

获取和修改属性

var obj = new TClass();
obj.name = "张三";
Type type = typeof(TClass);
//获取属性
var Name = type.InvokeMember("name", BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.Instance, null,
                     obj, new object[] { }) as string;
Console.WriteLine(obj.name);
//设置属性
type.InvokeMember("name", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null,
                      obj, new object[] { "新属性（李四）" });
Console.WriteLine(obj.name);//=====================
PropertyInfo[] pros = type.GetProperties(---);//
PropertyInfo pro = null;
var value = pro.GetValue(type);//获取值


从程序集中获得类型
取得当前代码所在程序集（使用GetExecutingAssembly）

Assembly ass = Assembly.GetExecutingAssembly();
Console.WriteLine("当前所在程序集名："+ass.ManifestModule.Name);
Console.WriteLine("当前所在程序集路径："+ass.Location);

 
通过反射加载程序集并创建程序中的类型对象
从程序集中获得类型，这个应该是我们平时用得比较多。如我们所谓的依赖注入和控制反转（这个主题将在下篇博文进行分析）就用到了通过反射从程序集中获取类型。
首先我们还是看看怎么从程序集中获得类型吧。我们可以使用Assembly类型提供的静态方法LoadFrom()或Load()，如：

Assembly asm = Assembly.LoadFrom("Demo.dll");
Assembly asm = Assembly.Load("Demo");

区别：

Assembly asm = Assembly.LoadFrom("net.exe");//需要加后缀，可以指定路径，如下面的
Assembly asm1 = Assembly.LoadFrom(@"C:\01文件\05Svn\BlogsCode\Blogs\Blogs.Web\bin\Blogs.BLL.dll");

Assembly asm2 = Assembly.Load("Blogs.BLL");//无需加后缀，不可以指定路径
//Assembly asm3 = Assembly.Load(@"C:\01文件\05Svn\BlogsCode\Blogs\Blogs.Web\bin\Blogs.BLL");//这里会报错
//使用Load可以加载当前程序bin目录行下的程序集或者系统程序集

//这里TClass可以是一个接口，那么可以在外面的dll任意实现了。  
TClass obj = (TClass)asm2.CreateInstance("net.tclass", true);//true：不区分大小写
obj.fun();//***调用动态加载的dll中的方法***

这样带来的功能是非常强大的。如 我们在没有引用程序集的情况下，也可以使用到程序外的程序集。我们还可以根据不同情况引用不同的程序集。我们甚至还可以通过配置文件来直接配置代码运行时应该加载哪个dll，运行哪个dll中的哪个实现方法。（下篇在讲依赖注入的时候会讲到，同学们继续关注哦~）
从上所知，反射不是某一个概念，而是一类操作的统称。或者说是某些能力的统称。 感觉不好回答反射到底是什么，只能说反射能干什么。它能动态创建对象、动态调用对象方法、动态读取和设置属性和字段、它能动态加载程序外的dll。总的感觉就是大多数都是跟“动态”扯上了关系。
 

 
补充：跨程序集反射
如果我们反射A.dll，而A.dll中引用了B.dll，那么在assembly.GetTypes(); //运行到这个地方会弹出如下错误描述
 
“未处理 System.Reflection.ReflectionTypeLoadException Message="无法加载一个或多个请求的类型。有关更多信息，请检索LoaderExceptions属性。”
 
这种情况可以
 
Assembly assembly =  Assembly.LoadFrom("A.dll") ;Type type = assembly.GetType("xxx.myclassname") ; //传入对应的需要反射的类型 而不能GetTypes。且，应用程序需要应用A.dll锁依赖的B.dll。
 
本文以同步至《C#基础知识巩固系列》
article  42
title: 一步步开发自己的博客 番外篇（8、第三方登录及问题记录）
body: 
前言废话
《一步步开发自己的博客》这个系列已经好久没更新了，看我博客的人都知道我最近在学习javascript。并不是说不更新"嗨-博客"了，而现在学习javascript就是了为了更好的写好"嗨-博客"。其实，这是个"死循环"。系统学习javascript是为了更好的写好"嗨博客"，而写"嗨博客"同样也是为了发现自己哪些地方不足进而加以学习。打算写完javascript系列后，把"嗨博客"的前端好好的重构重构，现在的页面也太矬了一点。
已经好久没有写这样的"废话"了，最近的javascript系列也是，要么直接进入主题，要么直接用demo引入。自以为这样的"干货"大家会更加喜欢。其实不然，我们很多的时候并不是那么喜欢纯技术，偶尔润润色、扯扯淡可能更容易接受。
搞技术的时间真的是不够用啊，青春都献给了无尽的知识吸收。前段日子买了kindle下载了很多"课外书"，有心理的、哲学的、小说等等，然发现并没有多少时间可以用来消费。每天都在给自己敲警钟，想拿高薪就的好好学习，前端这么菜，赶紧把《javascript高级程序设计》看完并用博客记录总结。唉~~一个星期又一个星期的过去了，现在才第六篇闭包，后面还有好多呢。不行，得加快速度。（本想看看课外书的，最终也只是想想）。时间都去哪儿了，时间都献给了技术。
还是不抱怨了，时间只有那么多，我们能做的就是怎样最有效的利用。废话就到此结束，进入今天的主题。
-------------------------------------------以上废话分割线------------------------------------------
前面我们讲过我们自己设计的评论系统。多次有人提议，应该加个匿名评论和第三方登录评论。本来想，自己新开的独立博客肯定没什么访问量，更不会有什么人去评论。意外的是，还真有几个人评论了，如果要评论还需特意去注册。为了方便和大家交流，我觉得有必要提前把第三方登录评论做掉，说做就做。
一、第三方授权登录
什么是第三方授权登录，就是一些大家都会有的帐号如QQ、微信、淘宝、微博等账户。通过那些巨头公司提供的api直接实现登录。
当然，我们是不可能得到你的用户名和密码的。不了解的人，可能会存在这个疑虑。我们可以通过第三方授权登录得到如昵称、性别、注册地址、年龄、头像等基本信息。当然，我们也可以得到你账户因为的唯一编码，就是OAuthId。什么是OAuth技术？大家自行了解，这里就不细讲了。
二、Demo分析
我这里主要是做了QQ和新浪微博的授权登录，其他的没弄了。因为，现在的网民基本上人手几个QQ号，其实有QQ授权就完全足够了。但是，避免有些人疑惑安全问题，而使用平时不常用的微博，所以还加了一个微博授权。
这里主要是参考了园友天真的好蓝啊（直接下demo把，原文链接好像被原博主删掉了）的博文，说是参考，其实是完全拿来主义。因为他写得demo完全可以直接运行了。并且内含QQ、微博、淘宝等授权登录，淘宝的我没有测试，QQ和微博是完全没问题的。
他的demo是放在github上的，下载速度比较慢。我这里提供一个网盘下载地址。
三、问题一：刷新和强制刷新
上面的demo是完全没问题的，不过在我实际使用过程中遇到了些许问题。这里和大家分享下。
首先，我们在登录成功后，会根据授权得到的用户昵称和OAuthId创建一条用户信息存数据库，并存session里面作为登录标识。接着本应该刷新当前页面，显示登录详细如：XXX登录成功。
一般我们在浏览器的用js刷新当前页面会使用 window.location.href = window.location.href; 或是 window.location.reload(); 然后会出现一下问题。

当使用 window.location.reload(); Status直接返回一个304,而使用 window.location.href = window.location.href; Size是(from cache)
      
显然，都使用了缓存。
根据我的理解，第一种是去服务器确认了一次缓存有效性，然后服务器给浏览器304 Not Modified而使用缓存。第二种200(from cache)直接在浏览器端使用缓存，根本就没去服务器。
不管怎么说，都是没有真正刷新而取到服务器更新的数据。我们可以使用 window.location.reload(true); //强制刷新（从服务器重新加载）
四、问题二：跨域问题
我们在域名绑定的时候一般都会直接绑定和加www绑定如： http://haojima.net、http://www.haojima.net 。
这样问题就来了，我们在上面设置授权登录时需要设置一个回调地址：如 http:haojima.net/hi_login.html ，这样我们在访问 http://www.haojima.net 是授权登录，而回调地址是没有带www。本来这样也是没有问题的，可是我的处理是，在回调页面设置父页面的href如： window.opener.location.href = "/" ;这样 window.opener.location.href 访问的其实就是 www.haojima.net 域名，而我们回调页面地址域名是 haojima.net 。这里就会自己报错了，错误信息每个浏览器都不同，原因就是跨域了。跨域了就不允许通信。这也是浏览器的一种安全机制。
什么叫跨域？如下图，我们就是这种情况。

那我们如何解决这个问题。
方案一
我们可以设置两个回调地址，以QQ授权登录为例。

然后我们程序里面判断，如果当前访问地址带有www，那么我们就使用带有www的回调地址，反之则使用没有www的回调地址。

方案二
我们可以直接把网站所有url域名统一指向带www的域名或是统一指向不带www的域名。
这样我们访问如： http://haojima.net/UserManage/Login 就自动301到了 http://www.haojima.net/UserManage/Login ，如此一来我们只用设置对应的域名下的回调地址了。
我们可以直接在iis里面设置，可以在web.config里面设置。因为我使用的免费阿里云，没有iis只能设置config了。

<system.webServer>  
  <!--重定向到带www的Url-->
  <rewrite>
    <rules>
      <rule name="WWW Redirect" stopProcessing="true">
        <match url=".*" />
        <conditions>
          <add input="{HTTP_HOST}" pattern="^haojima.net$" />
        </conditions>
        <action type="Redirect" url="http://www.haojima.net/{R:0}"
        redirectType="Permanent" />
      </rule>
    </rules>
  </rewrite>
....

以上两种方案都可以完美解决我们遇到的跨域问题，不过这里又有个疑问。我们是把www301到不带www的url，还是把不带www301到带www的url。

所以，我们还是都带上www。我看博客园就是都执行了www，还有一些大的网站都是指向了www。
五、问题三：弹框拦截
什么是弹窗？就是我们从当前页面点击一个按钮或标签的时候打开一个新的页面。如：

遇到这种问题，我们一般都会骂坑爹的怎么拦截了，我就是想要弹框怎么办。像这种发到网上的页面，有很多人没注意这个拦截提示又或者看到了不知道怎么弹出来，那岂不是悲剧了。
其实也是只用安全措施把，避免有人恶意在网页不停的弹窗。为什么会出现这种拦截，因为我们是让代码自动弹的如：

<input type="button"  value="but" onclick="but()"/>
<script type="text/javascript">      
    function but() {
        $.get("temp.html", null, function () {//这里就是回调自动执行函数
            window.open("temp.html", 'newWindow', 'height=400, width=600, top=100, left=300, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no');
        });
    }       
</script>

那我们怎么解决这个问题呢？手动触发弹出就不会拦截了。

<input type="button" class="but_open" value="but" />
<script type="text/javascript">
    $(function () {
        $.get("temp.html", null, function () {
            $(".but_open").click(function () {//这里需要手动点击才会触发
                window.open("temp.html", 'newWindow', 'height=400, width=600, top=100, left=300, toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no');

            })
        });
    });
</script>

页面上看起来效果都是点击，但是这样实现的话，就不会被拦截了。有人会问，为什么要发ajax请求，项目里面需要请求后的结果做为open的url。
好了，暂时问题就需要这么些，先记录到这里了。
-----------------------------------------更新20171024---------------------------------------------
如果非得ajax之后打开新页面，而不被拦截。可以：

<script type="text/javascript">
    $("button").click(function () {
        var newPage = window.open();
        $.get("HtmlPage2.html", null, function () {         
            newPage.location.href = "http://www.baidu.com";
        }); 
    });
</script>

 
 
-------------------------------------------以下废话分割线------------------------------------------
原本计划写完这篇博文继续我的javascript学习之路。然，因为一些个人原因想换工作。然后想要拿到自己想要的薪资，就必须面试能够顺利。面试要顺利，就要有丰富的项目经验和深厚的知识积累。所以，不得不停下javascript这个系列，暂时先备战面试。（本来打算坚持继续学习javascript系列的，经Learning hard的提醒，现在确实应该备战一下）
决定再开一个系列《备战面试之深入理解XXX》，暂定主题委托和事件、反射、多线程、依赖注入和控制反转、设计模式等。
其实像上面的这些主题说不会吧，平时要用，一些基本的还是可以用的来。要是面试真正问起细节和原理，还真不知道了。特别是设计模式，一般的代码编程，我还真没用过什么所谓的设计模式。当然，我也确实不了解。趁着这次统统过一遍吧。
其实，我觉得我们都应该做好随时跳槽的心理准备。这样，我们时刻都是在准备着，不至于安乐于现状。最后送大家一句话，机会总是给有准备的人。
 

演示地址：http://www.haojima.net/UserManage/Login    
博客源码：http://git.oschina.net/zhaopeiym/Hi-Blogs
如果您有更好的处理方式，希望不要吝啬赐教。
欢迎加入开源博客Q群：469075305 (入群须知)
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
本文链接：http://www.cnblogs.com/zhaopei/p/5044935.html
如果本文对您有那么一点点用处，那么请您轻轻点个赞，给我继续作文的动力。

 
article  43
title: 一步步开发自己的博客 番外篇（7、异步记录日志 和 文章阅读量统计）
body: 
前言 

离前一篇《一步步开发自己的博客  .NET版（6、手机端的兼容）》都个把月了。
当时写完第六篇，很多人问“剧终”了？你还有好多实现没有讲解分析呢。我说没呢，后期还会有第二版、第三版...至于还没有分析到，后期补上。你看，我今天不就来了么。
前段时间写代码，手都写的酸痛酸痛的，歇息了几天，好多了。然后，又捣鼓了一下webapi。这也是个没有接触过的知识。跌跌撞撞的整了点东西出来。有兴趣写移动端的同学可以联系我，大家一起学习。API文档和测试地址：http://haojima.net/SwaggerUI 

其他的就不多说了，进入今天的主题，异步记录日志和文章阅读量统计。
     
异步记录日志
我们常用日志记录，无非就是，数据库记录和文本日志记录。而今天我要说的是，文本日志记录。
最简单的文本记录： File.WriteAllText(path,messg); 使用静态类File的WriteAllText 如果文件存在则覆盖，传入文件路径和消息内容。ok，完事。
当然，我们不能每次都覆盖上一次的记录。 File.AppendAllText(path,messg); 那么我们可是在原有内容追加。这里，我们不用关系文件流是否关闭，使用静态类File的这两个方法都会自动帮我们关闭。
如果，我们是使用的winfrom单线程。那么，基本的日志记录就这个两个方法 完全可以搞定。
但是，如果是web程序就不一样了，天生的多线程。多个线程同时访问一个文件，肯定是会报错的。不信你试试。
那我们怎么解决这个问题？有人会说，加锁呗。锁肯定是要加，不过要看怎么加了。如果加到写文件内容的时候肯定是不合适的。因为写文件要打开文件流，比较耗时。我们可以先把要写的日志，统一存内存，然后单线程从内存取数据，写到文本。当然，写内存也可能会多线程并发，这个时候，我们就可以把锁加到写内存的地方。这里大家就不用担心了，写内存的速度是非常快的，和直接写文件那差的可不是一两个档次的问题了。
我们刚才说存内存，怎么存？当然是存集合了。有个数据类型 Queue 为什么要用它。因为它是队列，有个特点：先进先出。我们取数据的时候就是去的最早存进去的数据了。
使用：存数据 Queue myQ = new Queue(); myQ.Enqueue("The");//入队    取数据 var t = myQ.Dequeue(); 直接在取值的时候就把值在队列中移除了。这样正好免了我手动移除。
那么，很简单。我们记日志的时候就先把日志往 Queue 里存，然后单独开个进程取值存值写文件里。ok，完事。
刚才说了，我们要加锁。是的，要加锁。因为 Queue 并不是线程安全数据。我们在写数据和读数据的时候都要加锁。

static object myLock= new object();
...
lock (myLock)
     logQueue.Enqueue(logmede);//存
...
lock (myLock)
     var m = logQueue.Dequeue();//取

 
我之前在网上查资料说不能多线程同时写入队列，经测试其实是不能同时读和写队列。所以在Dequeue取的时候也要锁定同一个对象
思路大体就是这样了。当然，我们还可以扩展很多的东西。如：定时删除指定过期日志、分文件大小存储日志、自动增加的日志文件命名...等等。
写到这里，估计又有大把大把的人要来批判我了。又在造轮子。日志框架那么多，干嘛还要自己写。浪费时间.....等。
没错，我确实是在造轮子。我不想解释太多了。累...   大神请略过....
下面给出，我的具体实现代码。分为四个文件 LogMode 包含文件名、日志内容 LogHelper 存队列、写文件 LogConfig 读取相关配置 LogSave 外部直接调用


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web;

namespace CommonLib.HiLog
{
    /// <summary>
    /// 日志模型
    /// </summary>
    internal class LogModel
    {      
        #region logFileName
        private string _logFileName;

        /// <summary>
        /// 日志文件名字
        /// </summary>
        public string logFileName
        {
            get { return _logFileName + "_" + DateTime.Now.ToString("yyyyMMdd"); }
            set { _logFileName = value; }
        }
        #endregion

        #region logMessg
        private string _logMessg;

        /// <summary>
        /// 日志内容
        /// </summary>
        public string logMessg
        {
            get
            {
                return "----begin-------" + DateTime.Now.ToString() + "----Queue.Count：" + LogHelper.LogQueue.Count + "-----------------------------------\r\n\r\n"
                    + _logMessg
                    + "\r\n\r\n----end----------" + DateTime.Now.ToString() + "----Queue.Count：" + LogHelper.LogQueue.Count + "-----------------------------------"
                    + "\r\n\r\n\r\n";
            }
            set { _logMessg = value; }
        }
        #endregion
    }
}

View Code


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace CommonLib.HiLog
{
    /// <summary>
    /// 日志操作辅助类
    /// zhaopeiym@163.com
    /// 创建20150104 修改20151003
    /// </summary>
    internal class LogHelper
    {
        /// <summary>
        /// 消息队列
        /// </summary>
        private static Queue<LogModel> logQueue = new Queue<LogModel>();
        /// <summary>
        /// 消息队列 对外只读
        /// </summary>
        public static Queue<LogModel> LogQueue
        {
            get { return LogHelper.logQueue; }
        }

        /// <summary>
        /// 标志锁
        /// </summary>
        static string myLock = "true";

        /// <summary>
        /// 写入日志文件（异步单线程 记录日志）
        /// </summary>
        /// <param name="logmede"></param>
        public static void logWrite(LogModel logmede)
        {
            // 这里需要锁上 不然会出现：源数组长度不足。请检查 srcIndex 和长度以及数组的下限。异常   
            //网上有资料说 http://blog.csdn.net/greatbody/article/details/26135057  不能多线程同时写入队列
            //其实  不仅仅 不能同时写入队列 也不能同时读和写如队列  所以  在Dequeue 取的时候也要锁定一个对象
            lock (myLock)
                logQueue.Enqueue(logmede);
            logStartWrite();
        }

        /// <summary>
        /// 文件编码格式
        /// </summary>
        public static Encoding encoding = Encoding.Default;

        /// <summary>
        /// 是否开始自动记录日志
        /// </summary>
        private static bool isStart = false;

        /// <summary>
        /// 用来 标识 最好一次 检测是否 需要 清理 日志文件 时间
        /// </summary>
        private static DateTime time = DateTime.MinValue;
        /// <summary>
        /// 每个日志文件夹 对应的文件下标
        /// </summary>
        private static Dictionary<string, int> logFileNum = new Dictionary<string, int>();
        /// <summary>
        /// 开始把队列消息写入文件
        /// </summary>
        private static void logStartWrite()
        {
            if (isStart)
                return;
            isStart = true;
            Task.Run(() =>
            {
                while (true)
                {
                    if (LogHelper.logQueue.Count >= 1)
                    {
                        LogModel m = null;
                        lock (myLock)
                            m = LogHelper.logQueue.Dequeue();
                        if (m == null)
                            continue;

                        if (string.IsNullOrEmpty(LogConfig.logFilePath))
                            throw new Exception("请先初始化日志保存路径LogModel._logFilePath");

                        TestingInvalid();

                        if (!Directory.Exists(LogConfig.logFilePath + m.logFileName + @"\"))
                            Directory.CreateDirectory(LogConfig.logFilePath + m.logFileName + @"\");

                        // int i = m.logFileNum;
                        if (!logFileNum.Keys.Contains(m.logFileName))
                            logFileNum.Add(m.logFileName, 0);
                        //部分 日志 文件路径
                        string SectionfileFullName = LogConfig.logFilePath + m.logFileName + @"\" + m.logFileName + "_" + logFileNum[m.logFileName].ToString("000") + ".txt";
                        //最新的写了内容的 部分 日志文件路径
                        string TopSectionfileFullName = SectionfileFullName;
                        // 需要实时更新的 最新日志文件 路径
                        string LogfileFullNqme = LogConfig.logFilePath + m.logFileName + @"\" + m.logFileName + ".txt";

                        FileInfo file = new FileInfo(SectionfileFullName);
                        while (file.Exists && file.Length >= LogConfig.SectionlogFileSize)
                        {
                            TopSectionfileFullName = SectionfileFullName;
                            logFileNum[m.logFileName]++;
                            SectionfileFullName = LogConfig.logFilePath + m.logFileName + @"\" + m.logFileName + "_" + logFileNum[m.logFileName].ToString("000") + ".txt";
                            file = new FileInfo(SectionfileFullName);
                        }

                        try
                        {
                            if (!file.Exists)//如果不存在 这个文件 就说明需要 创建新的部分日志文件了
                            {
                                //因为SectionfileFullName路径的文件不存在    所以创建
                                File.WriteAllText(SectionfileFullName, m.logMessg, encoding);

                                FileInfo Logfile = new FileInfo(LogfileFullNqme);
                                if (Logfile.Exists && Logfile.Length >= LogConfig.FileSize)
                                    //先清空  然后加上 上一个部分文件的内容
                                    File.WriteAllText(LogfileFullNqme, File.ReadAllText(TopSectionfileFullName, encoding), encoding);//如果存在则覆盖                           
                            }
                            else
                                File.AppendAllText(SectionfileFullName, m.logMessg, encoding);//累加

                            //追加这次内容 到动态更新的日志文件
                            File.AppendAllText(LogfileFullNqme, m.logMessg, encoding);
                        }
                        catch (Exception ex)
                        {
                            throw ex;
                        }

                    }
                    else
                    {
                        isStart = false;//标记下次可执行
                        break;//跳出循环
                    }
                }
            });
        }

        /// <summary>
        /// 检测 并删除 之前之外的 日志文件
        /// </summary>
        public static void TestingInvalid()
        {
            #region 检测 并删除 之前之外的 日志文件
            if (time.AddMinutes(LogConfig.TestingInterval) <= DateTime.Now)// 时间内 检测一次
            {
                try
                {
                    time = DateTime.Now;
                    List<string> keyNames = new List<string>();
                    foreach (var logFileName in logFileNum.Keys)
                    {
                        CreatePath(LogConfig.logFilePath + logFileName + @"\");
                        DirectoryInfo dir = new DirectoryInfo(LogConfig.logFilePath + logFileName + @"\");
                        if (dir.CreationTime.AddMinutes(LogConfig.DelInterval) <= DateTime.Now)//删除 设定时间 之前的日志
                            foreach (var fileInfo in dir.GetFiles())
                            {
                                if (fileInfo.LastWriteTime.AddMinutes(LogConfig.DelInterval) <= DateTime.Now)//最后修改时间算起
                                    File.Delete(fileInfo.FullName);

                            }
                        if (dir.GetFiles().Length == 0)
                            keyNames.Add(logFileName);//临时存储没有日志文件的文件夹
                    }
                    foreach (var key in keyNames)//删除没有日志文件的文件夹
                    {
                        logFileNum.Remove(key);
                        Directory.Delete(LogConfig.logFilePath + key + @"\", false);
                    }
                }
                catch (Exception ex)
                {
                    LogSave.ErrLogSave("手动捕获[检测并删除日志出错！]", ex, "记录日志出错");
                }                
            }
            #endregion
        }

        #region  创建路径
        /// <summary>
        /// 创建路径
        /// </summary>
        /// <param name="paht"></param>
        /// <returns></returns>
        public static bool CreatePath(string paht)
        {
            if (!Directory.Exists(paht))
            {
                Directory.CreateDirectory(paht);
                return true;
            }
            return false;
        }
        #endregion
    }
}

View Code


using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Web;

namespace CommonLib.HiLog
{
    /// <summary>
    /// 日志相关配置    
    /// </summary>
    public static class LogConfig
    {
        #region 辅助方法
        /// <summary>
        /// GetAppSettings
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public static string GetAppSettings(string key)
        {
            if (ConfigurationManager.AppSettings.AllKeys.Contains(key))
                return ConfigurationManager.AppSettings[key].ToString();
            return string.Empty;
        }

        /// <summary>
        /// 计算字符串 转 计算结果
        /// </summary>
        /// <param name="v"></param>
        /// <returns></returns>
        public static string toCompute(this string v)
        {
            return new DataTable().Compute(v, "").ToString();
        }
        #endregion

        #region 静态属性和字段

        #region logFilePath 路径
        /// <summary>
        /// 日志要存的路径 默认路径：网站根目录 + Log 文件夹
        /// 在程序第一次启动是设置
        /// </summary>       
        private static string _logFilePath;

        /// <summary>
        /// 日志要存的路径 默认路径：网站根目录 + Log 文件夹
        /// 在程序第一次启动是设置
        /// </summary>   
        public static string logFilePath
        {
            get
            {
                if (string.IsNullOrEmpty(_logFilePath))
                {
                    try
                    {
                        _logFilePath = HttpContext.Current.Server.MapPath("~/");
                    }
                    catch (Exception)
                    {
                        try
                        {
                            _logFilePath = System.Windows.Forms.Application.StartupPath + @"\";
                        }
                        catch (Exception)
                        {
                            throw new Exception("请先初始化要保存的路径：LogModel._logFilePath");
                        }
                    }
                }
                return _logFilePath;
            }

            set
            {
                _logFilePath = value;
            }
        }

        #endregion

        #region 检测间隔时间（分钟）
        private static int _TestingInterval;
        /// <summary>
        /// 检测间隔时间（分钟） 默认：一天
        /// 配置：appSettings->Log_TestingInterval 单位：秒
        /// </summary>
        public static int TestingInterval
        {
            get
            {
                if (_TestingInterval <= 0)
                {
                    var Log_TestingInterval = GetAppSettings("Log_TestingInterval");
                    if (string.IsNullOrEmpty(Log_TestingInterval))
                        _TestingInterval = 1 * 60 * 24;
                    else
                        _TestingInterval = Convert.ToInt32(Log_TestingInterval.toCompute());
                }
                return _TestingInterval;
            }
        }
        #endregion

        #region 删除 N分钟（最后修改时间）之前的的日志
        private static int _DelInterval;
        /// <summary>
        /// 删除 N分钟（最后修改时间）之前的的日志 默认：15天
        /// 配置：appSettings->Log_DelInterval 单位：秒
        /// </summary>
        public static int DelInterval
        {
            get
            {
                if (_DelInterval <= 0)
                {
                    var Log_DelInterval = GetAppSettings("Log_DelInterval");
                    if (string.IsNullOrEmpty(Log_DelInterval))
                        _DelInterval = 1 * 60 * 24 * 15;
                    else
                        _DelInterval = Convert.ToInt32(Log_DelInterval.toCompute());
                }
                return _DelInterval;
            }
        }
        #endregion

        #region 部分日志文件大小(Byte)
        private static int _SectionlogFileSize;
        /// <summary>
        /// 部分日志文件大小(Byte) 默认：1024Byte * 1024 * 1 = 1MB
        /// 配置：appSettings->Log_SectionlogFileSize 单位：Byte
        /// </summary>
        public static int SectionlogFileSize
        {
            get
            {
                if (_SectionlogFileSize <= 0)
                {
                    var Log_SectionlogFileSize = GetAppSettings("Log_SectionlogFileSize");
                    if (string.IsNullOrEmpty(Log_SectionlogFileSize))
                        _SectionlogFileSize = 1024 * 1024 * 1;
                    else
                        _SectionlogFileSize = Convert.ToInt32(Log_SectionlogFileSize.toCompute());
                }
                return _SectionlogFileSize;
            }
        }
        #endregion

        #region 变动文件大小(Byte)
        private static int _FileSize;
        /// <summary>
        /// 变动文件大小(Byte) 默认：1024 * 1024 * 4 = 4M
        /// 配置：appSettings->Log_FileSize 单位：Byte
        /// </summary>
        public static int FileSize
        {
            get
            {
                if (_FileSize <= 0)
                {
                    var Log_FileSize = GetAppSettings("Log_FileSize");
                    if (string.IsNullOrEmpty(Log_FileSize))
                        _FileSize = 1024 * 1024 * 4;
                    else
                        _FileSize = Convert.ToInt32(Log_FileSize.toCompute());
                }
                return _FileSize;
            }
        }
        #endregion

        #endregion
    }
}

View Code


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;

namespace CommonLib.HiLog
{
    /// <summary>
    /// 异步单线程
    /// </summary>
    public class LogSave
    {
        /// <summary>
        /// 获得Exception 的详细信息
        /// </summary>
        /// <param name="ex"></param>
        /// <returns></returns>
        public static string GetExceptionInfo(Exception ex)
        {
            StringBuilder str = new StringBuilder();
            str.Append("错误信息：" + ex.Message);
            str.Append("\r\n错误源：" + ex.Source);
            str.Append("\r\n异常方法：" + ex.TargetSite);
            str.Append("\r\n堆栈信息：" + ex.StackTrace);
            return str.ToString();
        }

        /// <summary>
        /// 系统 自动 捕捉异常
        /// 保存异常详细信息 
        /// 包括： 浏览器  浏览器版本 操作系统 页面  Exception
        /// </summary>
        /// <param name="ex"></param>
        /// <param name="fileName">文件名 默认：SysErr</param>
        public static void SysErrLogSave(Exception ex, string fileName = null)
        {
            StringBuilder str = new StringBuilder();
            string ip = "";
            if (HttpContext.Current.Request.ServerVariables.Get("HTTP_X_FORWARDED_FOR") != null)
                ip = HttpContext.Current.Request.ServerVariables.Get("HTTP_X_FORWARDED_FOR").ToString().Trim();
            else
                ip = HttpContext.Current.Request.ServerVariables.Get("Remote_Addr").ToString().Trim();
            str.Append("Ip:" + ip);
            str.Append("\r\n浏览器:" + HttpContext.Current.Request.Browser.Browser.ToString());
            str.Append("\r\n浏览器版本:" + HttpContext.Current.Request.Browser.MajorVersion.ToString());
            str.Append("\r\n操作系统:" + HttpContext.Current.Request.Browser.Platform.ToString());
            str.Append("\r\n页面：" + HttpContext.Current.Request.Url.ToString());
            str.Append("\r\n" + GetExceptionInfo(ex));
            LogHelper.logWrite(new LogModel()
            {
                logFileName = "SysErr" + fileName ?? string.Empty,
                logMessg = str.ToString()
            });
        }

        /// <summary>
        /// 异常日志记录
        /// </summary>
        /// <param name="strmes"></param>
        /// <param name="ex"></param>
        public static void ErrLogSave(string strmes, Exception ex, string fileName = null)
        {
            StringBuilder str = new StringBuilder();
            str.Append(strmes);
            if (ex != null)
                str.Append("\r\n" + GetExceptionInfo(ex));
            LogHelper.logWrite(new LogModel()
            {
                logFileName = fileName ?? "Err",
                logMessg = str.ToString()
            });
        }

        /// <summary>
        /// 警告日志记录
        /// </summary>
        /// <param name="str"></param>
        public static void WarnLogSave(string str, string fileName = null)
        {
            if (str != null && !string.IsNullOrEmpty(str.Trim()))
                LogHelper.logWrite(new LogModel()
                {
                    logFileName = fileName ?? "Warn",
                    logMessg = str
                });
        }

        /// <summary>
        /// 追踪日志记录
        /// </summary>
        /// <param name="str"></param>
        public static void TrackLogSave(string str, string fileName = null)
        {
            if (str != null && !string.IsNullOrEmpty(str.Trim()))
                LogHelper.logWrite(new LogModel()
                {
                    logFileName = fileName ?? "Track",
                    logMessg = str
                });
        }

        /// <summary>
        /// 追踪日志记录
        /// </summary>
        /// <param name="str"></param>
        public static void TrackLogSave(string str)
        {
            if (!string.IsNullOrEmpty(str.Trim()))
                LogHelper.logWrite(new LogModel()
                {
                    logFileName = "SqlTrack",
                    logMessg = str
                });
        }
    }
}

View Code
写好之后，下次我在别的项目里面就直接引用。
如果你使用的是EF，那么我再告诉你一个小秘密。 DbContext 中的 Database.Log 可以直接记录所有EF执行的sql语句和参数。
使用如： dbContext.Database.Log = LogSave.TrackLogSave;  而LogSave.TrackLogSave我们在上面已经封装过。
效果图1  效果图2 
文章阅读量统计
我在一开始就琢磨着怎么统计阅读量。之前也在http://www.cnblogs.com/zhaopei/p/4744846.html的最后提出了这个疑问。

遗憾的是，并没有谁告诉我更好的解决方案。
好吧，靠人不如靠己。还是自己瞎折腾吧。
但是，实现方式还是使用的我自己的提出的“如果实在是找不到好的解决方案，我打算用 IP+系统版本+浏览器版本号+.... 作为“联合主键”，如果“主键”24小时内重复两次以上，则不统计，如果cookie存在也不统计。”
1、我们在每次浏览器访问的时候都种下cookie，并设置过期时间为24小时。下次，浏览器访问的时候。我们检测如果存在我们种下的cookie。则直接忽略。
2、如果没有带上我们的cookie。我们就先组合“联合主键”。然后检测24小时内的记录有没有这个“联合主键”。如果有，则忽略，否则在原有阅读量的基础上加一，然后存入“联合主键”。
这里的"联合主键"有个小技巧。大家肯定都发现了，这个主键有点长。存数据库有点浪费空间（我数据库本来就只有50M），然后查询检索应该也会慢些吧（并不清楚）。我们想想，其实我们要的不是这么长一串东东。其实，我们只要得到这串东西代表的唯一性就可以了。那么我们可以用到md5，咱不管你是1G、2G还是高清或是无码。统统给你返回一定长度字符串（我取的是16位小写）。
随着数据的增加，这个统计阅读量的表数据，肯定是所有表中最大的。然而，我们统计阅读量是在，点击访问文章的时候，然后在统计阅读量这个环节卡太久，给人的感觉就是这个页面访问太慢，体验不好。
然而，我们每次统计都需要检测数据库里面是否存在，且数据量还不小。那我们只有再开个进程来做统计。
具体实现代码：

#region 判断是否阅读过 如果没有 这在BlogReadInfo 插入一条标识信息
private bool IsRead(Blogs.ModelDB.Blogs blogobj, string md5)
{
    if (blogobj.BlogReadInfo.Where(t => t.MD5 == md5 && t.LastTime.AddHours(24) > DateTime.Now).Count() > 0)
        return true;
    else
    {
        //BLL.
        blogobj.BlogReadInfo.Add(new Blogs.ModelDB.BlogReadInfo()
        {
            MD5 = md5,
            IsDel = false,
            BlogsId = blogobj.Id,
            CreateTime = DateTime.Now,
            UpTime = DateTime.Now,
            LastTime = DateTime.Now
        });
        return false;
    }
}
#endregion


#region 统计阅读量 异步调用方法
delegate void SaveReadDelegate(ModelDB.Blogs blogobj, string md5);
private void SaveReadNum(ModelDB.Blogs blogobj, string md5)
{
    LogSave.TrackLogSave(GetUserDistinguish(Request, false), "ReadBlogLog");
    var isup = true;
    BLL.BlogsBLL blogbll = new BLL.BlogsBLL();
    var blogtemp = blogbll.GetList(t => t.Id == blogobj.Id, isAsNoTracking: false).FirstOrDefault();
    if (blogtemp.BlogReadNum == null)
        blogtemp.BlogReadNum = 1;
    else if (!IsRead(blogtemp, md5))
        blogtemp.BlogReadNum++;
    else
        isup = false;
    if (isup)
        BLL.BlogCommentSetBLL.StaticSave();
}


#region 获取客户端标识（伪）
/// <summary>
///  获取客户端标识 用来判断是否已经阅读过此文章
/// </summary>
/// <param name="requestt"></param>
/// <param name="IsMD5">是否已经md5加密</param>
/// <returns></returns>
private string GetUserDistinguish(HttpRequestBase requestt, bool IsMD5 = true)
{
    //request
    StringBuilder str = new StringBuilder();
    string ip = "";
    if (requestt.ServerVariables.AllKeys.Contains("HTTP_X_FORWARDED_FOR") && requestt.ServerVariables.Get("HTTP_X_FORWARDED_FOR") != null)
        ip = requestt.ServerVariables.Get("HTTP_X_FORWARDED_FOR").ToString().Trim();
    else
        ip = requestt.ServerVariables.Get("Remote_Addr").ToString().Trim();
    str.Append("Ip:" + ip);
    str.Append("\r\n浏览器:" + requestt.Browser.Browser.ToString());
    str.Append("\r\n浏览器版本:" + requestt.Browser.MajorVersion.ToString());
    str.Append("\r\n操作系统:" + requestt.Browser.Platform.ToString());
    str.Append("\r\n页面：" + requestt.Url.ToString());
    //str.Append("客户端IP：" + requestt.UserHostAddress);
    str.Append("\r\n用户信息：" + User);
    str.Append("\r\n浏览器标识：" + requestt.Browser.Id);
    str.Append("\r\n浏览器版本号：" + requestt.Browser.Version);
    str.Append("\r\n浏览器是不是测试版本：" + requestt.Browser.Beta);
    //str.Append("<br/>浏览器的分辨率(像素)：" + Request["width"].ToString() + "*" + Request["height"].ToString());//1280/1024                        
    str.Append("\r\n是不是win16系统：" + requestt.Browser.Win16);
    str.Append("\r\n是不是win32系统：" + requestt.Browser.Win32);
    if (IsMD5)
        return str.ToString().GetMd5_16();
    else
        return str.ToString();
}
#endregion

（当然，这个方式统计也不一定准。请求头信息改改就被伪造了。）
然后我们通过委托从线程池抓去线程异步调用

//........................异步调用....................
new SaveReadDelegate(SaveReadNum).BeginInvoke(blogobj, GetUserDistinguish(Request), null, null);

ok，统计完事。 
 

如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。      
当然您还可以加入QQ群:469075305讨论。
如果您有更好的处理方式，希望不要吝啬赐教。
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
本文链接：http://www.cnblogs.com/zhaopei/p/4887573.html 
开源地址：http://git.oschina.net/zhaopeiym/Hi-Blogs

article  44
title: 一步步学习javascript基础篇（2）:作用域和作用域链
body: 
作用域和作用域链
js的语法用法非常的灵活，且稍不注意就踩坑。这集来分析下作用域和作用域链。我们且从几道题目入手，您可以试着在心里猜想着答案。
问题一、

if (true) {
    var str = "李四";
}
alert(str);//弹出值是？

问题二、

function add(num1, num2) {
    var sum = num1 + num2;
}
add(1,2);
alert(sum) //弹出值是？

问题三、

var str1 = "张三";
var str2 = "李四";
function fun1() {
    var str2 = "王五";
    var str3 = "郑六";
    alert(str1 + str2 + str3); //弹出值是？
} fun1();

 问题四、

var num1 = 10;
function fun1() {
    alert(num1);
}
function fun2(fn) {
    var num1 = 12;
    fn();
}
fun2(fun1); //弹出值是？

 js中没有块级作用域
答案一：
if (true) {
   var str = "李四";
}
alert(str); 
     
 我们看到了，弹出值是”李四“。这说明了js中没有块级作用域（这和我们以前接触的其他语言不同）。不仅if里面是这样，for、while...等等都是这样。
如：
for (var i = 0; i < 10; i++) { }
alert(i);
     
 js中只有函数作用域和全局作用域
我们只能从外层内层作用域访问外层作用域，而外层作用域不能访问内层作用域。
 答案二：
function add(num1, num2) {
var sum = num1 + num2;
}
add(1,2);
alert(sum)

     
 （没反映？因为报异常了。不信F12看）如此，我们是访问不到sum的。因为sun是属于add函数内的作用域。  我们只能从add函数内访问到全局作用域的变量值。

js中的作用域链
 答案三:
var str1 = "张三 ";
var str2 = "李四 ";
function fun1() {
    var str2 = "王五 ";
    var str3 = "郑六 ";
    alert(str1 + str2 + str3);
}
fun1();


     
str1取全局作用域、str3去fun1函数作用域的。这里有些疑惑的是str2了。这里就引入了作用域链。
 
一般我们都说，先从自己的作用域取变量，没取到然后去父作用域中取。这句话没错，不过有时候也会产生疑惑或是混淆。如答案四：
var num1 = 10;
function fun1() {
  alert(num1);
}
function fun2(fn) {
  var num1 = 12;
  fn();
}
fun2(fun1);

     
 “先从自己的作用域取变量，没取到然后去父作用域中取”，这里fun1的父作用域是全局作用域，而不是fn()调用时fun2中的作用域。所以我们可以把这句话改成“先从自己的作用域取变量，没取到然后去自定自己的地方的父作用域中取”。

暂且分析到这里了。后续如果有新的理解再补充进来。
 

 
注意：

当循环嵌套时千万不要忘记修改循环条件的变量名如：(这样就死循环了)


for (var i = 0; i < 4; i++) {
    //......
    //......
    for (var i = 0; i < 2; i++) {
        alert("ok")
    }
    //......
    //......
}

 
 
 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/513.html
本文已同步至目录索引：一步步学习javascript
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知

 
article  45
title: 一步步学习javascript基础篇（0）:开篇索引
body: 
索引：


一步步学习javascript基础篇（1）:基本概念


一步步学习javascript基础篇（2）:作用域和作用域链


一步步学习javascript基础篇（3）：Object、Function等引用类型


一步步学习javascript基础篇（4）：面向对象设计之创建对象（工厂、原型和构造函数等模式）


一步步学习javascript基础篇（5）：面向对象设计之对象继承（原型链继承）


一步步学习javascript基础篇（6）：函数表达式之【闭包】


一步步学习javascript基础篇（7）：BOM和DOM


一步步学习javascript基础篇（8）：事件


一步步学习javascript基础篇（9）：ajax请求的回退


 
转眼做开发已经五年了。回首过来，感慨颇多。从最开始“一阳指”打字，没有任何的基础，连QQ聊天都不会。到现在已经可以独立开发勉强可以使用的博客系统。在这一路过来，从来没有认真完整的看过一本技术书籍。每每都是，兴致来了就看看，最多也就坚持那么一两天。然后要么，又对另一本感兴趣，然后整个就去干其实事情而忘记了需要每天坚持。然，可能过了几个月，又开始“上进了”，拿起那本书从头开始看，如此反复。所以，我发现有几本书，前言介绍和基本数据什么的都看过好多遍了，每次都是在看前面几页。一直都是跟着自己的兴趣走，然而都只是短暂的兴趣。到最后，发现自己很多东西都会一点，然什么东西也就只会一点点。突然之间发现自己这样下去是不行的，很难再有长进和成长了。于是乎，再次下定决心“先有深度，再有广度”，那就从前端开始吧。
有人会说，你学就学嘛。干嘛还要写博文告诉大家，怕别人知道你在学习吗？是的，我就是怕你不知道。
我为什么要写成博客：

如果我没坚持那也不好意思。也算是强迫自己的一种方式吧。
通过博文的方式，我可以和大家一起交流，有些我没发现的而您知道的问题，可以告知或探讨。
博客记录的过程会发现自己不知道却以为自己知道的问题。
如果要写清楚，那么以前有些模糊的东西肯定会彻底理解。
在做知识分析、归纳和总结的时候，可以很大程度的加深印象
在自己以后遗忘的时候，可以查阅。（毕竟自己写过的东西，更容易找）
如果能帮助到您，哪怕是一点点那也是好的。

不过，我在此先要声明下。这是学习记录，不是教程。我们可以一起学习、一起研究探讨，但我并不能保证内容一定正确，您可以指正错误，但请不要言辞刻薄。高手略过，勿喷。
本系列计划主要参考学习《javascript高级编程3》and网上相关视频and园内博文。为了方便自己随时随地看书，还特意买了个Kindle(499￥)+《javascript高级编程》电子版（25￥）。
 
article  46
title: 一步步学习javascript基础篇（1）:基本概念
body: 
一、数据类型
数据类型
基本数据类型（五种）

Undefined
Null
Boolean
Number
String

复杂数据类型（一种）

Object

Undefined：只有一个值undefined（定义了没有赋值）。
例：
var str;
alert(str);//undefined
     
注意：如果没有用var申明，直接使用会报异常（ ... is not defined）。
建议：每次var声明都赋初始值，可以减少很多意外情况。
如：
var str;
var str2="张三";
str = str + str2;
alert(str);//并不是我们意料中的“张三”
     
Null:略
Boolean：只有两个字面值： true 和 false。任何数据类型通过Boolean（）函数都可以转成Boolean类型。

String：非空字符=>true     空字符=>false
Number：任何非零=>true   0和NaN=>false
Object:任何对象=>true      null=>false
Undefined                        undefined=>false

如：
var str = Boolean(NaN);
var str2 = Boolean("张三");
var str3 = Boolean(undefined);
alert(str+" "+str2+" "+str3);
     
既然如此，我们在使用if语句的时候会自动执行相应的 Boolean 转换。

if (str) {
    //str只要是非空字符、任何非零数字、任何非null对象 都是true
    //str只要是空字符、0、NaN、null、undefined 都是false
    //这样就省去了 我们一个个的判断了
    alert("true");
}

 String：略
二、操作符 
递增和递减操作符：
【++num、--num、num++、num--】
var age = 3, age2 = 3;
age++;
++age2;
alert(age+"  "+age2);
     
都是4，好像看不出有什么不同。
var age = 3, age2 = 3,num1 ,num2;
num1 = age++ + 1;
num2 = ++age2 + 1;
alert(num1+"  "+num2);
     
 好，区别来了。一个任然是4，一个变成了5。为什么会这样呢？优先级不同而已，age++先执行运算符+然后在自身加1，++age先自身加1然后再通过+运算符加1。
位操作符：
【按位非NOT(~)、按位与AND(&)、按位或OR(|)、按位异或XOR(^)、左移(<<)、有符号的右移(>>)、无符号右移(>>>)】其实平时我们很少用到，这里稍作了解。
例：按位非

var num1 = 25; // 二进制 00000000000000000000000000011001
var num2 = ~num1; // 二进制 11111111111111111111111111100110
alert(num2); // -26 

例：按位与

var result = 25 & 3;
alert(result); //1
//*********************
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 =  0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001 

例：按位异或


var result = 25 ^ 3;
alert(result); //26
//*************
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3 =  0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010 //十进制值 26 

例：左移

var oldValue = 2; // 等于二进制的 10
var newValue = oldValue << 5; // 等于二进制的 1000000，十进制的 64

例：有符号右移

var oldValue = 64; // 等于二进制的 1000000
var newValue = oldValue >> 5; // 等于二进制的 10 ，即十进制的 2 

例：无符号右移（这个差异有点大，因为第32为1代表负数的值也移过来了）

var oldValue = -64; // 等于二进制的 11111111111111111111111111000000
var newValue = oldValue >>> 5; // 00000111111111111111111111111110 等于十进制的 134217726

 
布尔操作符：
【逻辑非(!)、逻辑与（&&）、逻辑或（||）】
这里需要说的就是&&和||是短路操作。||如果前面一个满足条件了就不检测后面的条件了，&&相反前面一个不满足条件就不检测后面的条件了。例：

var age = 3;
if(age||aaa){//这里的age转Boolean为ture，所以后面的aaa就不检测了。
alert(age);}
if(aaa||age){//这里将会报错
alert(age);}

测试：
var age = 3;
if(age||aaa){//这里的age转Boolean为ture，所以后面的aaa就不检测了。
alert(age);}
if(aaa||age){//这里将会报错
alert(age);}
     
这里可以告诉大家一个小小的技巧，很多时候我们并不知道某个变量是否有值，但是我们又需要正常使用，那么我们可以给个备胎。
如：浏览器的兼容问题，在旧式浏览器中是用window.event来取事件的相关属性值，新式浏览器中是直接通过形参的形式传过来的。我们就可以。

function myonclick(ev) {
    var myevent = ev || window.event;//这样就可以保证新旧浏览器的兼容了
}

实验:　　
var obj = null;
var obj2 = obj||"备胎";
alert(obj2);
     
加性操作符：
【加法（+）、减法（-）】这个再熟悉不过了，不过还是有一点需要注意。

var strnum1 = "5";
var num2 = strnum1 + 3;
var num3 = strnum1 - 3;
alert("num2="+num2+" num3="+num3);//这里会是什么结果呢？

让我们来测试一下吧。
var strnum1 = "5";
var num2 = strnum1 + 3;
var num3 = strnum1 - 3;
alert("num2="+num2+" num3="+num3);//这里会是什么结果呢？
     
为什么会这样？字符串和数字相加，数字会转为字符串。字符串和数字相减，字符串转为数字。
相等操作符
var num1 = "5";
var num2 = 5;
var isEqual = num1==num2;
alert("num1是否等于num2："+ isEqual);
     
奇怪吧，字符串怎么和数字相等。是的，这里用到了自动转型。但是，我们不想看到这样的结果怎么办？
var num1 = "5";
var num2 = 5;
var isEqual = num1===num2;
alert("num1是否等于num2："+ isEqual);
     
是的，我们可以用===全等于。不仅比较数值，还比较类型。
三、语句
for-in语句
for循环语句用得多，for-in可能平时就用的较少了。（for-in循环应该用在非数组对象的遍历上，使用for-in进行循环也被称为“枚举”。）
例：
var obj = {id:2,name:"张三"};
var str = "";
for(o in obj)
{
   str += "属性："+ o + " 值：" + obj[o] + "    ";
}
alert(str);
     
label语句
感觉和C#中的goto很像，但又不一样。
我们平时有没有过在多个循环嵌套里面想跳出第二层循环？一般我们只能用break或者continue跳出最里面的循环，或者return跳出整个函数。万万没想到的是，还有一个label语句，可以跳出任意层循环。例：
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
    for (var j=0; j < 10; j++) {
        if (i == 5 && j == 5) {
          break outermost;
        }
        num++;
    }
}
alert(num); //55
     
 好了，第一篇差不多就整理到这里了。最后出几个有趣的题目给大家。

一、为什么 1＝0.9999999999…… 
二、为什么 alert(0.1 + 0.2)//0.30000000000000004
三、为什么 alert(0123 + 4)//87
四、
var obj1 = {}; obj1.name2 = "张三";
var str1 = "test"; str1.name2 = "李四";
alert(obj1.name2 + " " + str1.name2);
//弹出值是什么
五、
var obj1 = { name2: "111" };
var obj2 = obj1;
obj1.name2 = "222";
alert(obj2.name2);//这里弹出什么？
obj1 = { name2: "333" };
alert(obj2.name2);//这里弹出什么？
六、
 var fun = function (num1) {
     if (num1 <= 1) {
         return 1;
     }
     else {
         return num1 * fun(num1 - 1);
     }
 }
 var fun2 = fun;
 fun = function () {
     return 1;
 }
 alert(fun2(5));//这里弹出什么？ 

有兴趣的同学可以思考或者翻阅资料。
 

这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/511.html
本文已同步至目录索引：一步步学习javascript
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知

 
article  47
title: 免费图片存储和图话【提供demo下载】
body: 

我们不管是做博客系统还是其他网站，图片是免不了要使用到的。但是，我们都知道图片的访问是很耗资源的，同时也是很占磁盘空间的，且还特别占带宽。
所以，我们一般都会用到特定的图片服务器。不过，像我等屌丝平时闹着玩肯定是不会花钱整那些东西。今天我就来介绍一个高速免费无限量图片存储支持外链。是的，你没听错。就是无限量免费。它的名字：贴图库，可能有同学知道并且使用过了。那你可以略过了。
介绍完贴图库后，我在向大家介绍下。我的图话实现。图话是什么？就是我们经常看到的弹幕，只不过现在到了图片上面了。演示地址。

贴图库
其实官网已经有比较详细的文档了：http://open.tietuku.com/doc
官网提供了php的sdk，以前记得也有java的，但是没见过有.net。没办法，只能自己写了。
其实这个我不想做过多的讲解了，等下我提供demo下载，对着官方文档自己就看得懂了。我直接讲下怎么使用。
第一步：导入 TietukeLib.dll 。
就是我自己写的一个类库。
第二步：在 Global.asax 中系统启动时设置 AccessKey和SecertKey ，可在http://open.tietuku.com/manager查看到。

protected void Application_Start()
{
    TokenHelp.AccessKey = "";
    TokenHelp.SecertKey = "";

 

第三步：在页面访问是后台获取TeKen，然后在页面的空间里面设置TeKen值。
后台(相册ID查看：http://open.tietuku.com/album)

 public static string TeKen_File = string.Empty;
 public static string TeKen_WebUrl = string.Empty;

 public ActionResult Index()
 {
     TeKen_File = TietukeHelp.GetToken(相册ID, "file");//文件上传
     TeKen_WebUrl = TietukeHelp.GetToken(相册ID, "web");//weburl上传
     return View();
 }

前台

<div style="margin: 5px; padding: 5px; border: 1px dashed #0094ff">
    <form enctype="multipart/form-data" method="post" action="http://up.tietuku.com/">
        <input name="Token" value="@(Hi.Web.Controllers.TieTuKuController.TeKen_File)" type="hidden">
        <input type="file" name="file">
        <input type="submit">
    </form>
</div>

<div style="margin:5px;padding:5px;border:1px dashed #0094ff">
    <form method="post" action="http://up.tietuku.com/">
        ImgUrl:<input name="Token" value="@(Hi.Web.Controllers.TieTuKuController.TeKen_WebUrl)" type="hidden">
        <input type="text" name="fileurl">
        <input type="submit">
    </form>
</div>

效果图：
演示地址：http://hi.haojima.net/TieTuKu/Index
经过上面的介绍，如果您只是想在网页上简单的使用，并且不关系源码的话，了解了上面的就行了。直接下载TieTuKuLib.dll【注意：版本是.NET Framework4.5】。
 
如果您想在通过非网页的形式，也就是后台直接通过图片文件路径或网络图片地址进行上传的话，那就继续听我往下分析。
所说的后台传图片，其实就是用 System.Net.Http.dll 中的 HttpClient 来模拟get或者post请求。
这几个方法我也封装到了上面的TieTuKuLib.dll文件里面。直接TietukeLib.Help.PostReqest可以发送内容post请求，TietukeLib.Help.PostFileReqest发送图片和文字内容post请求。（当然，我的命名不规范。您可以拿到源码后自己修改下命名。我这里就懒得改了）
例：

/// <summary>
/// 根据url图片源 上传到指定相册id的相册
/// </summary>
/// <param name="url">url图片源</param>
/// <param name="c_aid">相册id(http://open.tietuku.com/album页面可以查看到)</param>
/// <returns></returns>
public static string PostUrlImg(string url, int c_aid)
{
    var data = (TokenHelp.DateTimeToUnixTimestamp(DateTime.Now) + 60).ToString();
    var a_data = new { deadline = data, aid = c_aid, from = "web" };
    StringBuilder str_content = new StringBuilder();
    str_content.Append("Token=" + TokenHelp.GetToken(a_data));
    str_content.Append("&fileurl=" + url);
    return TietukeLib.Help.PostReqest("http://up.tietuku.com/", str_content.ToString());
}

例：

/// <summary>
/// 根据本地文件流 上传到指定相册id的相册
/// </summary>
/// <param name="c_aid">相册id</param>
/// <param name="imageStream">文件流</param>
/// <param name="imgName">文件名</param>
/// <returns></returns>
public static string PostImgData(int c_aid, FileStream fileStream, string imgName)
{

    var data = (TokenHelp.DateTimeToUnixTimestamp(DateTime.Now) + 60).ToString();
    var a_data = new { deadline = data, aid = c_aid, from = "file" };
    StringBuilder str_content = new StringBuilder();
    str_content.Append(TokenHelp.GetToken(a_data));
    return Help.PostFileReqest("http://up.tietuku.com/", fileStream, str_content.ToString(), imgName);
}

关于贴图库的介绍就到这里了。其实，你看懂了上面的，完全可以自己建一个免费的图片网站了，什么图片网？当然是MM图片网。，其实我自己就建了一个，只是尺度有点大，就不放出链接了。然后我的博客系统也打算用这个来存图片。
有了图片，我们还可以整点别的好玩的东西-->"图话"，这就是接下来要分析的了。全部的源码下面再给出，和图话源码和一起。
 
图话
图话，说白了就是我们平时看视频上面飘来飘去的评论。现在我们只是把它飘到了图片上，就叫图话了。
当我看到图话的效果时，第一感觉就是好神奇哦，然后就是挺有意思的。然后就想自己拿来玩玩，结果找了下，没找到类似的插件。没办法，那就自己继续折腾折腾吧。
其实，仔细想想也挺简单的。飘来飘去，不就是一个div不断移动就可以了吗？是的，就是这么简单。我们很时候，都是被效果转移了注意力，而根本就没去想要去怎么实现它，或者以为会很难而懒得动手了。
好，我们说动就动。
先看效果图：

 首先，你需要在图片上显示评论消息，那么必须要图片上层添加一个div作为容器，然后再去div上显示文字。
1、怎么在图片上添加一个层div？

position: absolute

 “生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。”，我们暂且称为图话容器。
2、怎么样在“图话容器”中显示文字？
直接在“图话容器”里面添加div可以了，为了更好的控制在容器里面的位置和让其包裹文字，我们继续设置样式absolute。
3、怎样移动文字？
用js的定时器setInterval来不断改变文字所在div的位置left。
下面我们用代码说话。图片上层的div容器大小肯定要和图片大小一样。这里我们就需要动态读取加载的图片大小然后进行对应的设置。
图片加载时：

//图片加载时
function imgLoad(obj) {
    var str_html = $(".mb").html();//取模版"图话容器"
    var par = $(obj).parent();//取到img的父容器
    par.prepend(str_html);//添加到img的上面
    par.find(".div1").css("width", $(obj).css("width"));//设置容器的宽度和img一样
    par.find(".div1").css("height", 100);
    var strs = $(obj).attr("src").split('/');
    var imgName = strs[strs.length - 1];
    imgName = isc(imgName);
    $(obj).attr("name", imgName);
    msgKey[msgKey.length] = imgName;
    msgData[imgName] = ["test1:弹一下吧1", "test2:弹一下吧2", "test3:弹一下吧3", ];
    setInterval(function () {//定时器 不断执行
        par.find(".div11").each(function () {//取到所有的 评论文字 所在div
            mesgCycle(this, msgData[imgName]);
        });
    }, "10");
}

 
图话“容器模版”

<div class="mb" style="display:none">
    <div class="div1" style="background-color: rgba(0,0,0,0.3); position: absolute;overflow:hidden;">
        <div class="div11" style="top: 11px; left: 50px; font-size: 20px; color: rgba(0,0,0,0.3); position: absolute; overflow: hidden;">
            test:测试1
        </div>
        <div class="div11" style="top: 28px; left: 90px; font-size: 20px; color: #ff6a00; position: absolute; overflow: hidden; "></div>
        <div class="div11" style="top: 51px; left: 40px; font-size: 20px; color:#4cff00; position: absolute; overflow: hidden; ">test3:test3</div>
        <div style="position:absolute;bottom:0px;width:100%">
            <div class="but_div" style="display: table; margin: 0 auto">
                <input type="text" class="inp" /><input type="button" onclick="but(this);" value="弹一个" />
            </div>
        </div>
    </div>
</div>

 
定时执行移动坐标：

//接收 文字所在div  和 消息
function mesgCycle(element, mesg) {
    var elementRight = parseInt($(element).css("left"));
    var elementWidth = parseInt($(element).css("width"));
    var imgWidth = parseInt($(element).parents(".div_pack").find("img").css("width"));
    $(element).css("left", elementRight - 1);//移动一个单位坐标
    if ((elementRight + elementWidth) == 0) {//如果完全容器
        mesg[mesg.length] = mesg[0];
        $(element).text(mesg.shift());//取下一条消息
        $(element).css("left", imgWidth - parseInt($(element).css("width")));//重新设置初始坐标
        $(element).css("color", getColor());//更好文字颜色
    }
}

 
好了，关键代码就这些了。下面给出全部源码。

首先，我并非专业前端。肯定有很多用的不合适和不合理的（我只是瞎折腾），希望园友给出更好的解决方案。如果您觉得此文对您有那么一点点用，请轻轻点个赞。
演示地址：http://haojima.net/demo/tuhua
源码下载：http://pan.baidu.com/s/1qW3n3AG
(注意：demo里面要设置你自己的 相册ID、AccessKey 和 SecertKey )
本文链接：http://www.cnblogs.com/zhaopei/p/4931518.html 
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知

 
 

 
ps:演示地址是高圆圆和范冰冰选美pk，事实证明，喜欢高圆圆的要多过范冰冰啊。赶快为你心仪的女神投上一票吧。

 
article  48
title: 一步步学习javascript基础篇（3）：Object、Function等引用类型
body: 
我们在《一步步学习javascript基础篇（1）:基本概念》中简单的介绍了五种基本数据类型Undefined、Null、Boolean、Number和String。今天我们主要介绍下复杂数据类型（即引用数据类型）
Object类型
我们用的最多的引用类型就属object类型了，一般用来存储和传输数据是再好不过的。然，它的两种创建方式我们是否了解呢？
1、通过构造函数来创建
如： var obj = new Object(); 
在js中的引用类型有个非常灵活的用法，可以动态的附加属性和赋值。
如：

var obj = new Object();
obj.name = "张三";//动态添加属性并赋值
obj.age = 23;

alert(obj.name);

2、通过字面量表示法来创建对象
现在大家用得比较多的就是字面量表示法来创建对象了。
如：

var obj = {
    name: "张三",
    age: 23
};
alert(obj.age);

和上面的效果是等效的。通过这样方式创建感觉结构更加的清晰，更加有封装的感觉。：）
我们还可以这样用
如：

var obj = {};
obj.name = "张三";
obj.age = 23;
alert(obj.age);

如：

var obj = {
    "name": "张三",//给属性加上双引号
    age: 23
};
alert(obj.name);

是不是感觉很强大很灵活呢？我在访问属性的时候一般都是点出来，但是还有另外的方式。
如：(我们可以使用中括号的形式来访问属性值)

var obj = {
    "name tow": "张三",
    age: 23
};
//alert(obj.name tow);//这里会报错，属性不能有空格
alert(obj["name tow"]);//这里可以正常弹出

例：
var obj = {
  "name tow": "张三",
  age: 23
};
//alert(obj.name tow);//这里会报错，属性不能有空格
alert(obj["name tow"]);//这里可以正常弹出

      
Array类型
除了object之外，应该属数组用的最多了。下面来罗列下常见用法。
同样Array也有两种创建方式:

var arr = new Array(1, 2, 3, 4, 5);//通过构造函数创建
var arr2 = [5, 4, 3, 2, 1];//通过字面量表达式来创建 

上面两种方式是等效的，我们可以直接通过下标的方式来访问数组： alert(arr[2]); 。
如果我们想要打印数组中所有的值，直接打印数组的变量名就可以：

var arr2 = [5, 4, 3, 2, 1];//通过字面量表达式来创建
var str2 = "";
for (var i = 0; i < arr2.length; i++) {
    str2 += arr2[i] + ","
}
alert(str2);//打印拼接的字符串        
alert(arr2);//直接打印变量名（实际上会自动调用数组的toString方法）

例：
var arr2 = [5, 4, 3, 2, 1];//通过字面量表达式来创建
var str2 = "";
for (var i = 0; i < arr2.length; i++) {
  str2 += arr2[i] + ","
}
alert(str2);//打印拼接的字符串

     
 例：
var arr2 = [5, 4, 3, 2, 1];//通过字面量表达式来创建
alert(arr2);//直接打印变量名（实际上会自动调用数组的toString方法）

     
上面直接打印arr2，我们发现默认都是以逗号分隔的。那么有时候，我们不想用逗号怎么办呢。那你可能可以用到join方法
var arr2 = [5, 4, 3, 2, 1];//通过字面量表达式来创建
alert(arr2.join('_'));//直接打印变量名（实际上会自动调用数组的toString方法）

     
往数组添值：
我们可以直接： arr2[4] = 7; arr2[5] = 8;  
还有一种更加巧妙地添值方式： arr2[arr2.length] = 9; arr2[arr2.length] = 10; ，下标length刚好是数组最大长度的下一个，添加值后length再次动态自动累计。
栈方法、队列方法：
什么是栈？（后进先出）。什么是队列？（先进先出），我们怎样用数组来模仿这种数据结构的访问方式？下面通过一张图来解释下数组对象提供的四个方法。

从图可以看出：shift和push、unshift和pop的组合可以实现栈的数据结构访问，shitf和pop、shift和unshift的组合可以实现队列的数据机构访问方式。 这里需要注意：pop和shift取数据的同时，数组中对于的值也同时移除了。
例：
var arr2 = [5, 4, 3, 2, 1];
alert("arr2.pop：" + arr2.pop() + "  arr2：" + arr2);

     
 关于数组的排序：
关于数组的排序有sort（正）reverse（反）。
先看个例子，大家猜想下结果：

var arr2 = [5, 14, 23, 12, 1];
alert(arr2.sort());

 然结果并不是我们想要的：
var arr2 = [5, 14, 23, 12, 1];
alert(arr2.sort());

     
 为什么会这样呢？因为sort不会直接比较数字类型，而已转为string了再做的比较。那么我们想要比较数字怎办？我们可以往sort传函数，例：
function mycompare(o1, o2)
{
   return o1 - o2;//如果为正数则o1大，负数则o2大，零则相等。
}
var arr2 = [5, 14, 23, 12, 1];
alert(arr2.sort(mycompare));

     
 有人会问o1和o2是怎么来的？这是sort函数规定的。这样说大家可能不好接受。下面，我们自己来模拟下sort的排序，大家就明白了。

var arr2 = [5, 14, 23, 12, 1, 123, 23, 4, 5, 6, 32, 5, 3, 2, 1];
arr2.mysort = function (fun) {
    //*********************具体排序过程*******************
    for (var i = 0; i < arr2.length - 1; i++) {
        for (var j = 0; j < arr2.length - i; j++) {
            if (fun(arr2[j], arr2[j + 1]) > 0) {//这里用我们传进来的方法判断是否要排序调换位置
                var temp = arr2[j];
                arr2[j] = arr2[j + 1];
                arr2[j + 1] = temp;
            }
        }
    }
    //***************************************************
    return arr2;
} 
function mycompare(o1, o2) {
    return o1 - o2;//回调函数（具体的比较规则）
}
alert(arr2.mysort(mycompare));

var arr2 = [5, 14, 23, 12, 1, 123, 23, 4, 5, 6, 32, 5, 3, 2, 1];
arr2.mysort = function (fun) {
    //*********************具体排序过程*******************
    for (var i = 0; i < arr2.length - 1; i++) {
        for (var j = 0; j < arr2.length - i; j++) {
        if (fun(arr2[j], arr2[j + 1]) > 0) {//这里用我们传进来的方法判断是否要排序调换位置
            var temp = arr2[j];
            arr2[j] = arr2[j + 1];
            arr2[j + 1] = temp;
            }
        }
    }
    //***************************************************
    return arr2;
}
function mycompare(o1, o2) {
 return o1 - o2;//回调函数（具体的比较规则）
}
alert(arr2.mysort(mycompare));

     
 当然，我们模拟的并不是那么的好，大概就是这么个意思。
反序就简单了：（直接reverse()就可以了）

function mysort(o1, o2)
{
    return o1 - o2;//如果为正数则o1大，负数则o2大，零则相等。
}
var arr2 = [5, 14, 23, 12, 1];
arr2.sort(mysort);
arr2.reverse();
alert(arr2);

 数组的一些操作方法：
 concat创建一个新的副本，并合并传进来的参数

var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brow

slice创建一个新的副本，取数组的位置数据

var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);//从下标为1的开始，到末尾
var colors3 = colors.slice(1, 4);//从下标1（包含1）到4（不包含4）
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow

splice会改变原数组数据，可实现对数组的删、插和替换

var colors = ["red", "green", "blue"];
//****************删**********************
var removed = colors.splice(0, 1); // 删除第一项（从下标0开始，删除1项）
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项
//****************插**********************
removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项（从下标1开始，删除0项，并插入后面的参数数据）
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组
//****************替换**********************
removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项（从下标1开始，删除1项[也就是yellow]，并插入后面的参数数据）
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项

 
查找位置方法
indexOf()和 lastIndexOf()，就是查找在数组中的位置，和string中的对应方法差不多。
迭代方法
 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。以上方法都不会修改数组中的包含的值。
如：

var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
return (item > 2);
});
alert(everyResult); //false

 其中。forEach和map区别不大，只是一个有返回值，一个没有。实际中我们用forEach比较多，下面我们模拟forEach的实现。

var str = "", str2 = "";
var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
numbers.forEach(function (item, index, array) {
    str += item + "_";
});
//**************其实我们完全可以自己模拟实现*******
numbers.myforEach = function (fun) {
    for (var i = 0; i < numbers.length; i++) {
        fun(numbers[i], i, numbers);
    }
}
numbers.myforEach(function (item, index, array) {
    str2 += item + "*";
})
//***************************************************
alert("str：" + str + "  str2：" + str2);

var str = "", str2 = "";
var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
numbers.forEach(function (item, index, array) {
  str += item + "_";
});
//**************其实我们完全可以自己模拟实现*******
numbers.myforEach = function (fun) {
    for (var i = 0; i < numbers.length; i++) {
      fun(numbers[i], i, numbers);
    }
}
numbers.myforEach(function (item, index, array) {
  str2 += item + "*";
})
//***************************************************
alert("str：" + str + "  str2：" + str2);

     
 归并方法
 reduce()和 reduceRight()，这两个方法是比较有意思的，以前还真没接触过。先看例子，再解释：

var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
    return prev + cur;
});
alert(sum); //15

也是个循环，第一次执行 prev 是 1， cur 是 2。第二次， prev 是 3（1 加 2 的结果）， cur 是 3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。reduceRight只是方向相反。下面我们来模拟：

var numbers = [1, 2, 3, 4, 5, 3];
var sum = numbers.reduce(function (prev, cur, index, array) {
    return prev + cur;
});
//***********************模拟实现reduce**************************
numbers.myreduce = function (fun) {
    for (var i = 0; i < numbers.length; i++) {
        var temp = 0;
        for (var j = 0; j < i; j++)
            temp += numbers[j];
        var tempNum = fun(temp, numbers[i], i, numbers);
    }
    return tempNum;
}
//*************************************************
var sum2 = numbers.myreduce(function (prev, cur, index, array) {
    return prev + cur;
})
alert("sum：" + sum + "  sum2：" + sum2); //

var numbers = [1, 2, 3, 4, 5, 3];
var sum = numbers.reduce(function (prev, cur, index, array) {
  return prev + cur;
});
//***********************模拟实现reduce**************************
numbers.myreduce = function (fun) {
for (var i = 0; i < numbers.length; i++) {
    var temp = 0;
    for (var j = 0; j < i; j++)
        temp += numbers[j];
          var tempNum = fun(temp, numbers[i], i, numbers);
        }
        return tempNum;
}
//*************************************************
var sum2 = numbers.myreduce(function (prev, cur, index, array) {
   return prev + cur;
})
alert("sum：" + sum + "  sum2：" + sum2); //

     
Date类型
我们很多时候需要测试一个函数的性能，可以取它的执行进过时间：

//取得开始时间
var start = Date.now();
//调用函数
doSomething();
//取得停止时间
var stop = Date.now(),
result = stop – start;

下面列出一些常用方法

getTime() 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒) 以毫秒数设置日期，会改变整个日期
getFullYear() 取得4位数的年份（如2007而非仅07）
getUTCFullYear() 返回UTC日期的4位数年份
setFullYear(年) 设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年) 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth() 返回日期中的月份，其中0表示一月， 11表示十二月
getUTCMonth() 返回UTC日期中的月份，其中0表示一月， 11表示十二月
setMonth(月) 设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) 设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate() 返回日期月份中的天数（1到31）
getUTCDate() 返回UTC日期月份中的天数（1到31）
setDate(日) 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) 设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
getDay() 返回日期中星期的星期几（其中0表示星期日， 6表示星期六）
getUTCDay() 返回UTC日期中星期的星期几（其中0表示星期日， 6表示星期六）
getHours() 返回日期中的小时数（0到23）
getUTCHours() 返回UTC日期中的小时数（0到23）
setHours(时) 设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时) 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes() 返回日期中的分钟数（0到59）
getUTCMinutes() 返回UTC日期中的分钟数（0到59）
setMinutes(分) 设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) 设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds() 返回日期中的秒数（0到59）
getUTCSeconds() 返回UTC日期中的秒数（0到59）
setSeconds(秒) 设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) 设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() 返回日期中的毫秒数
getUTCMilliseconds() 返回UTC日期中的毫秒数
setMilliseconds(毫秒) 设置日期中的毫秒数
setUTCMilliseconds(毫秒) 设置UTC日期中的毫秒数
getTimezoneOffset() 返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返回300。在某地进入夏令时的情况下，这个值会有所变化

RegExp类型
两种表示法：
1. var pattern1 = /at/g; 
2. var re = new RegExp("cat", "g"); 
后面的参数代表模式，如：g：表示全局（global）模式、i：表示不区分大小写（case-insensitive）模式、m：表示多行（multiline）模式关于正则了解不是很清楚，后期有机会在单独学习整理正则这块。
Function类型
三种表示法：
1. function sum (num1, num2) { return num1 + num2; } 
2. var sum = function(num1, num2){ return num1 + num2; }; 
3. var sum = new Function("num1", "num2", "return num1 + num2");  
 以上三种都是可行的，不过我们平时用得比较多的是第一种，第二种也有用，第三种用得比较少，但是最能看出function的本质，其实就是一个Function对象的实例。
我们来看看1和2的区别。

alert(sum1(1, 2));//弹出值 3
alert(sum2(1, 2));//报异常[sum2 is not a function]
function sum1(num1, num2) { return num1 + num2; }
var sum2 = function (num1, num2) { return num1 + num2; };

因为js解析器是从上到下的解析，在执行sum2的时候还没有定义，所以报异常。但是sum1比较特殊，是申明式的。在执行sum1之前就会”预解析“（函数声明提升）。相当于把sun1的定义提到了最上面(放到源代码树的顶部)。
方法重载
严格来说，js中是没有方法重载的，不过我们可以根据参数的个数来模拟。（还有，js中函数的形参我们是不确定类型的）
例：
function sum1(num1, num2) {
  return num1 + num2;
}
function sum1(num1, num2, num3) {
  return num1 + num2 + num3;
}
alert(sum1(1, 2));

     
上面并没有出现我们预料中的结果，因为第二次定义的sun1不是实现的重载，而是直接覆盖了第一次的定义。下面，我们就简单的模拟实现方法重载：

function sum1(num1, num2, num3) {
    if (num1 != undefined && num2 != undefined && num3 != undefined) {
        return num1 + num2 + num3;
    }
    else if (num1 != undefined && num2 != undefined)
        return num1 + num2;
}
alert(sum1(1, 2));
alert(sum1(1, 2, 3));

 
函数内部属性（arguments 和 this）
arguments:类数组对象，包含着传入函数中的所有参数。下面通过arguments实现上面的模拟重载:

function sum1(num1, num2, num3) {
    var temp = 0;
    if (arguments.length == 3) {
        //***********具体实现其逻辑*********************
        for (var i = 0; i < arguments.length; i++) {
            temp += arguments[i];
        }
    }
    else {
        //***********具体实现其逻辑*********************
        for (var i = 0; i < arguments.length; i++) {
            temp += arguments[i];
        }
    }
    return temp;
}
alert("1+2=" + sum1(1, 2) + "  1+2+3=" + sum1(1, 2, 3));

function sum1(num1, num2, num3) {
var temp = 0;
if (arguments.length == 3) {
//***********具体实现其逻辑*********************
for (var i = 0; i < arguments.length; i++) {
temp += arguments[i];
}
}
else {
//***********具体实现其逻辑*********************
for (var i = 0; i < arguments.length; i++) {
temp += arguments[i];
}
}
return temp;
}
alert("1+2=" + sum1(1, 2) + "  1+2+3=" + sum1(1, 2, 3));

     
我们在第一篇博文里面有提一个问题：

六、
 var fun = function (num1) {
     if (num1 <= 1) {
         return 1;
     }
     else {
         return num1 * fun(num1 - 1);
     }
 }
 var fun2 = fun;
 fun = function () {
     return 1;
 }
 alert(fun2(5));//这里弹出什么？ 

 不过，并没有同学去解答，有人可能觉得太简单，或是不乐意懒得去解答。这题的答案是：
var fun = function (num1) {
if (num1 <= 1) {
return 1;
}
else {
return num1 * fun(num1 - 1);
}
}
var fun2 = fun;
fun = function () {
return 1;
}
alert(fun2(5));//这里弹出什么？

     
 为什么会是这个答案呢？好像和我们预料中的不一样。下面我们图解：

我们可能发现了一个问题，那就是第4步调用的已经不是所在的这个函数本身了（也就是没有递归了），这不是我们想要的。我们要的是，不管外面怎么改变，4处都代表所在的函数指针。那么我们可以用到arguments的callee方法，例：
var fun = function (num1) {
if (num1 <= 1) {
return 1;
}
else {
return num1 * arguments.callee(num1 - 1);
}
}
var fun2 = fun;
fun = function () {
return 1;
}
alert(fun2(5));//这里弹出什么？

     
 函数的另一个内部属性this：
 首先我们看看这样一个问题：

var color = "red";
var o = { color: "blue" };
function sayColor() {
    alert(this.color);
}
sayColor(); //"red"
o.sayColor = sayColor;
o.sayColor(); //"blue"

为什么会有不同的结果？我们记住一句话，一般情况"哪个对象点出来的方法，this就是哪个对象"。上面的例子其实等效于：

window.color = "red";
var o = { color: "blue" };
function sayColor() {
    alert(this.color);
}
window.sayColor(); //"red"
o.sayColor = sayColor;
o.sayColor(); //"blue" 

 虽然"哪个对象点出来的方法，this就是哪个对象"，但是有时候我们不想要这样的结果，我们不想用对象点或者对象点出了想this是另外的对象。那么我们可以使用call：
var o = { color: "blue" };
var o2 = { color: "red" };
function sayColor() {
alert(this.color);
}
//sayColor.call(o);
sayColor.call(o2);

     
 传如的第一个参数，直接赋值给函数里面的this。和call类似的有apply，区别看下面：

 var o = { color: "blue" };
 var o2 = { color: "red" };
 function sayColor(a, b) {
     alert(this.color + a + b);
 }
 sayColor.apply(o, [1, 2]);//只传两个参数，第一个是为this赋值的对象，第二个是函数实参数组
 sayColor.call(o2, 1, 2);//可以传多个参数，第一个是为this赋值的对象，后面的是函数实参用逗号分割

基本包装类型
 在这个系列的第一篇中有个问题：

四、
var obj1 = {}; obj1.name2 = "张三";
var str1 = "test"; str1.name2 = "李四";
alert(obj1.name2 + " " + str1.name2);

//四、
var obj1 = {}; obj1.name2 = "张三";
var str1 = "test"; str1.name2 = "李四";
alert(obj1.name2 + " " + str1.name2);

     
 为什么会是这样的结果？因为str1.name2设置值的时候访问的是string的包装类，然后再次访问str1.name2之前就把之前那个包装类已经被销毁。
为什么要有包装类？
因为可以像操作引用对象一样操作基本数据类型，如： var s1 = "some text"; var s2 = s1.substring(2); 
哪些基本类型有包装类?
Boolean、Number和String类型。
浏览器的内置对象
Global（其实也就是我们平时用的window）和Math（一些计算功能）
URI 编码方法
encodeURI、encodeURIComponent、decodeURI、decodeURIComponent

//encodeURI主要对完整的url进行编码(空格会编码成%20)【对应该的解码decodeURI】
alert(window.encodeURI("http://i.cnblogs.com/EditPosts.aspx?postid = 5002381"));
//encodeURIComponent会把url中的所有特殊字符进行转码（所以，我们一般用来进行部分url转码，如Url中的参数）【对应的解码decodeURIComponent】
alert(window.encodeURIComponent("http://i.cnblogs.com/EditPosts.aspx?postid = 5002381"));

 
eval这是一个js中最最最强大的函数了，相对与一个独立的解析器。如我文中的操作实例就是用这个函数实现的。如：

    <textarea class="test_code" style="width: 80%;height:220px; max-height: 200px;">

//。。。。这里面写js代码
var obj1 = {}; obj1.name2 = "张三";
var str1 = "test"; str1.name2 = "李四";
alert(obj1.name2 + " " + str1.name2);

    </textarea>
    <input type="button" class="test_code_but" onclick="eval($(this).prev().val());" value="运行" />

效果图：当然，你还的引入jqeruy问题，博客园中默认就已经引入了。所以，你不需要再次引入，你测试的话是看不到alert弹框的，因为博客园禁掉了。我的是用的jquery ui中的Dialog对话框做的。
总结

码字真累，不知不觉已经从中午十二点已经到了晚上八点了，没想到一篇这样的文章断断续续尽然花了我七八个小时的时间。感觉越到后面越没有耐心，还好现在终于写完了。
这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/515.html
本文已同步至目录索引：一步步学习javascript
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知
如果您觉得文章对您有那么一点点帮助，那么麻烦您轻轻的点个赞，以资鼓励。

 
article  49
title: 我们为什么应该坚持写博客
body: 
种种原因：
我们很多人都有过写点东西的冲动，只是又因为种种原因没有发表。

写着写着，挤不出字来了。
总感觉自己的内心想法表达不出来。
感觉写了没什么用，自己都明白了干嘛还要写。
怕写出来被人笑话被人喷。（这个也是我经常害怕的）
写博客的费脑力，耗时间。还不如拿这精力去再学更多的东西。

关于以上几点我的理解：

第一点：万事开头难，我们不管做什么事，最难的就是从零到一的过程。只要你跨过了，什么都是那么的自然。不管写的多差，你就要坚持，然后慢慢得就有了感觉。
第二点：从一个方面说明，我们的表达能力还不行（这正好可以锻炼我们的表达能力）。从另一方面也说明，你对这个问题或是知识点了解得还不够透彻。如果你知道了来龙去脉、前因后果不会说不清除的（借此我们可以更加深入的学习）。
第三点：写博客当然有用，不然那么多牛人为什么写博客。首先，人都有一个遗忘规律。现在你认为已经烂记于心的东西，几个月后说不定就模糊了。其实，很多时候我们都是在反复的记忆遗忘做斗争。不说别的，现在要你写个数据库ado连接你写得出来吗？现在要你写个原生的ajax你写得出来吗？其实，这都是我们读书的时候就写过好多遍的，不如工作中不是经常手动去写很可能现在就忘记了。然，我们写博客有效的加深记忆。万一，还是忘记了，我们查找自己的博客也是很快就能回忆起来的。（其实，我们很多时候都是在反复的在学以前学过的东西，如果我们能过目不忘以前所接触、所学过的，我们一定是牛人了）
第四点：笑就笑呗，哪个牛人不是从菜鸟过来的。我不写教程，我写笔记写心得总可以吧。喷子，是少不了的。就是世上的蚊子无法灭绝。（正好可以锻炼你强大的内心）
第五点：费脑力，确实。耗时间，也是。不过这是值得的。为什么这么说，不管做什么，都是要有付出的。（不过，在后期越写越顺，脑力和时间也就越用越少，就像平时说话那么自然）

好处多多：

可以结交更多的朋友。和同档次和高于你档次的人做朋友，你可以学到很多。（近朱者赤，同道的朋友会有一种暗自竞争的动力）
在我们博文写成，会有很多道友阅读。很多我们自己认为是对的，实际上是错误的东西、或是我们难以发现的错误，热心的道友会帮你指出。这是一个难得的成长机会。
在写博客的过程中，我们肯定会遇到这样或那样的疑问会去查资料。在这过程，我们可能会引发更多的知识或疑问。这个时候问题本身可能就不是那么重要的，引申出来的问题和知识带你会让我们学习到更多。
很多时候，我们也会有心或是无心帮到一些初学者或是遇到同样问题的人。在得到他人的感谢或是肯定的时候心里满满的美（或是虚荣心吧）。
通过博客轨迹，我们以后也可以看到自己的成长轨迹。我们都做过些什么，以后应该怎么做，以至于不忘初心，不迷失自己。
还有一点，也许不是那么明显。我觉得博客是一个非常好的简历。不仅可以看到你的技术水平，还可以看到你平时的关注内容、评论言辞，从而看出你的为人和人品。

我们应该怎样去写好博客：

首先，我们要么就不写要么用心写。也不是说一定要写得多么牛逼，起码用心了，我们就有长进。如果随意滥竽充数，那就真的是浪费时间了。用心了，也不一定就是好的博文，但是会慢慢的一篇篇的变成好的博文。
然后，我们需要假想观众。我们写出来的东西，总是会有人去读的，起码自己会读吧。所以，一定要以能让别人读懂为基础理念。然后就是怎样能让别人更加容易读懂。
想象我们的读者是个初学者。不要一开始，在认为自己懂了的前提直接写下结论。（就像注释一样，也许我们写代码的时候整个逻辑都清晰明了。不过几个后，就要把代码从头理解了。所以，我们必要的时候会标上注释。我们假想对象是初学者，那样我们以后看自己的博客也会马上进入状态理解以前是要表达的意思）。
我们在看某本书的时候就开始计划着，我应该怎样更好的把自己现在看的这节通过博文的方式表达出来，而让读者看得懂。（有个这个想法，你看书会更加的专心，会去了解其原理。而不是像有时候，似懂非懂的情况下继续接着看），我们通过博文形式记录自己的读书笔记，会要比只是把书浏览一遍，然后过几个月又忘记了，然后又去读，要好的多。

 
我注册博客园已经整整五年了，真正开始写博客也只是近一年的事情，以前没写也是因为上面的“种种原因”。然而，正是这一年，是我在程序员的这条道路上，成长最多最快也是这一年。也不是说写博客就真的会让你想开挂般成长。只是真的可以引发很多积极的东西，一些平时你不会去做的东西或者难以坚持的东西。（本人现在正在看《javascript高级程序设计》，并以博文笔记形式记下所读所解）
 
最后附上一副图，平时我群里群友闲聊时的镇群图。 （一图足以解释标题的疑问）

  

这是我个人对写博客的一点心得，每个写博客的人都有自己的心得，我这里列举出来的肯定不全，也有些是你并不认同的。但是，我相信还是有部分是正确有用的。道友们也可以在评论区，写下自己的一点心得，大家探讨探讨。
原文链接：http://www.cnblogs.com/zhaopei/p/4998937.html
如果本文引起了您的共鸣或是对您有点帮助，那么请您轻轻点个赞，鼓励下。

 

 
园友心得（评论）：
 五月的仓颉 
“就拿我自己来说，每次写博客的时候，我都会想到我的博客是面向网友们的，所以必须要非常严谨，一定不能把自己都想不明白的知识点就这么随意往博客上一放，每一句话都必须自己想清楚了才可以，每一个知识点必须自己弄懂了才会写上去。就像我博客里面的一篇Java代码性能优化的文章吧，在发表之前在我的草稿箱里面放了至少有半个月，不断思考、修改，结果在发表之后收到了一些的好评，也被广泛转载。现在，我自己的博客里面草稿箱里面还有9篇文章，只有完全搞懂了，才会发布出去。从这个角度说，对于一个用心写博客的人来说，写博客对于提升自己的严谨度、专业性是非常有帮助的，久而久之，你对于技术的态度也会潜移默化地变成你对于生活的态度。”
 
相关文章推荐：
《为什么要写技术博》：http://www.cnblogs.com/vamei/archive/2012/11/17/2774208.html
《为什么写技术博客对新人如此重要？》：http://blog.csdn.net/oiio/article/details/6913156
《为什么你应该（从现在开始就）写博客》：http://blog.csdn.net/pongba/article/details/3896311
《我为什么鼓励工程师写blog》：https://news.cnblogs.com/n/566179/
 
article  50
title: 各大招聘网站信息实时查询浏览【二】
body: 
前言

前面写了《各大招聘网站信息实时查询浏览》，关注的朋友还真不少。各种意见的提，我也觉得意见挺好的，也就一一采纳了。
有朋友说，希望能在手机端访问。好，采纳。有朋友说，选择区域太少了。好，我加上。有朋友说，希望能在本页面查看详情。ok，我同意。
额，差不多就这些改动了。

效果图
不想往下看的可以直接：演示地址  源码下载 
pc:效果图     移动端：效果图

使用webapi提供数据
为什么要用webapi提供数据？

数据部分和显示部分分离
可以各终端调用数据展示

因为我这里请求的时候，是实时访问的招聘网站，所以请求过程要耗费一定的时间。但是，信息的更新并不频繁。我们可以在webapi中使用缓存。
在guget命令行执行 Install-Package Strathweb.CacheOutput.WebApi2OutputCache 。
示例代码：

[CacheOutput(ClientTimeSpan = 60, ServerTimeSpan = 60)]
public IEnumerable<string> Get()
{
     return new string[] { "str1", "str2" };
}

WebAPI 测试链接：http://hi.haojima.net/SwaggerUI/
响应式
什么是响应式? 请戳。
在做响应式布局的时候，还是遇到了点小问题的。
如：
pc端的搜索条件所在的div 显示效果：

在移动端的显示效果：

要求：pc端一行显示，移动端两行显示。且左右居中显示。
问题就出在左右居中。首先，pc端的显示。两个div一行显示，我们一般都是用样式 float: left; 。可是，我发现float了以后不好居中了啊。考虑这用个东西包起来，再居中。具有包裹性的：无非就是： float: left;  display:table;  position:absolute 。float排除，然后table的显示方式好使。就像我们平时让table居中那样。 margin:0 auto; 
测试代码：

<style type="text/css">
        .clearfix {
            overflow: auto;
            _height: 1%;
        }
</style>
<div class="clearfix" style="display:table;margin:0 auto; border: 1px dashed #ff0000">
    <div style="float: left; border: 1px solid #ff0000">div1</div>
    <div style="float: left; border: 1px solid #ff0000; ">div2</div>
</div>

 
注意：clearfix 用来防止使用了 float 而引起的”坍塌“效果。
pc端搞定了，那移动端直接去掉 float  再显示就ok了。
(前端的东西，我也是知其然不知其所以然。什么居中、”坍塌“、clearfix等 也不知道为什么要这么用。所以博文记录下，方便下次自己翻阅。)
详细信息显示
虽然列表中超链接到详情页面。但是，如果我们可以直接在本页面查看到详情岂不是更加的方便。我们做的本来就是为了更加方便的浏览招聘信息。
说做就做。首先，我们的列表已经有了超链接。我们在点击行的时候，发送请求到后台。取得详细信息，然后在页面显示。就这么简单。
后台获取详细信息：


#region 根据url请求，返回详细信息
/// <summary>
/// 根据url请求，返回详细信息
/// </summary>
/// <param name="url"></param>
/// <param name="type"></param>
/// <returns></returns>
public string GetUrlInfo(string url, DataType type)
        {
            var ulS = string.Empty;
            switch (type)
            {
                case DataType.智联招聘:
                    #region 问题：“gzip”不是受支持的编码名 的处理方法  http://www.cnblogs.com/soundcode/p/3785152.html
                    HtmlAgilityPack.HtmlWeb.PreRequestHandler handler = delegate(HttpWebRequest request)
                               {
                                   request.Headers[HttpRequestHeader.AcceptEncoding] = "gzip, deflate";
                                   request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;
                                   request.CookieContainer = new System.Net.CookieContainer();
                                   return true;
                               };
                    htmlWeb.PreRequest += handler;
                    #endregion
                    htmlWeb.OverrideEncoding = Encoding.GetEncoding("UTF-8");
                    HtmlAgilityPack.HtmlDocument response = htmlWeb.Load(url);

                    var fuli = response.DocumentNode.SelectNodes("/html/body/div[3]/div[1]/div[1]/div");
                    var jiben = response.DocumentNode.SelectNodes("/html/body/div[4]/div[1]/ul");
                    var miaoshu = response.DocumentNode.SelectNodes("/html/body/div[4]/div[1]/div[1]/div/div[1]");

                    if (fuli != null && fuli.Count >= 1 && !string.IsNullOrEmpty(fuli[0].InnerText.Trim()))
                        ulS += "<h3>福利诱惑:</h3>" + fuli[0].InnerText;
                    if (jiben != null && jiben.Count >= 1 && !string.IsNullOrEmpty(jiben[0].InnerText.Trim()))
                        ulS += "<h3>基本信息:</h3>" + jiben[0].InnerText;
                    if (miaoshu != null && miaoshu.Count >= 1 && !string.IsNullOrEmpty(miaoshu[0].InnerText.Trim()))
                        ulS += "<h3>职位描述:</h3>" + miaoshu[0].InnerText;
                    break;
                case DataType.猎聘网:
                    htmlWeb.OverrideEncoding = Encoding.GetEncoding("UTF-8");
                    response = htmlWeb.Load(url);
                    //--基本信息
                    var jbinfo = response.DocumentNode.SelectNodes("//*[@id='job-view-enterprise']/div[1]/div[1]/div[1]/div[3]/div") ??
                          response.DocumentNode.SelectNodes("//*[@id='job-hunter']/div[1]/div[1]/div[1]/div[3]/div");
                    //职位描述
                    var selectNodes = response.DocumentNode.SelectNodes("//*[@id='job-hunter']/div[1]/div[1]/div[1]/div[4]")
                        ?? response.DocumentNode.SelectNodes("//*[@id='job-view-enterprise']/div[1]/div[1]/div[1]/div[4]");
                    //岗位要求                    
                    var ganwei = response.DocumentNode.SelectNodes("//*[@id='job-hunter']/div[1]/div[1]/div[1]/div[5]/div")
                      ?? response.DocumentNode.SelectNodes("//*[@id='job-view-enterprise']/div[1]/div[1]/div[1]/div[5]/div");
                    ulS = "<h3>基本信息:</h3>" + jbinfo[0].InnerText +
                          "<h3>职位描述:</h3>" + selectNodes[0].InnerText +
                          "<h3>岗位要求:</h3>" + ganwei[0].InnerText;
                    break;
                case DataType.前程无忧:
                    htmlWeb.OverrideEncoding = Encoding.GetEncoding("GBK");
                    response = htmlWeb.Load(url);
                    //--
                    ulS = "<h3>基本信息:</h3>" + response.DocumentNode.SelectNodes("/html/body/div[3]/div/div[2]/table[1]/tr[3]/td[1]")[0].InnerText +
                          "<h3>职位描述:</h3>" + response.DocumentNode.SelectNodes("/html/body/div[3]/div/div[2]/div[1]/div[2]/div/table")[0].InnerText;

                    break;
                case DataType.拉勾网:
                    htmlWeb.OverrideEncoding = Encoding.GetEncoding("UTF-8");
                    response = htmlWeb.Load(url);
                    ulS = "<h3>基本信息:</h3>" + response.DocumentNode.SelectNodes("//*[@id='container']/div[1]/div[1]/dl/dd[1]")[0].InnerText +
                          "<h3>职位描述:</h3>" + response.DocumentNode.SelectNodes("//*[@id='container']/div[1]/div[1]/dl/dd[2]")[0].InnerText;
                    break;
            }

            return ulS.ToJson();
        }
#endregion

View Code
 
前台信息加载:

if ($(obj).next().hasClass("dataInfo"))
    $(obj).next().toggle();//如果已有详细信息，则只做显示隐藏的切换
else
    $(obj).after("<div class='dataInfo'>正在加载...</div>");//否则提示“正在加载”
$.ajax({//发起请求
    url: apiHref + "/api/HiJob?url=" + url,
    data: null,
    beforeSend: function (XHR) {
    },
    success: function (data) {
        $(obj).next(".dataInfo").html(eval(data.data));//用内容替换提示信息
    },
    dateType: "json"
});

 
新增拉勾网的数据
我后期又加了“拉勾”网的招聘信息。其他的网站都是直接链接，取信息。而偏偏拉勾就是不同。它是，请求->页面加载->ajax异步请求详情->追加到页面。然而，就因为这个异步，好几个同学就搞不定了。问我，拉勾的数据为什么取不到。在这里就统一分析下吧。
请求如：http://www.lagou.com/jobs/list_.net?city=上海  在浏览器F12监控。


我们可以看到信息列表数据是从http://www.lagou.com/jobs/positionAjax.json?city=上海地址，通过ajax的post请求取得的。
所以，我们后台模拟一个post请求就完事了。

StringContent fromurlcontent = new StringContent("first=true&pn=" + pn + "&kd=" + kd);
fromurlcontent.Headers.ContentType = new MediaTypeHeaderValue("application/x-www-form-urlencoded");       
fromurlcontent.Headers.Add("X-Requested-With", "XMLHttpRequest");                    
HttpClient httpclient = new HttpClient();
HttpResponseMessage responseMsg = httpclient.PostAsync(new Uri(url), fromurlcontent).Result;//发起post请求
var result = responseMsg.Content.ReadAsStringAsync().Result;
JavaScriptSerializer _jsSerializer = new JavaScriptSerializer();
LagouInfo JPostData = _jsSerializer.Deserialize<LagouInfo>(result);

 
注意了，我们得到数据之后。还进行的反序列化。因为数据是json格式的。但，不是所有数据都是我们想要的。所以进行序列化，然后只取我们想要的数据。（当然，序列化类，是我对着json数据一个个抠出来，写的类属性）
序列化类：


public class LagouInfo
    {
        public string code;
        public Ccontent content;
        public string msg;
        public string requestId;
        public string resubmitToken;
        public string success;
    }

public class Ccontent
    {
        public string currentPageNo;
        public string hasNextPage;
        public string hasPreviousPage;
        public string pageNo;
        public string pageSize;
        public List<Cresult> result;
        public string start;
        public string totalCount;
        public string totalPageCount;
    }

public class Cresult
    {
        public string adWord;
        public string adjustScore;
        public string city;
        public string companyId;
        public List<string> companyLabelList;
        public string companyLogo;
        public string companyName;
        public string companyShortName;
        public string companySize;
        public string countAdjusted;
        public string createTime;
        public string createTimeSort;
        public string education;
        public string financeStage;
        public string formatCreateTime;
        public string haveDeliver;
        public string industryField;
        public string jobNature;
        public string leaderName;
        public string orderBy;
        public string positionAdvantage;
        public string positionFirstType;
        public string positionId;
        public string positionName;
        public string positionType;
        public string positonTypesMap;
        public string randomScore;
        public string relScore;
        public string salary;
        public string score;
        public string searchScore;
        public string showOrder;
        public string totalCount;
        public string workYear;
    }

View Code
 
然后，接着组装自己想要的数据。

if (JPostData == null || JPostData.content == null || JPostData.content.result == null)
    return;
for (int i = 0; i < JPostData.content.result.Count; i++)
{
    var item = JPostData.content.result[i];
    string titleName, infourl, company, city, date, salary, salary_em, source;
    titleName = item.positionName;
    infourl = "http://www.lagou.com/jobs/" + item.positionId + ".html";
    company = item.companyShortName;
    city = item.city;
    date = DateTime.Parse(item.createTime).ToString("yyyy-MM-dd");
    salary = "月薪"; //item.SelectSingleNode(xpath + "/td[@class='gsmc']/a").InnerText;
    salary_em = item.salary;
    source = "拉勾网";

    listJobInfo.Add(
        new JobInfo(){
                          city = city,
                          company = company,
                          date = date,
                          info_url = infourl,
                          salary = salary,
                          salary_em = salary_em,
                          titleName = titleName,
                          source = source
                      });
}

 
增加选择区域
刚开始的时候，只添加了几个热门的城市（也是因为偷懒）。然后，很多同学就开始不依了，为什么没有“**”。大哥，能不能加上“**”。
既然大家有兴趣，那我一次性都加上吧。

点击更多：

说实在的，这个增加选择区域没有任何技术含量。纯粹的一个体力活。
因为每个网站的地区对于的地区编码都是不一样的。所以，我就需要到各个网站一个个的抠。
如：
抠完后：（string[0]:智联/拉勾 string[1]:前程 string[2]:猎聘）


dic_hi.Add("北京", new string[] { "北京", "010000", "010" });
dic_hi.Add("上海", new string[] { "上海", "020000", "020" });
dic_hi.Add("深圳", new string[] { "深圳", "040000", "050090" });
dic_hi.Add("广州", new string[] { "广州", "030200", "050020" });
dic_hi.Add("杭州", new string[] { "杭州", "080200", "070020" });
dic_hi.Add("成都", new string[] { "成都", "090200", "280020" });
dic_hi.Add("南京", new string[] { "南京", "070200", "060020" });
dic_hi.Add("武汉", new string[] { "武汉", "180200", "170020" });
dic_hi.Add("西安", new string[] { "西安", "200200", "270020" });
dic_hi.Add("厦门", new string[] { "厦门", "110300", "090040" });
dic_hi.Add("长沙", new string[] { "长沙", "190200", "180020" });
dic_hi.Add("苏州", new string[] { "苏州", "070300", "060080" });
dic_hi.Add("天津", new string[] { "天津", "050000", "030" }); 
             
dic_hi.Add("重庆", new string[] { "重庆", "060000", "040" });
dic_hi.Add("郑州", new string[] { "郑州", "170200", "150020" });
dic_hi.Add("青岛", new string[] { "青岛", "120300", "250070" });
dic_hi.Add("合肥", new string[] { "合肥", "150200", "080020" });
dic_hi.Add("福州", new string[] { "福州", "110200", "090020" });
dic_hi.Add("济南", new string[] { "济南", "120200", "250020" });
dic_hi.Add("大连", new string[] { "大连", "230300", "210040" });
dic_hi.Add("珠海", new string[] { "珠海", "030500", "050140" });
dic_hi.Add("无锡", new string[] { "无锡", "070400", "060100" });
dic_hi.Add("佛山", new string[] { "佛山", "030600", "050050" });
dic_hi.Add("东莞", new string[] { "东莞", "030800", "050040" });
dic_hi.Add("宁波", new string[] { "宁波", "080300", "070030" });
dic_hi.Add("常州", new string[] { "常州", "070500", "060040" });
dic_hi.Add("沈阳", new string[] { "沈阳", "230200", "210020" });
dic_hi.Add("石家庄", new string[] { "石家庄", "160200", "140020" });
dic_hi.Add("昆明", new string[] { "昆明", "250200", "310020" });
dic_hi.Add("南昌", new string[] { "南昌", "130200", "200020" });
dic_hi.Add("南宁", new string[] { "南宁", "140200", "110020" });
dic_hi.Add("哈尔滨", new string[] { "哈尔滨", "220200", "160020" });
dic_hi.Add("海口", new string[] { "海口", "100200", "130020" });
dic_hi.Add("中山", new string[] { "中山", "030700", "050130" });
dic_hi.Add("惠州", new string[] { "惠州", "030300", "050060" });
dic_hi.Add("贵阳", new string[] { "贵阳", "260200", "120020" });
dic_hi.Add("长春", new string[] { "长春", "240200", "190020" });
dic_hi.Add("太原", new string[] { "太原", "210200", "260020" });
dic_hi.Add("嘉兴", new string[] { "嘉兴", "080700", "070090" });
dic_hi.Add("泰安", new string[] { "泰安", "121100", "250090" });
dic_hi.Add("昆山", new string[] { "昆山", "070600", "060050" });
dic_hi.Add("烟台", new string[] { "烟台", "120400", "250120" });
dic_hi.Add("兰州", new string[] { "兰州", "270200", "100020" });
dic_hi.Add("泉州", new string[] { "泉州", "110400", "090030" }); 

View Code
总结

和之前那个版本显示效果区别不大（页面还是一样的丑，代码也还是一样的丑），不过实现方式完全不一样了。这阵子学习了MVC和WebAPI的点皮毛知识，也就再次折腾下。
演示地址  源码下载 ,如果您觉得有用，那就留给脚印吧。演示地址后期可能会变，这篇博文会维护最新链接。
转眼一年又悄悄的过去了，我猜想大家又开始蠢蠢欲动起来了。不过年后跳得应该比较多。不过，个人觉得年后的竞争压力大得多。
 
如果您有更好的处理方式，希望不要吝啬赐教。
本文链接：http://www.cnblogs.com/zhaopei/p/4931518.html 
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知

 
article  51
title: 一步步学习javascript基础篇（4）：面向对象设计之创建对象（工厂、原型和构造函数等模式）
body: 
前面我们介绍了可以通过Object构造函数或对象字面量都可以用来创建单个对象，但是如果需要创建多个对象的话，显然很多冗余代码。
接下来介绍几种模式来创建对象。不过在此之前，我们还是先来了解下 typeof和instanceof 。
typeof和instanceof 

//typeof主要用了检查值类型数据，如：
alert(typeof (1) + " " + typeof ("1") + " " + typeof (false) + " " + typeof (undefined));
//instanceof主要用了检查对象，如：
var arr = new Array();
alert((arr instanceof Object) + " " + (arr instanceof Array) + " " + (arr instanceof Number));//既是Object也是array，但不是Number

例：
//typeof主要用了检查值类型数据，如：
alert(typeof (1) + " " + typeof ("1") + " " + typeof (false) + " " + typeof (undefined));
//instanceof主要用了检查对象，如：
var arr = new Array();
alert((arr instanceof Object) + " " + (arr instanceof Array) + " " + (arr instanceof Number));//既是Object也是array，但不是Number

     
下面我们接着介绍数种创建对象的方式。
一、 工厂模式：

function createPerson(name) {
    var o = new Object();
    o.name = name;
    o.sayName = function () {
        alert(this.name);
    };
    return o;
}
var obj = createPerson("张三");
var obj2 = createPerson("李四");
alert(obj instanceof Object);
alert(obj instanceof createPerson)

由上可知，工厂模式简单、思路清晰、容易理解，也可以创建对象，不过有个缺点不能确定对象类型。因为它总是一个object类型，而不能判定是createPerson类型。
例1：
function createPerson(name) {
    var o = new Object();
    o.name = name;
    o.sayName = function () {
      alert(this.name);
    };
    return o;
}
var obj = createPerson("张三");
var obj2 = createPerson("李四");
alert(obj instanceof Object);
alert(obj instanceof createPerson)

     
二、构造函数模式 

var obj = { name: "李四" };
function Person(name) {
    this.name = name;
    this.sayName = function () {
        alert(this.name);
    };
}
var per = new Person("张三");
per.sayName();//张三
var per2 = new Person("李四");
alert(per.sayName==per2.sayName);//false

 
其实，构造函数模式我们在上篇博文就简单介绍过了。同样，构造函数模式也不完美，因为每个实例化出来的对象所拥有的方法都是独立的，而一个对象类型的方法完全是可以同享引用来节省内存空间。
例2：
var obj = { name: "李四" };
function Person(name) {
    this.name = name;
    this.sayName = function () {
     alert(this.name);
    };
}
var per = new Person("张三");
per.sayName();//张三
var per2 = new Person("李四");
alert(per.sayName==per2.sayName);//false
alert(per instanceof Person)//与上面的工厂模式不同，这里通过构造函数创建的方法，可以直接判断对象类型了。

     
由例2可以看出，第二次弹出消息为false，证明了每个实例对象中的方法都是独立的。 第三次弹出消息为true，与上面的工厂模式不同，这里通过构造函数创建的方法，可以直接判断对象类型了。
我们说实例对象的方法应该是共享的，那么我们可以用接下来的模式实现。
三、原型模式
1.0在使用原型模式之前，我们首先需要了解什么是原型。我的理解就是，原始对象类型的模型。每个对象都有一个属性（prototype）指向对象的原型。

function Person() {
    this.sayHi1 = function () { }
}
Person.prototype.sayHi2 = function () { };

var per1 = new Person();
var per2 = new Person();
alert(per1.sayHi1 === per2.sayHi1);//每个实例化出来的对象所独有的，所以为false
alert(per1.sayHi2 === per2.sayHi2);//因为是同一个引用，所以为true
//我们再次证明了构造函数中的属性(或是方法、对象)是实例化对象独有的，原型中的属性(或是方法、对象)是共享的。

第一个比较是对象的属性，所以每个实例对象拥有独立的方法，而第二个比较是原型方法，就算是实例对象，它们直接也是引用共享的。
例3：
function Person() {
this.sayHi1 = function () { }
}
Person.prototype.sayHi2 = function () { };

var per1 = new Person();
var per2 = new Person();
alert(per1.sayHi1 === per2.sayHi1);//每个实例化出来的对象所独有的，所以为false
alert(per1.sayHi2 === per2.sayHi2);//因为是同一个引用，所以为true

     
我们看到了 per1.sayHi2 === per2.sayHi2  比较是true。（===是全等的意思，不仅比较值，还比较类型。）
 
我们看到了 __proto__ 指向的就是我们所谓的原型（只有Firefox、 Safari 和 Chrome浏览器有此属性）。还有一个 constructor 指向我们的构造函数。
1.1 __proto__ 和原型 prototype 的关系（其实__proto__并不是一个js语言中规定的对象属性，只是某些浏览器实现了）

function Person() {
    this.name1 = "张三",
    this.sayHi1 = function () { }
}
Person.prototype.sayHi2 = function () { };

var per1 = new Person();
var per2 = new Person();
alert(per1.constructor);//constructor指向了构造函数
alert(per1.constructor.prototype);//constructor.prototype 指向了构造函数的原型
alert(per1.constructor.prototype === per1.__proto__);//true 由此看出__proto__和原型的关系。（指向了构造函数的原型）

例：
function Person() {
this.name1 = "张三",
   this.sayHi1 = function () { }
}
Person.prototype.sayHi2 = function () { };

var per1 = new Person();
var per2 = new Person();
alert(per1.constructor);//constructor指向了构造函数
alert(per1.constructor.prototype);//constructor.prototype 指向了构造函数的原型
alert(per1.constructor.prototype === per1.__proto__);//true 由此看出__proto__和原型的关系。（指向了构造函数的原型）

     
1.2如果原型中的属性和构造函数中的属性重名，会优先访问构造函数中的属性 

function Person(name) {
    this.name1 = name;
};
Person.prototype.name1 = "test1";
Person.prototype.name2 = "test2";

var per1 = new Person("name1");
alert(per1.name1);//访问到的是实例对象中的name1属性“name1”
delete per1.name1;//删除实例对象中的name1属性
alert(per1.name1);//访问类型原型中的name1属性“test1”

alert(per1.name2);//访问原型属性“name2”
per1.name2 = "name2";//这里并不是修改了原型属性“name2”的值，而是为实例对象动态添加了一个“name2”的属性，并赋值。
alert(per1.name2);//访问实例属性“name2”
delete per1.name2;
alert(per1.name2);//访问原型属性“name2”

例：
function Person(name) {
  this.name1 = name;
};
Person.prototype.name1 = "test1";
Person.prototype.name2 = "test2";

var per1 = new Person("name1");
alert(per1.name1);//访问到的是实例对象中的name1属性“name1”
delete per1.name1;//删除实例对象中的name1属性
alert(per1.name1);//访问类型原型中的name1属性“test1”

alert(per1.name2);//访问原型属性“name2”
per1.name2 = "name2";//这里并不是修改了原型属性“name2”的值，而是为实例对象动态添加了一个“name2”的属性，并赋值。
alert(per1.name2);//访问实例属性“name2”
delete per1.name2;
alert(per1.name2);//访问原型属性“name2”

     
如图：
 
1.3使用字面量表示法为原型统一添加方法和属性
我们上面看到定义原型的属性和方法都是一个个定义的，看上去明显感觉杂乱。其实我们也可以通过字面量的方式为原型添加属性或方法，如：

function Person() { }
Person.prototype = {
    name1: "张三",
    age: 23,
    sayHi: function () {
        alert(this.name1);
    }
}
var per1 = new Person();
per1.name1 = "李四"
per1.sayHi()

 
缺点：这样的定义，相当与重写了对象类型的prototype属性，也就是我们再也访问不到 constructor 属性了。
当然，我也可以手动设置，如：

function Person() { }
Person.prototype = {
    constructor: Person,//手动设置constructor赋值Person
    name1: "张三",
    age: 23,
    sayHi: function () {
        alert(this.name1);
    }
}
var per1 = new Person();
per1.name1 = "李四"
per1.sayHi()

 
我们通过在构造函数中定义属性，在原型中通过字面量表示法定义方法已经可以很好的创建对象了。唯一的缺点就是分为两个步骤，那么我们下面试着全部封装到构造函数中。如： 

function Person(str1, str2, str3) {
    this.name1 = str1;
    this.name2 = str2;
    this.age = str3;
    //方法
    if (typeof this.sayName != "function") {//只用判断一个就可以了，第一次构造的时候是不能有sayName方法的。
        //在构造函数里面貌似不能通过字面量来为prototype统一赋值
        Person.prototype.sayName = function () {
            alert(this.name1);
        };
        Person.prototype.sayHi = function () {
            alert(this.name2);
        };
    }
}

var per1 = new Person("张三","李四","12");
per1.sayName();

 

我们平时常用的一些创建对象的方式就介绍到这里了。
下一篇继续分析对象的继承，欢迎大家继续关注。
这是学习记录，不是教程。文中错误难免，您可以指出错误，但请不要言辞刻薄。
原文链接：http://haojima.net/zhaopei/516.html
本文已同步至目录索引：一步步学习javascript
欢迎上海“程序猿/媛”、"攻城狮"入群：【沪猿】229082941 入群须知
欢迎对个人博客感兴趣的道友加入群：【嗨-博客】469075305 入群须知
如果您觉得文章对您有那么一点点帮助，那么麻烦您轻轻的点个赞，以资鼓励。

 
article  52
title: 一步步开发自己的博客  .NET版（5、Lucenne.Net 和 必应站内搜索）
body: 
前言 

    这次开发的博客主要功能或特点：    第一：可以兼容各终端，特别是手机端。    第二：到时会用到大量html5，炫啊。    第三：导入博客园的精华文章，并做分类。（不要封我）    第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

 
演示地址：http://haojima.net/      群内共享源码：469075305 
 

今天来分析下 嗨-博客 中的搜索功能。搜索功能在个人网站里面要有这么个东西，但又不是特别重要。所以我们需要有，可以不用太深入了解，毕竟我们不是专门做搜索这块的。
所以，我打算把搜索分两块。一块是，用Lucene.Net实现站内搜索。一块是利用第三方搜索引擎来 实现站内搜索。
 
 
Lucene.Net简介

Lucene.net是Lucene的.net移植版本，是一个开源的全文检索引擎开发包，即它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎。开发人员可以基于Lucene.net实现全文检索的功能。
Lucene.net是Apache软件基金会赞助的开源项目，基于Apache License协议。
Lucene.net并不是一个爬行搜索引擎，也不会自动地索引内容。我们得先将要索引的文档中的文本抽取出来，然后再将其加到Lucene.net索引中。标准的步骤是先初始化一个Analyzer、打开一个IndexWriter、然后再将文档一个接一个地加进去。一旦完成这些步骤，索引就可以在关闭前得到优化，同时所做的改变也会生效。这个过程可能比开发者习惯的方式更加手工化一些，但却在数据的索引上给予你更多的灵活性，而且其效率也很高。(来源百度百科)


Lucene帮助类

其实 在之前 我也是接触到过Lucene.net，那也是自己 做的个小玩意(博客备份小工具3)  瞎折腾的。但是 这次打算迁移到这个系统中，不知怎么的 报错了。可能是这次用的是 .net 4.5。Lucene这东西太高深，我也没打算深究。于是 在网上收索了一把，资料还挺多的。《lucene.net 3.0.3、结合盘古分词进行搜索的小例子（分页功能）》 我随意看了下，这里有个 帮助类 挺不错的，也还符合 我这样想要的效果。这里来分析下这个帮助类。 
1.首先创建索引。      


IndexWriter writer = new IndexWriter(directory_luce, analyzer, false, IndexWriter.MaxFieldLength.LIMITED);
Document doc = new Document();
doc.Add(new Field(name, value, Field.Store.YES, Field.Index.NOT_ANALYZED));
writer.AddDocument(doc);

这里的 
directory_luce 是索引创建路径
analyzer 分析器
value 是对应 存入索引额名字和值
2.从索引里面搜索       

            string[] fileds = { "title", "content" };//查询字段           
            QueryParser parser = null;
            parser = new MultiFieldQueryParser(version, fileds, analyzer);//多个字段查询
            Query query = parser.Parse(keyword);
            int n = 1000;
            IndexSearcher searcher = new IndexSearcher(directory_luce, true);//true-表示只读
            TopDocs docs = searcher.Search(query, (Filter)null, n);
            if (docs == null || docs.TotalHits == 0)
            {
                return null;
            }
            else
            {
                List<SearchResult> list = new List<SearchResult>();
                int counter = 1;
                foreach (ScoreDoc sd in docs.ScoreDocs)//遍历搜索到的结果
                {
                    try
                    {
                        Document doc = searcher.Doc(sd.Doc);
                        int id = int.Parse(doc.Get("id"));
                        string title = doc.Get("title");
                        string content = doc.Get("content");
                        string blogTag = doc.Get("blogTag");
                        string url = doc.Get("url");
                        int flag = int.Parse(doc.Get("flag"));
                        int clickQuantity = int.Parse(doc.Get("clickQuantity"));

                        string createdate = doc.Get("createdate");
                        PanGu.HighLight.SimpleHTMLFormatter simpleHTMLFormatter = new PanGu.HighLight.SimpleHTMLFormatter("<font color=\"red\">", "</font>");
                        PanGu.HighLight.Highlighter highlighter = new PanGu.HighLight.Highlighter(simpleHTMLFormatter, new PanGu.Segment());
                        highlighter.FragmentSize = 50;
                        content = highlighter.GetBestFragment(keyword, content);
                        string titlehighlight = highlighter.GetBestFragment(keyword, title);
                        if (titlehighlight != "") title = titlehighlight;

                        list.Add(new SearchResult(title, content, url, blogTag, id, clickQuantity, flag));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                    counter++;
                }
                return list;

3.完整代码


 public class PanGuLuceneHelper
    {
        private PanGuLuceneHelper() { }

        #region 单一实例
        private static PanGuLuceneHelper _instance = null;
        /// <summary>
        /// 单一实例
        /// </summary>
        public static PanGuLuceneHelper instance
        {
            get
            {
                if (_instance == null) _instance = new PanGuLuceneHelper();
                return _instance;
            }
        }
        #endregion

        #region 00一些属性和参数
        #region Lucene.Net的目录-参数
        private Lucene.Net.Store.Directory _directory_luce = null;
        /// <summary>
        /// Lucene.Net的目录-参数
        /// </summary>
        public Lucene.Net.Store.Directory directory_luce
        {
            get
            {
                if (_directory_luce == null) _directory_luce = Lucene.Net.Store.FSDirectory.Open(directory);
                return _directory_luce;
            }
        }
        #endregion

        #region 索引在硬盘上的目录
        private System.IO.DirectoryInfo _directory = null;
        /// <summary>
        /// 索引在硬盘上的目录
        /// </summary>
        public System.IO.DirectoryInfo directory
        {
            get
            {
                if (_directory == null)
                {
                    string dirPath = AppDomain.CurrentDomain.BaseDirectory + "SearchIndex";
                    if (System.IO.Directory.Exists(dirPath) == false) _directory = System.IO.Directory.CreateDirectory(dirPath);
                    else _directory = new System.IO.DirectoryInfo(dirPath);
                }
                return _directory;
            }
        }
        #endregion

        #region 分析器
        private Analyzer _analyzer = null;
        /// <summary>
        /// 分析器
        /// </summary>
        public Analyzer analyzer
        {
            get
            {
                {
                    _analyzer = new Lucene.Net.Analysis.PanGu.PanGuAnalyzer();//                   
                }
                return _analyzer;
            }
        }
        #endregion

        #region 版本号枚举类
        private static Lucene.Net.Util.Version _version = Lucene.Net.Util.Version.LUCENE_30;
        /// <summary>
        /// 版本号枚举类
        /// </summary>
        public Lucene.Net.Util.Version version
        {
            get
            {
                return _version;
            }
        }
        #endregion
        #endregion

        #region 01创建索引
        /// <summary>
        /// 创建索引(先删 后更新)
        /// </summary>
        /// <param name="datalist"></param>
        /// <returns></returns>
        public bool CreateIndex(List<SearchResult> datalist)
        {
            IndexWriter writer = null;
            try
            {
                writer = new IndexWriter(directory_luce, analyzer, false, IndexWriter.MaxFieldLength.LIMITED);//false表示追加（true表示删除之前的重新写入）
            }
            catch
            {
                writer = new IndexWriter(directory_luce, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);//false表示追加（true表示删除之前的重新写入）
            }
            foreach (SearchResult data in datalist)
            {
                writer.DeleteDocuments(new Term("id", data.id.ToString()));//新增前 删除  不然会有重复数据
                CreateIndex(writer, data);
            }
            writer.Optimize();
            writer.Dispose();
            return true;
        }
        public bool CreateIndex(SearchResult data)
        {
            List<SearchResult> datalist = new List<SearchResult>();
            datalist.Add(data);
            return CreateIndex(datalist);
        } 

        public bool CreateIndex(IndexWriter writer, SearchResult data)
        {
            try
            {

                if (data == null) return false;
                Document doc = new Document();
                Type type = data.GetType();//assembly.GetType("Reflect_test.PurchaseOrderHeadManageModel", true, true); //命名空间名称 + 类名    

                //创建类的实例    
                //object obj = Activator.CreateInstance(type, true);  
                //获取公共属性    
                PropertyInfo[] Propertys = type.GetProperties();
                for (int i = 0; i < Propertys.Length; i++)
                {
                    //Propertys[i].SetValue(Propertys[i], i, null); //设置值
                    PropertyInfo pi = Propertys[i];
                    string name = pi.Name;
                    object objval = pi.GetValue(data, null);
                    string value = objval == null ? "" : objval.ToString(); //值                   
                    if (name == "id" || name == "flag")//id在写入索引时必是不分词，否则是模糊搜索和删除，会出现混乱
                    {
                        doc.Add(new Field(name, value, Field.Store.YES, Field.Index.NOT_ANALYZED));//id不分词
                    }
                    else
                    {
                        doc.Add(new Field(name, value, Field.Store.YES, Field.Index.ANALYZED));
                    }
                }
                writer.AddDocument(doc);
            }
            catch (System.IO.FileNotFoundException fnfe)
            {
                throw fnfe;
            }
            return true;
        }
        #endregion

        #region 02在title和content字段中查询数据
        /// <summary>
        /// 在title和content字段中查询数据
        /// </summary>
        /// <param name="keyword"></param>
        /// <returns></returns>
        public List<SearchResult> Search(string keyword)
        {
            string[] fileds = { "title", "content" };//查询字段           
            QueryParser parser = null;
            parser = new MultiFieldQueryParser(version, fileds, analyzer);//多个字段查询
            Query query = parser.Parse(keyword);
            int n = 1000;
            IndexSearcher searcher = new IndexSearcher(directory_luce, true);//true-表示只读
            TopDocs docs = searcher.Search(query, (Filter)null, n);
            if (docs == null || docs.TotalHits == 0)
            {
                return null;
            }
            else
            {
                List<SearchResult> list = new List<SearchResult>();
                int counter = 1;
                foreach (ScoreDoc sd in docs.ScoreDocs)//遍历搜索到的结果
                {
                    try
                    {
                        Document doc = searcher.Doc(sd.Doc);
                        int id = int.Parse(doc.Get("id"));
                        string title = doc.Get("title");
                        string content = doc.Get("content");
                        string blogTag = doc.Get("blogTag");
                        string url = doc.Get("url");
                        int flag = int.Parse(doc.Get("flag"));
                        int clickQuantity = int.Parse(doc.Get("clickQuantity"));

                        string createdate = doc.Get("createdate");
                        PanGu.HighLight.SimpleHTMLFormatter simpleHTMLFormatter = new PanGu.HighLight.SimpleHTMLFormatter("<font color=\"red\">", "</font>");
                        PanGu.HighLight.Highlighter highlighter = new PanGu.HighLight.Highlighter(simpleHTMLFormatter, new PanGu.Segment());
                        highlighter.FragmentSize = 50;
                        content = highlighter.GetBestFragment(keyword, content);
                        string titlehighlight = highlighter.GetBestFragment(keyword, title);
                        if (titlehighlight != "") title = titlehighlight;

                        list.Add(new SearchResult(title, content, url, blogTag, id, clickQuantity, flag));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                    counter++;
                }
                return list;
            }
            //st.Stop();
            //Response.Write("查询时间：" + st.ElapsedMilliseconds + " 毫秒<br/>");

        }
        #endregion

        #region 03在不同的分类下再根据title和content字段中查询数据(分页)
        /// <summary>
        /// 在不同的类型下再根据title和content字段中查询数据(分页)
        /// </summary>
        /// <param name="_flag">分类,传空值查询全部</param>
        /// <param name="keyword"></param>
        /// <param name="PageIndex"></param>
        /// <param name="PageSize"></param>
        /// <param name="TotalCount"></param>
        /// <returns></returns>
        public List<SearchResult> Search(string _flag, string keyword, int PageIndex, int PageSize)
        {
            if (PageIndex < 1) PageIndex = 1;
            Stopwatch st = Stopwatch.StartNew();
            st.Start();
            BooleanQuery bq = new BooleanQuery();
            if (_flag != "")
            {
                QueryParser qpflag = new QueryParser(version, "flag", analyzer);
                Query qflag = qpflag.Parse(_flag);
                bq.Add(qflag, Occur.MUST);//与运算
            }
            if (keyword != "")
            {
                string[] fileds = { "blogTag", "title", "content" };//查询字段
                QueryParser parser = null;// new QueryParser(version, field, analyzer);//一个字段查询
                parser = new MultiFieldQueryParser(version, fileds, analyzer);//多个字段查询
                Query queryKeyword = parser.Parse(keyword);
                bq.Add(queryKeyword, Occur.MUST);//与运算
            }

            TopScoreDocCollector collector = TopScoreDocCollector.Create(PageIndex * PageSize, false);
            IndexSearcher searcher = new IndexSearcher(directory_luce, true);//true-表示只读
            searcher.Search(bq, collector);

            if (collector == null || collector.TotalHits == 0)
            {
                //TotalCount = 0;
                return null;
            }
            else
            {
                int start = PageSize * (PageIndex - 1);
                //结束数
                int limit = PageSize;
                ScoreDoc[] hits = collector.TopDocs(start, limit).ScoreDocs;
                List<SearchResult> list = new List<SearchResult>();
                int counter = 1;
                //TotalCount = collector.TotalHits;
                st.Stop();
                //st.ElapsedMilliseconds;//毫秒
                foreach (ScoreDoc sd in hits)//遍历搜索到的结果
                {
                    try
                    {
                        Document doc = searcher.Doc(sd.Doc);
                        int id = int.Parse(doc.Get("id"));
                        string title = doc.Get("title");
                        string content = doc.Get("content");
                        string blogTag = doc.Get("blogTag");
                        string url = doc.Get("url");
                        int flag = int.Parse(doc.Get("flag"));
                        int clickQuantity = int.Parse(doc.Get("clickQuantity"));
                        content = Highlight(keyword, content);
                        //string titlehighlight = Highlight(keyword, title);
                        //if (titlehighlight != "") title = titlehighlight;
                        list.Add(new SearchResult(title, content, url, blogTag, id, clickQuantity, flag));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                    counter++;
                }
                return list;
            }
        }
        #endregion

        #region 把content按照keywords进行高亮
        /// <summary>
        /// 把content按照keywords进行高亮
        /// </summary>
        /// <param name="keywords"></param>
        /// <param name="content"></param>
        /// <returns></returns>
        private static string Highlight(string keywords, string content)
        {
            SimpleHTMLFormatter simpleHTMLFormatter = new PanGu.HighLight.SimpleHTMLFormatter("<strong>", "</strong>");
            Highlighter highlighter = new PanGu.HighLight.Highlighter(simpleHTMLFormatter, new Segment());
            highlighter.FragmentSize = 200;
            return highlighter.GetBestFragment(keywords, content);
        }
        #endregion

        #region 04删除索引
        #region 删除索引数据（根据id）
        /// <summary>
        /// 删除索引数据（根据id）
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public bool Delete(string id)
        {
            bool IsSuccess = false;
            Term term = new Term("id", id);
            IndexWriter writer = new IndexWriter(directory_luce, analyzer, false, IndexWriter.MaxFieldLength.LIMITED);
            writer.DeleteDocuments(term); // writer.DeleteDocuments(term)或者writer.DeleteDocuments(query);            
            writer.Commit();
            IsSuccess = writer.HasDeletions();
            writer.Dispose();
            return IsSuccess;
        }
        #endregion

        #region 删除全部索引数据
        /// <summary>
        /// 删除全部索引数据
        /// </summary>
        /// <returns></returns>
        public bool DeleteAll()
        {
            bool IsSuccess = true;
            try
            {
                IndexWriter writer = new IndexWriter(directory_luce, analyzer, false, IndexWriter.MaxFieldLength.LIMITED);
                writer.DeleteAll();
                writer.Commit();
                IsSuccess = writer.HasDeletions();
                writer.Dispose();
            }
            catch
            {
                IsSuccess = false;
            }
            return IsSuccess;
        }
        #endregion
        #endregion

        #region 分词测试
        /// <summary>
        /// 分词测试
        /// </summary>
        /// <param name="keyword"></param>
        /// <returns></returns>
        public string Token(string keyword)
        {
            string ret = "";
            System.IO.StringReader reader = new System.IO.StringReader(keyword);
            Lucene.Net.Analysis.TokenStream ts = analyzer.TokenStream(keyword, reader);
            bool hasNext = ts.IncrementToken();
            Lucene.Net.Analysis.Tokenattributes.ITermAttribute ita;
            while (hasNext)
            {
                ita = ts.GetAttribute<Lucene.Net.Analysis.Tokenattributes.ITermAttribute>();
                ret += ita.Term + "|";
                hasNext = ts.IncrementToken();
            }
            ts.CloneAttributes();
            reader.Close();
            analyzer.Close();
            return ret;
        }
        #endregion

    }

View Code


public class SearchResult
    {
        public SearchResult() { }

        public SearchResult(string title, string content, string url, string blogTag, int id, int clickQuantity, int flag)
        {
            this.blogTag = blogTag;
            this.clickQuantity = clickQuantity;
            this.content = content;
            this.id = id;
            this.url = url;
            this.title = title;
            this.flag = flag;
        }
        /// <summary>
        /// 标题
        /// </summary>
        public string title { get; set; }
        /// <summary>
        /// 正文内容
        /// </summary>
        public string content { get; set; }
        /// <summary>
        /// url地址
        /// </summary>
        public string url { get; set; }
        /// <summary>
        /// tag标签
        /// </summary>
        public string blogTag { get; set; }
        /// <summary>
        /// 唯一id
        /// </summary>
        public int id { get; set; }
        /// <summary>
        /// 点击量
        /// </summary>
        public int clickQuantity { get; set; }
        /// <summary>
        /// 标记（用户） 
        /// </summary>
        public int flag { get; set; }
    }

View Code
必应站内搜索
1.为什么要用必应搜索？
因为我们现在做的主要功能是博客系统，搜索只是其中的一小块环节。而 我对这搜索并不了解，所以就用第三方搜索，省事嘛。
2.为什么不用别的三方收索呢？
百度？不用说了，咱们程序员都懂的。谷歌？我倒是想用，可生在天朝，也是没得办法。选来选去 还是选了必应。
3.怎么来使用第三方的站内搜索？
格式如下：http://cn.bing.com/search?q=关键字+site:网站地址 
例如：http://cn.bing.com/search?q=博客+site:blog.haojima.net 
效果图：
嘿嘿，如此之简单。既然都已经看到效果了，那么 我们可以干些什么呢？ 我打算 直接把结果 显示在我的 站内搜索结果。为什么 不直接跳转到这个页面显示 搜索结果？因为 这个页面有广告什么的，不能按照我自己的方式显示。我直接把结果放我的搜索页面 可以和 我上面用Lucene.net的搜索结果一起显示，这样岂不是 显得更专业。，不知道的 还以为 是我自己怎么弄出来的。那么 我们怎么解析 搜到的结果呢？我这里推荐下  Jumony  之前我一直是用 HtmlAgilityPack  ，现在为什么不用了，因为有了更好的。HtmlAgilityPack 缺点是 要去xpath，然 如果页面存在js动态改变文档结构的话，我们直接F12 复制出来的 xpath是不准的。那么有人 会说  HtmlAgilityPack  我已经用习惯了，不想 重新学习Jumony 。这里我告诉你错了，根本就需要重新学习，如果你会jquery 的话。常用功能语法基本一样，还支持拉姆达表达式，爽的一逼。
我们来看看 怎么使用Jumony 解析 解锁结果吧。

var document = jumony.LoadDocument(url);
var list = document.Find("#b_results .b_algo").ToList().Select(t => t.ToString()).ToList();

 
两行代码搞定，还直接转成了list集合。在页面循环加载就ok了。
站内下的某个用户内搜索


 我个人觉得 这是个蛮实用的功能，我们有时候 写了博客（很多时候我们写博客就是把自己怕会忘记的知识点 整理记录），而后期找不到。那么通过这个功能 可以很好的解决我们的问题。我们不想全站搜索，只搜索自己的内容就可以了。
页面还是用全站的搜索页面，我们直接在搜索关键词上做手脚就可以了。比如，我们想搜索  zhaopei  用户下的内容，那么我们可以要搜索的关键字前面加上  blog:zhaopei   那么完整的搜索关键字就成了  blog:zhaopei 关键字 
 那么  我们要做的就是 在用户页面 搜索 就在关键字 前面加上  blog:用户名  我们在搜索 页面解析的时候 需要做的就是 分解关键字 blog:用户名 关键字  先用空格 分割 然后如果中间有 空格的话 ，然后判断 前面五个字符是不是 blog: 然后截取 到用户名和 关键字。
我们下面具体看看 在Lucene.net 和 必应搜索里面是怎么做的。
1.Lucene.net 

   #region 加载 Lucene.net 的搜索结果
        /// <summary>
        /// 加载 Lucene.net 的搜索结果
        /// </summary>
        /// <returns></returns>
        public ActionResult ShowLuceneResult()
        {
            if (!Request.QueryString.AllKeys.Contains("key"))
                return null;
            string key = Request.QueryString["key"];

            var zhankey = key.Split(' ');//分割关键字
            var blogName = string.Empty;
            if (zhankey.Length >= 2)
            {
                var str = zhankey[0].Trim();
                if (str.Length > 6 && str.Substring(0, 5) == "blog:")
                    blogName = str.Substring(5);//取得用户名
            }

            string userid = Request.QueryString.AllKeys.Contains("userid") ? Request.QueryString["userid"] : "";

            //这里判断是否 用户名不为空  然后取得用户对应的 用户ID  （因为 我在做Lucene 是用用户id 来标记的）
            if (!string.IsNullOrEmpty(blogName))
            {
                key = key.Substring(key.IndexOf(' '));
                var userinfo = CacheData.GetAllUserInfo().Where(t => t.UserName == blogName).FirstOrDefault();
                if (null != userinfo)
                    userid = userinfo.Id.ToString();
            }

            string pIndex = Request.QueryString.AllKeys.Contains("p") ? Request.QueryString["p"] : "";
            int PageIndex = 1;
            int.TryParse(pIndex, out PageIndex);

            int PageSize = 10;
            var searchlist = PanGuLuceneHelper.instance.Search(userid, key, PageIndex, PageSize);
            return PartialView(searchlist);
        }
        #endregion

 2.  必应搜索

 #region  加载 bing  的搜索结果
        /// <summary>
        /// 加载 bing  的搜索结果
        /// </summary>
        /// <returns></returns>
        public ActionResult ShowBingResult()
        {
            if (!Request.QueryString.AllKeys.Contains("key"))
                return null;
            string key = Request.QueryString["key"];//搜索关键字
            JumonyParser jumony = new JumonyParser();
            //http://cn.bing.com/search?q=AJAX+site%3ablog.haojima.net&first=11&FORM=PERE
            string pIndex = Request.QueryString.AllKeys.Contains("p") ? Request.QueryString["p"] : "";
            int PageIndex = 1;
            int.TryParse(pIndex, out PageIndex);
            PageIndex--;

            //如：blog:JeffreyZhao 博客
            var zhankey = key.Split(' ');//先用空格分割
            var blogName = string.Empty;
            if (zhankey.Length >= 2)
            {
                var str = zhankey[0].Trim();
                if (str.Length > 6 && str.Substring(0, 5) == "blog:")
                    blogName = "/" + str.Substring(5);//这里取得 用户名
            }
            if (!string.IsNullOrEmpty(blogName))
                key = key.Substring(key.IndexOf(' '));

            //如：
            var url = "http://cn.bing.com/search?q=" + key + "+site:" + siteUrl + blogName + "&first=" + PageIndex + "1&FORM=PERE";
            var document = jumony.LoadDocument(url);
            var list = document.Find("#b_results .b_algo").ToList().Select(t => t.ToString()).ToList();

            var listli = document.Find("li.b_pag nav ul li");
            if (PageIndex > 0 && listli.Count() == 0)
                return null;

            if (listli.Count() > 1)
            {
                var text = document.Find("li.b_pag nav ul li").Last().InnerText();
                int npage = -1;
                if (text == "下一页")
                {
                    if (listli.Count() > 1)
                    {
                        var num = listli.ToList()[listli.Count() - 2].InnerText();
                        int.TryParse(num, out npage);
                    }
                }
                else
                    int.TryParse(text, out npage);
                if (npage <= PageIndex)
                    list = null;
            }

            return PartialView(list);
        }
        #endregion

 看看 我们的搜索结果的效果图吧。

总结
首先 搜索是必不可少的功能，但又不是主要功能。那么我们可以直接用lucene.net 来做搜索，然后用必应搜索做备用。但是 用必应 有个弊端。就是  如果我们 的文章页面 被用户自己删除了，而 必应已经收录了，那么 我们在搜索结果页面 点击 可能就是404 或 500 了。当然 我们自己的 lucene.net 也会有这个 问题，我们可以在用户删除 文章的时候 也删除 对应的那天搜索索引就好了。

 
演示地址：http://blog.haojima.net/Search/Index?key=blog:zhaopei 博客&p=1 
如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。 当然您还可以加入QQ群:讨论。
如果您有更好的处理方式，希望不要吝啬赐教。
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
本文链接：http://www.cnblogs.com/zhaopei/p/4783986.html
 
article  53
title: 一步步搭建自己的博客 .NET版（2、评论功能）
body: 
前言 

    这次开发的博客主要功能或特点：    第一：可以兼容各终端，特别是手机端。    第二：到时会用到大量html5，炫啊。    第三：导入博客园的精华文章，并做分类。（不要封我）    第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

 
    演示地址：http://blog.haojima.net/      群内共享源码：469075305 
 
    上一篇《一步步开发自己的博客（一）》发表之后得到的效应还不错，得到了二十几个赞。然后建的QQ群 两天不到 就有了进三十来个人。大家在群里关于建站经验讨论也是十分热烈。由此可见，大家对拥有自己的独立空间 是多么的渴望。
    这篇主要是分析 评论功能。在这里，不得不吐槽下 博客园的评论功能。
    第一、对于阅读者。大家有没有在看评论的时候，看着看着有往上翻？特别是有些对骂的评论，都不知道是谁在骂谁。不得不往上翻那个@的人发的是什么。不知道 这句话 是 对谁的哪句话做的回复。虽然有“引用”功能，但也有很多人没有使用。
    第二、对于博主。在回复各位园友时，点击回复 ，然后 跳到 最下方，然后评论框 自动出现@***  回复之后。想回复下一位，又要把滚动条拖上去。然后 又忘记 这个人是不是已经回复过了。又往下拖 看自己有没有回复过，或者有没有漏掉谁。如果评论够多的话 我相信 各位应该都这样的感觉，我的那个头 我的那个晕。
    在这里 我就打算规避这类问题，像QQ空间的评论 就很爽，谁在和谁对话 一目了然。
表结构
      对于这样的一个需求，没有做过的也许一时没有了头绪。这里最主要的关系就是，“引用”- 谁对谁说。是对哪条评论 展开的讨论。
      其实我把表结构拿出来，相信大家就明白了。
      这里  我再详细分析下每个字段。
      ID：表主键
      Content:评论的内容     
 
      CommentID：引用的评论内容的ID。
      BlogUsersId：用户ID
      BlogsId：博客ID
      ReplyUserID：引用的评论的用户ID。
      ReplyUserName：引用的评论的用户名。
 
      CommentSort：没用（本来以为会用到）
      ContentLevy：没用（本来以为会用到）
       这里要说明下    CommentID：引用的评论内容的ID。其实并非真的是评论内容ID 而是"父评论ID"。我们为了简单起见，把评论分成两种。
父评论，子评论。什么是父评论，子评论？父：初始评论，子：在父评论的基础上进行评论，或者子评论的基础上进行评论。（这里就不分 子子评论  子子子评论了。我想递归应该也可以做到，但不想那么复杂了）
      那么上面还有一个字段没有解释：
      IsInitial  是否是"父评论"
 
 
如图：      
实现
     通过对表结构的简单分析，我相信 大家应该已经非常明白 我会怎么去实现了。
   第一、评论提交

var BlogId = int.Parse(Request.Form["BlogId"]);
var UserId = MySession.UserInfoSessioin.Id; //int.Parse(Request.Form["UserId"]);
var CommentID = int.Parse(Request.Form["CommentID"]);
var Content = Request.Form["Content"];
var ReplyUserID = int.Parse(Request.Form["ReplyUser"]);
var ReplyUserName = string.Empty;
var User = BLL.Common.CacheData.GetUserInfo().Where(t => t.Id == ReplyUserID).FirstOrDefault();
if (null != User)
{
    ReplyUserName = string.IsNullOrEmpty(User.UserNickname) ? User.UserName : User.UserNickname;
}

BLL.BlogCommentBLL comment = new BLL.BlogCommentBLL();
comment.Add(new BlogComment()
{
    BlogUsersId = UserId,
    BlogsId = BlogId,
    Content = Content,
    CommentID = CommentID,
    ReplyUserID = ReplyUserID,
    ReplyUserName = ReplyUserName,
    IsInitial = CommentID == -1
});
comment.save();

 
       一目了然，其实就是一个对象存入数据库了。至于每个字段的取值，你想怎么取看你自己的。
   第二、加载评论
      评论的加载 可能会比提交复杂那么一点。提交有前后 怎么去归类布局呢？
      首先要对 父评论 的筛选，然后加载父评论 和 父评论下的子评论。感觉要进行多次数据库的查询，那么我们只能尝试尽可能少的查询。
      下面来具体看实现代码。      

int blogId = int.Parse(Request.Form["blogID"]);
int pageIndex = int.Parse(Request.Form["pageIndex"]);
BLL.CommentHandle com = new BLL.CommentHandle();
Dictionary<string, object> dic = new Dictionary<string, object>();
var comObj = com.GetComment(blogId, pageIndex);
if (null == comObj)
    return PartialView("Null");
dic.Add("commentList", comObj);//对应的评论
dic.Add("SessionUser", BLL.Common.MySession.UserInfoSessioin);
return PartialView(dic);      

  com.GetComment(blogId, pageIndex) 方法 根据 博客ID  和  第几页评论 做为参数，取评论数据，下面给出方法的详细实现：

public List<List<BlogComment>> GetComment(int blogId, int pageIndex)
{
    int total;
    BLL.BlogCommentBLL com = new BlogCommentBLL();
    //IsInitial == true 父评论 （第一次数据库查询：查询30条父评论）
    List<int> disCom = com.GetList<int>(pageIndex, 30, out total, t => t.IsInitial == true && t.BlogsId == blogId,
                        false, t => t.Id).Select(t => t.Id).ToList();
    if (pageIndex > total)//已经没有评论信息了
    {
        return null;
    }
    //第二次数据库查询：查询30条父评论 和30条父评论下的子评论
    var listCom = com.GetList(t => disCom.Contains(t.CommentID) || disCom.Contains(t.Id)).ToList();
    List<List<BlogComment>> ComObj = new List<List<BlogComment>>();
    var ini = listCom.Where(t => t.IsInitial == true).ToList();//这里就不查数据库了直接进行集合筛选
    //对评论进行分组（以父评论 分组）
    foreach (BlogComment item in ini)
    {
        item.BlogUsers = CacheData.GetUserInfo().Where(t => t.Id == item.BlogUsersId).FirstOrDefault();              
        var userobj = CacheData.GetUserInfo().Where(t => t.Id == item.ReplyUserID).FirstOrDefault();
        if (null != userobj)
            item.ReplyUserName = userobj.UserNickname;
        //添加 以父评论 为一分组 的评论
        ComObj.Add(GetCom(item, listCom));
    }
    return ComObj;
}

    上面进行了二次数据库查询，其余的时候 都是进行 数据集合的筛选。在上面的代码中 我们看到了 方法 GetCom(item, listCom)// 取 顶级评论 下的子评论

private List<BlogComment> GetCom(BlogComment com, List<BlogComment> list)
{
    var li = list.Where(t => t.CommentID == com.Id).ToList();
    li.Insert(0, com);
    return li;
}

效果图和演示地址
        在此实现的全部过程都已经分析完了。我们来看看效果图和演示地址。
        效果图：
        演示地址：http://blog.haojima.net/admin/268.html （界面丑是丑了点，后期再美化。如果有美工愿意免费合作，非常欢迎~~）
        如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。 当然您还可以加入QQ群:讨论。
        如果您有更好的处理方式，希望不要吝啬赐教。
        一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
        本文链接：http://www.cnblogs.com/zhaopei/p/4744846.html 
 

 
疑问
     我在构思开发博客的时候，有个疑问。那就是怎样更好的统计文章阅读量。
     我知道的方式：
     第一、通过Cookie。（缺点：如果要进行访问量排行的话，可以人为清理cookie，恶意刷新访问量）
     第二、通过客户端取得IP（缺点：1.如果访问量大的话，每次插入数据库之前都要先查询是否存在。2.现在我们大多是公用外网IP，无法统计独立访客）
     疑问：1.cnzz的独立访客(UV)是怎么统计的。2.博客园的文章阅读量是怎么统计的。（进过测试，文章刷新第二遍的时候可以看到 阅读量 加一 ，然后清理cookie 后刷新 阅读量 加一，然后不管怎么刷 都没反应了）
     如果实在是找不到好的解决方案，我打算用 IP+系统版本+浏览器版本号 作为“联合主键”，如果“主键”24小时内重复两次以上，则不统计，如果cookie存在也不统计。
 
哪位大虾知道更好的解决方案能告诉我下，万分感谢。
 
article  54
title: EF遇到的一些问题
body: 
环境：EntityFramework 版本号：4.1.0.0
问题一：“数据读取器与指定的“。。。.。。。”不兼容。某个类型为“。。。”的成员在同名的数据读取器中没有对应的列。”。
使用方式：rep.context.Database.SqlQuery<T>(sql, pList.ToArray<object>()); //sql       是直接字符串拼接的
问题原因：T 是个视图，因为数据库中的字段是有前缀"C_"，而生产实体的时候 我们做了去前缀的操作。导致 字段对应不上。
解决方案：在拼写sql 字符串的时候 把有前缀的字段 起个别名去掉前缀。如： C_DISP_TYPE_NM as DISP_TYPE_NM。
 
问题二：“V_CLAIM_DISPATCH 的“MAIN_STAT”属性不能设置为“Int64”值。必须将该属性设置为类型为“Int32”的非 null 值”
使用方式：var surveyList = claimBiz.FindAll<V_CLAIM_DISPATCH>(sqlText, pList); 
问题原因：【不明】猜想可能原因是，数据库是number（10），生成的实体是int。而实际读出来的数据要对应int64。但那个字段类型的映射是EF自动完成的，不能人为修改。所以报错。
解决方案：重新写个类V_CLAIM_DISPATCH_COPY  标志字段 Nullable<Int64> MAIN_STAT。上面的使用方式 var surveyList = claimBiz.FindAll<V_CLAIM_DISPATCH_COPY  >(sqlText, pList);  把泛型改成自定义类。
 
问题三：多对多 新增数据时 对应关系表也会增加一条数据。
例如：科目表 有语文 数学，我新增一条学员信息 对应科目语文。更新成功后科目表 也会重新新增一条”语文“的信息。
问题原因：在添加 学员信息时  查询的科目 语句用到了 AsNoTracking （即 不被实体被EF context追踪，查询出来的实体不能直接用于更新和删除，否则报错）。参考资料 1 2 3
解决方案：在查询科目 的时候  把 AsNoTracking  这个方法去掉。[然后有出现了 问题四 ]
 
问题四：一个实体对象不能由多个 IEntityChangeTracker 实例引用
问题原因：在添加Add 实体时 在实体的 导航属性添加了 关系实体。 查询资料：1
（
如： var modelMyBlogs = new Model.MyBlogs(){}; 
      modelMyBlogs.BlogTags.Add(itemBlogTag);
       blog.Add(modelMyBlogs);
itemBlogTag 是由重新实例DbContext查询出来的。
）
解决方案：直接吧DbContext放到session里面或者进程内公用。（我是直接放session里）
 
问题五：查询异常的慢。
可能原因：
1.数据量大 筛选条件没有 EntityFunctions.AsNonUnicode   http://www.cnblogs.com/zhaopei/p/4431461.html
2.如果查询出来的结果集不用更新和修改 可以 在后面加 AsNoTracking 方法（不被实体EF context追踪）
 
article  55
title: 关于健康和运动
body: 
    像我们程序猿/媛们，天天坐在电脑旁边。运动量为零，还要时刻接受电脑的辐射。那么日子长了，健康自然就出问题了。什么近视眼和肩周炎应是最常见的，就是所谓的职业病。IT界有名的乔帮主都挂了，国内的有张孝祥也挂了年仅38，不是还有李开复也得了淋巴癌。这是大名鼎鼎的。其中还有多少多少的IT草根，加班猝死，时不时都有这样的新闻。难道这还不够我们程序猿/媛们引起警觉吗？健康是大问题啊。身体是革命的本钱， 身体不好，拼不过菜鸟。很多人对技术非常的热爱，天天无休止的学习进步，当人投入到了一件事情里面去了，是不知道时间过了多少的，也许天天加班加点的，但是从中得到了提升，我们就不觉得那么累了。但心里好像过的充实、兴奋，身体就不一定受的了了。
    万事开头难，千里之行始于足下。那就从今天开始，从现在开始。每天进步一点点，坚持下来，你会发现原来我也可以。
    下面我就来与大家分享下，我最近的运动情况。我觉得有效的运动，还是要做有氧运动，比如慢跑啊、爬山啊、滑冰啊、、我在上海，这边都没有看到山，所以只能选择跑步了。滑冰偶尔去。怎样坚持自己的运动呢？最好有个运动记录软件，那样的话，就好像有个东西在督促着，然后有份数据在那里自己的特有成就感。

 
 

 
    这就是我17天的运动数据，其中除了天气下雨和加班。每天必跑。其实老早去年的时候我就想跑步了。一直觉得实在是没时间。唯一有时间就只有周末了，发现周末两天实在是很难坚持。后来又想，要不早上跑吧，懒床有起不来。某次，偶然晚上有人跑步，想了想，那我就晚上跑吧。说实在的，刚开始确实很累很吃力。跑的时候，眼都看不清前面、脚也抬不起来、严重缺氧，肚子里面像打翻了什么一样。但我还是坚持了，心想付出了汗水，总会有回报的。不仅可以锻炼身体，更能锻炼我的毅力。刚开始的时候回到家里起码要半个小时后才能恢复，现在慢慢的十分钟不到就能呼吸平稳，也不继续流汗了。
 
一个人跑步是很孤独的，如果人多了。更能坚持。所以大家可以在网友约跑友一起。
 

 
----------------------------------更新2016-07-10----------------------------------
距离这篇博文发布已经一年多了，是时候更新下数据了。

 

什么事，都是贵在坚持。且，我们每个人都是可以被自己的坚持所吓到！
跑步是一种生活，当你汗流浃背的感觉有多爽，整个人都是轻松的。
不一定要跑多远，但是一定要坚持每天都跑。
我们不比时间、不比路程、不比速度，我们只比看谁更能坚持。
不要求有兔子般的速度，只求有乌龟般的精神。

 
另，热爱运动的农码可以进群（咕咚群）分享心得：
团号：11251918

 
article  56
title: 一步步开发自己的博客  .NET版 剧终篇（6、响应式布局 和 自定义样式）
body: 
前言 

    这次开发的博客主要功能或特点：    第一：可以兼容各终端，特别是手机端。    第二：到时会用到大量html5，炫啊。    第三：导入博客园的精华文章，并做分类。（不要封我）    第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

 
演示地址：http://haojima.net/      群内共享源码：469075305 
 

《一步步开发自己的博客》这个系列到这里算是完结了。前面的注册、登录、评论、发布、搜索每个星期一篇博文，同时每个星期（也就周末两天）一个版本。这个博客系统使用是的mvc4 ef6.0，对于mvc之前没是没有使用过。在这个系统里面使用 我也是边学边用。肯定有用的不足和不全的地方，那我也只能后期再修修改改了。我想说的是，前奏给足了，我们现在是不是 该来点高潮的呢？
我们今天要分析的是 响应式布局 和 自定义样式。兴奋吧、激动吧，我自己都淡定不下来了。哈哈。 前面我们做了那么多铺垫，就是为了今天的 响应式布局 和 自定义样式。在这个多终端的时代，你不能在移动端正常显示？ out了吧。那么  我们怎么实现 响应式布局呢？有人马上会说Bootstrap，好吧我确实知道这么个东西。但是 实话 我也没怎么用过 ，不熟悉 不了解。但是我知道肯定是 根据屏幕分辨率大小  给不同的样式。既然 这样 我们何 不自己写呢。毕竟 别人的 东西，如果不够了解的话， 总会出现未知的情况。
好了，说了这么多。来说说今天要分析的重点内容吧。
首页的响应式布局
为什么说是首页的响应式布局呢？因为 我只打算做首页 的 响应式布局。博客内容的 显示页面 由用户自定义。别急 这个等下后面会讲到。
1.什么是响应式布局？


    响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。
响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。--来源百度百科


2.怎样实现响应式布局
现在响应式布局用得比较大众的应该是Bootstrap，但是我并不打算使用。原因很简单，我对Bootstrap不熟悉不了解。然后 我简单的看了下Bootstrap是怎么实现的响应式布局。原理很简单，就是使用到了CSS3中的media。media何方神圣？可以用来吃吗？它可以针对不同的媒体类型定义不同的样式，也可以针对不同的屏幕尺寸设置不同的样式。且当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。既然如此，响应式何愁。
3.media的简单使用
Max Width：在可视区域的宽度小于 600px 的时候被应用。

@media screen and (max-width: 600px) {
  .class {
    background: #0094ff;
  }
}

Min Width：在可视区域的宽度大于600px 的时候被应用。

@media screen and (min-width: 600px) {
  .class {
    background: red;
  }
} 

简单？对，就是如此简单。您还可以 在600到900直接的启用。

@media screen and (min-width: 600px) and (max-width: 900px) {
  .class {
    background: #0094ff;
  }
}

当然，您还可以，放入单独文件。爽歪歪了吧。

<link rel="stylesheet" media="screen and (max-width: 600px)" href="max600.css" />

好了，你已经知道得太多了。实现一个首页的响应式 基本上已经够用了。
默认样式 显示 移动端：

.blog_body_e.col-xs-12 .a_blog_user {
    display: inline-block;
}

.blog_body_e, .blog_body_b {
    padding-left: 10px;
    padding-right: 10px;
}

如果是PC端：（默认 大于992px就算是PC端 当然，你也可以自定义）

@media (min-width: 992px) {
    .blog_body_e.col-md-3 .a_blog_user {
        display: block;
    }

    .blog_body .blog_body_b {
        width: 80%;
        float: left;
    }

    .blog_body .blog_body_e {
        width: 20%;
        float: left;
        box-sizing: border-box;
        padding-right: 25px;
    }

    .blog_body_e, .blog_body_b {
        padding-left: 20px;
        padding-right: 20px;
    }
}

我们看分布看看效果图
PC端：

手机端：
        
还可以吧，。
ASP.NET MVC移动端识别 
上面我们已经说了 响应式布局，但那是客户端的，针对于同一个视图页面的。不过 同一个视图页面 通过响应式布局 也是有缺点的 会导致页面 样式十分庞大 页面加载效率降低，而且只能 做局部的调整，如果 要做
大的调整 会比较复杂 或根本就不可能实现。
那我们有没有别的办法。答案是有的。如果我们 可以在后台 识别 请求过来的是  PC端 还是移动端，然后 加载不同的视图。这样  我们就可以有多 份视图。还好 我们伟大的ASP.NET MVC里面是很好实现的。你只要在你的请求的视图 在复制一个 改名为.Mobile.cshtml如：_Layout.cshtml和_Layout.Mobile.cshtml。没了？对 的 ，没了。如果是 移动端的请求 那么会自动请求_Layout.Mobile.cshtml如果是PC端 那么会自动请求_Layout.cshtml 。
这样 我们就可以针对两大类 再做响应式布局。
有人会说，我们在本地开发 都是PC端请求。那么我们怎么测试移动端的效果呢？一定要发布到线上 然后用手机测试？那多麻烦啊，每改一个样式都要 发布一次。好吧，我再告诉你一个 诀窍。在PC端 伪装成移动端直接在PC端看移动端的效果。看下面的代码，复制到Global.asax文件的MvcApplication方法里面。打开注释 就是 默认显示 移动端效果。发布的时候记得注释掉。

////打开注释 默认 是 移动端 显示效果
//DisplayModeProvider.Instance.Modes.RemoveAt(0);
//DisplayModeProvider.Instance.Modes.Insert(0,
//    new DefaultDisplayMode("Mobile")
//    {
//        ContextCondition = Context => true
//    }
//    );

 
关于自定义样式
自定义样式
我们都是向往自由的，一个博客怎么可以没有自定义样式的功能呢？好吧，那我就加一个。
那么自定义样式有哪些功能呢？CSS样式、JS脚本权限、页首html、侧边栏html、页尾html 都给加上吧。既然你要自由，就给你绝对的自由。
当时，我还在考虑 自定义样式 存数据库 还是 存文本呢？存文本吧，一般也不会存在同时访问一个文件的情况。因为每个用户 都给了一个文件夹来保存。页面加载请求的时候也不用读数据库，直接请求文件 也会要快很多。
说到想到、想到做到，我们每个登录用户在 跳转到 自定义 样式页面的时候 我们 会检测 是否存在，如果存在 则加载之前 的内容，不存在 创建一个空的文件。当请求博客内容页面的时候 如果有 自定义样式 直接加载 过来 ok。简单。
禁用默认主题样式
我们上面 修改了样式 ，但是 我们的默认 主题的样式 还是存在的，除非 你全部覆盖掉。有的前端 的高手 ，可能就要说了，我想直接禁用默认主题样式啊，一个个的去覆盖你的多麻烦。好吧，我们做程序员的就是这么苦逼，你想要，我就给。。这里，正好 我们把之前 页面内的css样式 和 行内css全部分离处理，放到单独的 css文件里。然后 我们 在请求博客内容页面的时候，判断 你是否禁用的  默认样式 ，如果是 我们就不加载了。
在其他博友页面启用自定义主题样式
这可是我们的重头戏了。什么是 “在其他博友页面启用自定义主题样式”，那个谁 还说我是在玩强奸，我想说  你误会了。“在其他博友页面启用自定义主题样式” 是有条件的。第一、你必须在你的设置页面 勾选了“在其他博友页面启用自定义主题样式”。第二、你必须是登录状态。（那么也就是说 其实 只有你自己看得到而已，其他用户 或 没有登录的游客  看到的 还是 博客对应的原始用户 定义的主题样式）,为什么要这么做呢？没有为什么，我就是嫌弃定义的主题样式太丑了，我不想看，但是 你的文章内容又很有营养，想看。纠结了吧。 那就显示我自己的主题样式来阅读你的文章内容，这样 你可以定义 有利于在移动端的样式 然后阅读任何人的文章。爽吧。
说是这么说，怎么实现呢。其实 我们都已经讲了，我们在数据库里面存一个bool值 是否 启用显示 。然后 我们浏览博客内容的时候 检测 是否 是登录状态，如果否，这 显示 博客用户的 主题样式。如果是登录状态，然后在在判断 你是否启用了， 如果没有启用 还是 显示 博客用户的样式，最好 如果你登录了 然后 启用了 最后 才在其他博友 的博客内容页面 显示你自己 定义的样式。
手机端自定义样式和PC端自定义样式
前面我们已经说过了，可以在MVC后台识别请求的是移动端还是PC端，那我们就 做两份视图，你可以分别自定义 移动端样式 和 PC端样式。 
效果图：（截图好像好多小蝌蚪）
总结

这里主要讲了 响应式布局 然后 在响应式布局不能满足的情况下 我们可以 建立 针对不同的终端 建立 对应的 响应式 这样 可以缩小 范围 有利于 页面的加载 和 页面跟好的显示。然后  我们还说了 自定义样式、和禁用样式 在 其他博友页面启用 自定义主题样式。其实 用代码实现起来 都不难。只要 理清了 逻辑 和自己想要的效果。
关于这系列博客 到这里 也该告一段落了，真心话 一个星期一个版本 就周末两天 真心的累。绷紧的神经 感觉好久都没有放松过了。在这里  我要感谢 一路园友们的支持，不然 我还真坚持不下来。
现在  我终于 可以放松放松 ，然后陪陪老婆了。这阵子 老是抱怨我  电脑才是 我的老婆，都不和她说话了。
有人说，那你的这个博客系统都不用维护的吗？要维护，还会加 没有想到的 一些功能 和效果。 不过 不用这么 急迫了。趁着这段时间 我可以慢慢的 重构下 代码。
后期 我在这个 博客系统  中觉得有用的 或 新加的功能 会再单独 写博文来分析。
这才是第一版哦，还会有第二版 第三版，当然 要是有人关注的话。
（我们的终极目标是：PC移动兼容、能在各大博客网收藏保存文章到我们的博客系统、能在手机客户端离线下载阅读博客文章）

对了，如果 谁有兴趣开发 iPhone、iPad或安卓客户端的 可以联系我。(我们的目的很简单 只是一起学习而已)
暂时提供API:http://blog.haojima.net/UserBlog/webapi 而且已经有朋友 做出了 安卓版的 雏形。（当然 这位朋友 到时候也会写安卓版 系列文章 和大家一起探讨学习 【请移步到此】）
    
 

演示地址：http://blog.haojima.net/Admin/ConfigurePC 
如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。      
当然您还可以加入QQ群:讨论。
如果您有更好的处理方式，希望不要吝啬赐教。
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
本文链接：http://www.cnblogs.com/zhaopei/p/4823359.html
开源地址：http://git.oschina.net/zhaopeiym/Hi-Blogs

 
article  57
title: 学习经历感想
body: 
前言

嗨-博客 开源了...
开源地址：https://git.oschina.net/zhaopeiym/Hi-Blogs我们可以用 开源中国的源代码管理 同时使用它GIT 和SVN。有兴趣的同学 可以 贡献代码。让我们一起来完善这个 博客系统。关于GIT和SVN的使用：http://www.cnblogs.com/zhaopei/tag/git/

其实 前几天 我就已经把源码 挂在 开源博客上了。本来打算下周写篇博文的时候  告诉大家 开源地址的。
今天我在 开源中国上 看了下 热门开源项目 如下。 所以 我就忍不住 的写下了本文。
                   
你们应该发现问题了吧。今日热门、本周热门、本月热门 有java、javasript、android、php  唯独没有.net C#。 这是为何？ 我百思不得其解。
难道 我们学 C#的都是 去了 GitHub？也许吧。 或许 我们根本就不屑于 开发那些  小玩意。
为什么会这样
大家都说 学.NET 的平均工资要比java低。那为什么会这样呢？.net入门相对比 java 简单。通过初级筛选 学习.net就比 java平均水平低了。
既然 我们大多数的 人 一开始 就比别人 差了那么一丢丢。我们是不是 要加把劲 赶上去。
对于我自己，说句实话。在学校  那个时候 学java 学不进 然后再学的 .net 。但 这并不是说  .net 就要比那个谁差。因为 我E语文盲。啥都不认识。
学.net 的一个优势 是 IDE 有官方汉化，资料有官方中文版。就是因为微软 地区化 做得好。所以 我才选择的.net。既然选择了，那么就要就要把自己的路走好，走远。
分享精神

一个人 闷头 写代码 是无趣的。我们需要 在一个 群体 里面 分享、讨论。
 我为什么要分享？因为  当得到 大家 的认同的时候，虚荣心 特别的满足。
如果 能帮助到你 或者 能激发你一点 灵感 ，那么 我也会感到 很高兴。
当然，我们在 研究和实践的过程 肯定是会遇到一些问题的，大家能在一起 讨论 会得到意想不到的 收获，也许 没有能过 直接告诉你 最佳方案，但很多时候 都会 激发你更多的灵感。
还有，一些 不足 是我们自己认识不到的。别人 一眼就看出来了。这个时候 我们就需要  有一颗谦虚的心来接受。然后  你会发现 你已经得到了提升。
参与其中 其中 你会发现 激发了 强烈的兴趣，我们是一群志同道合的人。我们在做一件大家都非常热爱的事。那是外人无法体会到的 充实和 满足。我们的人生有了追求 有了方向和理想。

 
正在看此文的你，我们一起行动起来吧。我们C#的这个群体需要你，不要说  你不重要。正是千千万万个你 组成 的我们这个大团体。
只要每个人都从“我”开始，我现在 我们这个团体 很快 就能得以 提升。
 
好了，说得够多的了。多说无益，听得进去的人 自然已经听进去了。
我们继续来说说 我们的博客系统。
很多朋友都说 就 “剧终”了啊。 我说过，远远没有。一个系统 是做不完的。我们可以 无止境的 优化 无止境的 新增功能。
在接下来的日子，我们 还会有第二版，第三版...（如果 有人关注的话）
 
然后，又有朋友说了，你都还有好多技术点 没讲到啊。在这里  感谢大家的关注。
我将在 一篇文章写一写 关于 “嗨-博客” 中的 文章阅读量统计、评论数量统计、日志的异步记录...等等。
我为什么要分享“嗨-博客”系统
首先，我开发这个系统，并没有想过 大家都会来使用（当然，如果大家乐意使用的话，我将会尽自己最大的努力去维护）。
我只是 通过 这个"试验品"来实践一下 自己所学。然后 现在 有人 一起学习，我也希望 尽可能 讲到 每个细节点，让你也能开发出 一个属于自己的 博客 系统。
不然 我们很多时候  一直在学习，然后 学了又忘，忘了又学。
我自己就是 很早之前 就看过一些mvc的东西，但是 工作中并未使用。所以 没几天 忘得一干二净。
我想了下，不能老是做这样 无用功的事情了。那么就 做个东西出来吧。把所学实践运用起来，加深自己的理解和记忆。所以 这个“试验品”就诞生了。
然后 就一发不可收拾，加上 园友们的 支持 更是  越来越起劲。从中  我也是 得到了 意想不到的 好处。

接触了  我之前 一直没有 接触过的缓存
了解了 响应式布局 原理。
自己做了一个 异步 单线程 日志记录。
实现了 阅读量统计
做了自己的 评论系统。
开始了解 webapi
等等...

在此之前  这些东东  我想都没想过。 这就是所谓的  良性循环吧。当你 走出了第一步 ，你会发现 世界 原来是这么的大。
然而，我们 很多 同学就是不肯迈出第一步。因为 他 不知道 外面还有世界。
当你会了一个东西，你会发现 你还有两个东西不会。当你会了两个东西，你会发现 你还有四个东西不会。然后  你发现 会得越多，不会的 也会越多。
如果 你现在 你觉得  没有什么  是你需要知道的 ，其实  那反而说明 你不会的 更多。这也就是    大牛  都低调的原因吧。
 
结束语

当然 这只是 我个人 的一些 流水账式感想，并不要求 大家 都认同。
你可以有不同的见解，但是 希望 不要恶意 攻击。
如果无意冒犯了，那就当我放了一个气。
原文链接：http://www.cnblogs.com/zhaopei/p/4836739.html 

 
article  58
title: 开发自己的博客转发插件（跨域）
body: 
    接着上一篇的《博客备份小工具3》我有提到“其实想了想，转发博客干嘛非要在本地客户端转发，直接在博客园的页面用js不就可以达到目的么。想是这么想，还没尝试。等我写完了这个博客就去试试。。”。想法很天真，现实很残忍。本以为，直接ajax异步post请求就可以把当前页面的内容发布。可是，问题来了。我们浏览的页面域名是cnblogs.com，而我们后台发布的域名是i.cnblogs.com。跨域了，亲。问题既然来了，总不能半途而废吧。程序的世界没有办不到，只有想不到。jsonp专门来干这事的。（jsonp资料传送门）。   为什么不用《博客备份小工具3》，因为它是CS的。要是可以直接在浏览页面有个按钮一键转发岂不是爽歪歪。貌似Chrome插件可以专门来干这等坏事。（chrome插件介绍传送门）。好了就这两个重要的点了。
   下面来说说主要的实现思路，首先通过插件在浏览页面给自己找块地盘（添加一个div）。然后div中可以输入用户名、密码登录，取得文章类型。接着就一键发布，把当前页面的内容通过jsonp跨域传到自己开发的后台发布~是不是很简单呢？哈哈，其实我觉得挺难的。中间遇到了很多问题。就现在，估计还有很多的bug。
   好了，先看看效果图。感觉爽吗？要是当心安全问题，下面我会把所有源码开放。大伙可以改进。^_^

一、开辟一片空间
插件content_script中配置的content_script.js,在content_script.js中可以直接操作当前浏览页。哈哈，这还了得，这岂不是到哪里都随心所欲了。好吧，那么我们给自己开辟一片空间来做想要的操作。

    var mydata = "";
    mydata += "&url=" + document.location.href;
    mydata += "&type=mytype";
    mydata += "&tag=mytag";

    var html = " <div id='chrome_test_div' style='display:none;background-color:#0094ff; position: fixed; top: 0px; left: 0px; width: 100%;z-index:11'>\
        <table style='width:100%'>\
            <tr>\
                <td>用户名：</td>\
                <td><input id='chrome_test_user' type='text' value='' /></td>\
                <td>密码：</td>\
                <td><input id='chrome_test_pass' type='password' value='' /></td>\
                <td>\
                    <a href='javascript:void(0);' id='chrome_test_a' >\
登录\
</a>\
</td>\
<td>\
文章：\
</td>\
<td>\
<span id='chrome_content_title'></span>\
</td>\
\
<td>个人分类:</td>\
<td>\
    <select id='pop_sel_type_text'></select>\
</td>\
\
<td>\
    Tag标签:\
                </td>\
                <td>\
                    <input type='text' value='' list='pop_sel_tag_text' id='id_pop_sel_tag_text'>\
                    <input type='hidden' id='myhidden' />\
                    <!--<datalist id='pop_sel_tag_text'></datalist>-->\
                </td>\
                <td colspan='2'><input type='button' id='chrome_test_button' value='一键转发'  /></td>\
                <td  id='chrome_meg_td'></td>\
            </tr>\
        </table>\
        <script src='https://git.oschina.net/zhaopeiym/Demo/raw/master/resource/cnblogs/cnblog.Chrome.js?v=123'></script>\
    </div>";

    $("body").prepend(html).css("margin-top", "70px");
    $("#chrome_content_title").text($("#cb_post_title_url").text());
    document.body.scrollTop = 30;
    window.onscroll = function () {
        if (true) {
            var top = document.body.scrollTop;
            if (top <= 0) {
                $("#chrome_test_div").slideDown(200);
            }
            else if (top >= 30) {
                $("#chrome_test_div").slideUp(400);
            }
        }
    }

 
直接添加一个div，然后在div中添加一个table。画上登录要的用户名、密码、文章标题、后台发布的文章类型、tag标签、、、等。
二、登录 获取 你所有的文章分类。
1、用jsonp发送请求
不知道同学们有没有注意到上面的代码中有一段
<script src='https://git.oschina.net/zhaopeiym/Demo/raw/master/resource/cnblogs/cnblog.Chrome.js?v=123'></script>是的，我所以当前操作页的js都在这个路径下。

function chrome_test_login() {
    var username = $("#chrome_test_user").val();
    var password = $("#chrome_test_pass").val();
    var Section_url = "&username=" + username + "&password=" + password;
    $.getJSON(getjsonUrl + '/BolghelpWeb/Handler1.ashx?OperationCMD=login' + Section_url + '&callback=?', function (data) {
        test(data);
    });
}

 
登录的js。ajax的jsonp使用起来还是蛮方便的。
2、后台代码的登录和取文章分类
登录：

 /// <summary>
 /// 登录
 /// </summary>
 /// <param name="context"></param>
 public void PostLogin(HttpContext context, string username, string password)
 {
     username = context.Request.QueryString["username"];
     password = context.Request.QueryString["password"];

     string loginurl = "http://passport.cnblogs.com/login.aspx?ReturnUrl=http://www.cnblogs.com/";//
     string result = htmlWeb.Load(loginurl).DocumentNode.InnerHtml;
     String __EVENTVALIDATION = new Regex("id=\"__EVENTVALIDATION\" value=\"(.*?)\"").Match(result).Groups[1].Value;
     String __VIEWSTATE = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\"").Match(result).Groups[1].Value;
     String LBD_VCID_c_login_logincaptcha = new Regex("id=\"LBD_VCID_c_login_logincaptcha\" value=\"(.*?)\"").Match(result).Groups[1].Value;

     StringBuilder str_content = new StringBuilder();
     str_content.Append(@"__EVENTTARGET=");
     str_content.Append(@"&__EVENTARGUMENT=");
     str_content.Append(@"&__VIEWSTATE=" + System.Web.HttpUtility.UrlEncode(__VIEWSTATE, Encoding.UTF8));
     str_content.Append(@"&__VIEWSTATEGENERATOR=C2EE9ABB");
     str_content.Append(@"&__EVENTVALIDATION=" + System.Web.HttpUtility.UrlEncode(__EVENTVALIDATION, Encoding.UTF8));
     str_content.Append(@"&tbUserName=" + System.Web.HttpUtility.UrlEncode(username, Encoding.UTF8));
     str_content.Append(@"&tbPassword=" + password);
     str_content.Append(@"&LBD_VCID_c_login_logincaptcha=" + LBD_VCID_c_login_logincaptcha);
     str_content.Append(@"&LBD_BackWorkaround_c_login_logincaptcha=");
     str_content.Append(@"&btnLogin=登  录");
     str_content.Append(@"&txtReturnUrl=http://www.cnblogs.com/");

     httphelp.PostHtml(loginurl, null, str_content.ToString(), Encoding.UTF8, true);
 }

 
取文章分类：

/// <summary>
/// 取文章类型
/// </summary>
/// <param name="context"></param>
public void PostGetType(HttpContext context)
{
    PostLogin(context, "", "");

    string TypeUrl = "http://i.cnblogs.com/EditArticles.aspx?opt=1";//地址                                
    var typeHtml = httphelp.PostHtml(TypeUrl, null, "", Encoding.UTF8, true);
    HtmlAgilityPack.HtmlDocument response = new HtmlDocument();
    response.LoadHtml(typeHtml);
    var html_trS = response.DocumentNode.SelectNodes("//*[@id='Editor_Edit_APOptions_Advancedpanel1_cklCategories']/tr");

    List<object> objs = new List<object>();
    foreach (var item in html_trS)
    {
        var html_tdS = item.SelectNodes(item.XPath + "/td");
        foreach (var item_td in html_tdS)
        {
            if (item_td.SelectSingleNode(item_td.XPath + "/input") != null)
            {
                var value = item_td.SelectSingleNode(item_td.XPath + "/input").Attributes["value"].Value;
                var name = item_td.SelectSingleNode(item_td.XPath + "/input").Attributes["name"].Value;
                var text = item_td.SelectSingleNode(item_td.XPath + "/label").InnerText;
                objs.Add(new { value = value, text = text, name = name });
            }
        }
    }
    context.Response.ContentType = "application/json";
    string callback = context.Request.QueryString["callback"];
    context.Response.Write(callback + "(" + objs.ToJson() + ")");
}

 
ok，在此就登录，并取到了所有的文章类型。
三、一键发布
其实在发布之前又登录的一次。为什么呢？因为发布需要登录，之前登录的是上一次请求。而上一次请求的session，在这一个是读不到的。可能是因为跨域请求的原因。那没办法的，那就再登录一次吧。反正登录的反法已经独立出来了。只是电脑多干事了。
1、首页在前台页面取得要转发的正文内容

//一键转发
$("#chrome_test_button").click(function () {
    $("#chrome_meg_td").html("");

    var type = $("#pop_sel_type_text").val().split('%')[0];
    var name = $("#pop_sel_type_text").val().split('%')[1];
    var username = $("#chrome_test_user").val();
    var password = $("#chrome_test_pass").val();
    var tag = $("#id_pop_sel_tag_text").val();
    var Section_url = "&type=" + type + "&tag=" + tag + "&name=" + name + "&password=" + password + "&username=" + username;
    $.getJSON(getjsonUrl + '/BolghelpWeb/Handler1.ashx?OperationCMD=Publishing&callback=?' + Section_url + '&url=' + document.location.href, function (data) {
        $("#chrome_meg_td").html("发布成功~<a href='http://i.cnblogs.com/EditArticles.aspx'  target='_blank'>后台查看~</a>");
        $("#chrome_test_div a").css("color", "#fff");
    });
});

 
2、然后是后台发布

 /// <summary>
 /// 发布
 /// </summary>
 /// <param name="context"></param>
 public void PostPublishing(HttpContext context)
 {
     string url = "http://i.cnblogs.com/EditArticles.aspx?opt=1";//地址   

     string callback = context.Request.QueryString["callback"];
     string mydataurl = context.Request.QueryString["url"];
     string mydatatype = context.Request.QueryString["type"];
     string mydatatag = context.Request.QueryString["tag"];
     string mydataname = context.Request.QueryString["name"];

     PostLogin(context, "", "");
     var html = httphelp.PostHtml(url, null, "", Encoding.UTF8, true);
     String __VIEWSTATE = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\"").Match(html).Groups[1].Value;
     string title = "test", body = "test";
     GetRequest(mydataurl, ref body, ref title);

     body += "</br>==================================<a  href='" + mydataurl + "' target='_blank'>原文链接</a>===此文章由<a href='http://www.cnblogs.com/zhaopei/' target='_blank'>博客转发插件</a>转发==================================";

     StringBuilder str_content = new StringBuilder();
     str_content.Append(@"__VIEWSTATE=" + System.Web.HttpUtility.UrlEncode(__VIEWSTATE, Encoding.UTF8));//随便分类信息和__VIEWSTATE有关    所以 分类  不好弄
     str_content.Append(@"&__VIEWSTATEGENERATOR=FE27D343");//FE27D343   0512620B
     str_content.Append(@"&Editor$Edit$txbTitle=" + System.Web.HttpUtility.UrlEncode("【转】" + title, Encoding.UTF8));
     str_content.Append(@"&Editor$Edit$EditorBody=" + System.Web.HttpUtility.UrlEncode(body, Encoding.UTF8));
     str_content.Append(@"&" + mydataname + "=" + mydatatype);
     str_content.Append(@"&Editor$Edit$Advanced$ckbPublished=on");//发布
     str_content.Append(@"&Editor$Edit$Advanced$chkDisplayHomePage=on");//博客首页显示
     str_content.Append(@"&Editor$Edit$Advanced$chkComments=on");//允许评论
     str_content.Append(@"&Editor$Edit$Advanced$chkMainSyndication=on");//显示在RSS中
     str_content.Append(@"&Editor$Edit$Advanced$txbEntryName=");//友好地址名，只能使用字母、数字、-连字符、_下划线，不超过150个字符
     str_content.Append(@"&Editor$Edit$Advanced$txbExcerpt=");//插入摘要右侧图片
     str_content.Append(@"&Editor$Edit$Advanced$txbTag=" + mydatatag);// Tag标签
     str_content.Append(@"&Editor$Edit$Advanced$tbEnryPassword=");//密码保护
     str_content.Append(@"&Editor$Edit$lkbPost=发布");

     var srcString = httphelp.PostHtml(url, null, str_content.ToString(), Encoding.UTF8, true);//发布

     context.Response.ContentType = "application/json";
     //输出：回调函数名(json数据)
     if (srcString.Contains("发布成功"))
         context.Response.Write(callback + "('ok')");
     else
         context.Response.Write(callback + "('no')");
 }

 
基本上就此完工了。哈哈~
四、怎么使用
有人可能还不知道怎么安装插件。360浏览器你只有把插件直接拖到浏览器里面就可以了。如果是谷歌原版浏览器那么就拖到chrome://extensions/这个页面。还有问题就百度怎么安装插件吧。
不想看源码的 可以直接下载插件使用，安装后打开任何一个博客园文章页面，然后把滚动条滚到最上就可以看到效果了（效果比较隐藏，为了不影响大家正常浏览页面内容）。 【下载地址】
 
五、源码下载
全部源码下载（包括插件源码、后台源码和引用的外部js）。亲，老规矩。如果觉得对您有用，而您又下载了。请您轻轻的点个赞呗~~
 
 PS：这篇文章本来是写于2015-04-02 20:25，准备第二天发布。然，第二天发现登录不了了。原来正好遇上的博客园修改登录方式。整了老半天也没有整出怎么登录，无意看到了一篇文章，借鉴了下思路。搞定！！这里主要也是弄着玩玩，还有很多功能后续再继续完善。如：记住密码、自动登录取分类数据、验证码问题（一般只有晚上才需要）、当然肯定还有很多bug，先这样吧，之后再慢慢修改。
 
article  59
title: 一步步开发自己的博客 .NET版（3、注册登录功能）
body: 
前言 

这次开发的博客主要功能或特点：    第一：可以兼容各终端，特别是手机端。    第二：到时会用到大量html5，炫啊。    第三：导入博客园的精华文章，并做分类。（不要封我）    第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

 
    演示地址：http://blog.haojima.net/      群内共享源码：469075305 
 
    今天主要来分析下注册和登录。关于这两个功能的实现我相信大家都有自己的经验，说容易可以做的很容易 说复杂可以做的很复杂。
    其实说白了，注册就是往数据库里面插入一条数据，登录就是查询数据库里面是否存在这条数据。当然，还可以有自己的规则验证。如：用户名不能重复，密码不能为空...
    为了防止别人恶意注册 可以加个邮箱验证。那我们用什么邮箱发邮件通知呢, 163 Mail ? QQ Mail ?, 那我们做站长的 也忒掉面子了吧。起码也得来个和你域名相关的企业邮箱啊，是不 (*^__^*)
    在这里我给大家分享一个免费的企业邮箱。 http://wanwang.aliyun.com/promotion/free-times/

      关于免费的企业有申请，这里就不做过多介绍了，申请后绑定自己的域名就ok了。
      接下来，开始分析我的注册和登录功能的实现。
获取激活码和激活
     这里首先说下获取激活码和激活处理。首先什么是激活码？ 这里的激活码主要是用来验证。第一、证明邮箱用户确实存在，这样可以有效防止恶意注册。第二、只有邮箱用户才可以做用户信息修改处理，如 密码修改。因为需要用到激活码的地方“可能”比较多，所有   我们把 这两个方法 分离出来。    
获取激活码
    获取激活码，其实也就是 先生成一个随机数，先保存到Session，然后通过邮件发送到注册邮箱。当然 这里有个重要的地方，那就邮件的发送帮助类。


  public class EmailHelper
    {

        #region Eail 属性

        private string _mailFrom = "system@haojima.net";
        /// <summary>
        /// 发送者
        /// </summary>
        public string mailFrom { get { return _mailFrom; } set { _mailFrom = value; } }

        /// <summary>
        /// 收件人
        /// </summary>
        public string[] mailToArray { get; set; }

        /// <summary>
        /// 抄送
        /// </summary>
        public string[] mailCcArray { get; set; }

        /// <summary>
        /// 标题
        /// </summary>
        public string mailSubject { get; set; }

        /// <summary>
        /// 正文
        /// </summary>
        public string mailBody { get; set; }

        /// <summary>
        /// 发件人密码
        /// </summary>
        public string mailPwd { get; set; }

        private string _host = "smtp.haojima.net";
        /// <summary>
        /// SMTP邮件服务器
        /// </summary>
        public string host { get { return _host; } set { _host = value; } }

        private bool _isbodyHtml = true;
        /// <summary>
        /// 正文是否是html格式
        /// </summary>
        public bool isbodyHtml { get { return _isbodyHtml; } set { _isbodyHtml = value; } }

        private string _nickname = "嗨-博客 系统通知";
        /// <summary>
        /// 发送者昵称
        /// </summary>
        public string nickname
        {
            get { return _nickname; }
            set
            {
                _nickname = value;
            }
        }

        /// <summary>
        /// 附件
        /// </summary>
        public string[] attachmentsPath { get; set; }

        //优先级别
        private MailPriority _Priority = MailPriority.Normal;
        /// <summary>
        /// 优先级别  默认正常优先级
        /// </summary>
        public MailPriority Priority
        {
            get
            {
                return _Priority;
            }
            set
            {
                _Priority = value;
            }
        }
        #endregion

        public bool Send()
        {
            //使用指定的邮件地址初始化MailAddress实例
            MailAddress maddr = new MailAddress(mailFrom, nickname);
            //初始化MailMessage实例
            MailMessage myMail = new MailMessage();

            //向收件人地址集合添加邮件地址
            if (mailToArray != null)
            {
                for (int i = 0; i < mailToArray.Length; i++)
                {
                    myMail.To.Add(mailToArray[i].ToString());
                }
            }

            //向抄送收件人地址集合添加邮件地址
            if (mailCcArray != null)
            {
                for (int i = 0; i < mailCcArray.Length; i++)
                {
                    myMail.CC.Add(mailCcArray[i].ToString());
                }
            }
            //发件人地址
            myMail.From = maddr;

            //电子邮件的标题
            myMail.Subject = mailSubject;

            //电子邮件的主题内容使用的编码
            myMail.SubjectEncoding = Encoding.UTF8;

            //电子邮件正文
            myMail.Body = mailBody;

            //电子邮件正文的编码
            myMail.BodyEncoding = Encoding.Default;

            //邮件优先级
            myMail.Priority = Priority;

            myMail.IsBodyHtml = isbodyHtml;

            //在有附件的情况下添加附件
            try
            {
                if (attachmentsPath != null && attachmentsPath.Length > 0)
                {
                    Attachment attachFile = null;
                    foreach (string path in attachmentsPath)
                    {
                        attachFile = new Attachment(path);
                        myMail.Attachments.Add(attachFile);
                    }
                }
            }
            catch (Exception err)
            {
                throw new Exception("在添加附件时有错误:" + err);
            }

            SmtpClient smtp = new SmtpClient();
            //指定发件人的邮件地址和密码以验证发件人身份
            smtp.Credentials = new System.Net.NetworkCredential(mailFrom, mailPwd);//115                 //设置SMTP邮件服务器
            smtp.Host = host;
            // smtp.EnableSsl = true;
            //smtp.Port = 587;
            try
            {
                //将邮件发送到SMTP邮件服务器
                smtp.Send(myMail);
                return true;

            }
            catch (System.Net.Mail.SmtpException ex)
            {
                return false;
            }

        }
    }

View Code 
    用法：

EmailHelper email = new EmailHelper()
            {
                mailPwd = 发送者密码,
                host = 邮件服务器,
                mailFrom = 发送者邮箱,
                mailSubject = 邮件标题,
                mailBody = 邮件正文,
                mailToArray = new string[] { 发送给}
            };
 email.Send();//发送

效果图：
激活
      激活，复制你邮件收到的激活码 和 session 里面保存的数据数  比较。如果 相等 则表示验证成功。然后，该注册 的注册 、该改密码的改密码。（验证成功后 可以发个邮件告知 注册成功 并发送注册信息 以免 注册用户 忘记 注销信息）
数据验证
      在注册和登录的过程中，有多处地方需要验证。如：用户名密码 必填非空 邮箱格式比较正确。然而，在MVC里的特性验证用起来 那个爽歪歪的。
      这里来说说我的用法（初次使用）。
      特性验证： Required 非空 [Required(ErrorMessage = "用户名不能为空")] public string UserName { get; set; }   
      我们直接把特性标识在属性的上面就可以了，如果在数据保存的时候 验证不通过 则会抛出自定义的 异常信息。不过这里有个问题，我们的实体类都是通过 tt 文件自动生成的。我们加上去的特性 在下次保存 tt 文件的时候 又会清空。不过微软的猿们 早就替我们想好了。tt 生成的是部分类。那么 我们也就可以在外部生成 一个部分类来 加特性 然后在编译的时候 自动合并。 
     这里是后台验证。当然 我们不能只仅仅验证后台，要是能直接在前台就能 屏蔽 验证不通过的请求 也能减轻服务器的 负担。接下来要说的 就是 “爽歪歪”的。我们在后台加的特性验证，可以直接在前台也做验证。好神奇，这是怎么实现的呢？其实我们看看生成的html代码 就大概会猜到了。
     首先 我们在View 的 Razor视图 使用的强类型的“声明”。 @model BlogUsersSet 
     然后 在View的使用  @Html.TextBoxFor(t => t.UserName)    可以直接使用拉姆达表达式 爽啊。
     我们可以看到前台生成的html代码 

<input class="txt_username" data-val="true" data-val-required="用户名不能为空" id="UserName" name="UserName" type="text" value=""> 

     看到这里 我们是不是已经明白了点什么呢？ 验证信息 直接带到了 标签里面。当然   这仅仅只是生成在了html标签里面。其实  我们现在还不能完成前台的验证。我们要真的能自动在前台验证的话   需要引入一些 微软 提供的js文件。  jquery.validate.js jquery.validate.unobtrusive.js  看名字就知道   引用之前 还需引用jquery 文件。
    在此 前台验证 效果已经ok了。那仅仅 验证了 也还是不够的。起码也得有个 提示信息吧。 @Html.ValidationMessageFor(t => t.UserName) 自动输出 验证不通过的 信息提示。
    总结下使用MVC中的 特性来验证：
    第一、需要在后台的模型类 里面加上特性：如 [Required(ErrorMessage = "用户名不能为空")] public string UserName { get; set; }  （这里仅仅完成了后台验证）
    第二、需要在前台引入两个js文件 jquery.validate.js jquery.validate.unobtrusive.js （这里完成了前台验证）
    第三、在View文件中 生成控件 和验证提示信息。 @Html.TextBoxFor(t => t.UserName)//生成控件 @Html.ValidationMessageFor(t => t.UserName)//验证提示消息 
    效果图：   
    演示地址：http://blog.haojima.net/UserManage/Regis   
    注册和登录中最重要的 获取激活码、激活和数据验证都已经分析完了，那么下面就简单的说下注册、登录和重置密码吧。
注册
     首先关于注册信息包含：用户名、密码、昵称、邮箱。
     用户名：必填非空非重复，主要用来验证登录 和url中的链接。如：http://blog.haojima.net/zhaopei/1.html   中的 zhaopei。
     密码：必填非空，主要用来验证登录。
     昵称：非必填，主要用来友好显示在你的个人主页、方便别人记住你。如果是空，则用 用户名替代。
     邮箱：必填非空非重复，主要用来 注册的时候验证激活、重置密码的时候验证激活 和 评论邮件通知、站内消息通知（评论邮件通知 站内消息通知 功能暂未完成）   
     效果图：
登录
     1.如果登录成功。保存登录用户信息到session。
     2.如果勾选了“自动登录” 则保存 用户信息到 客户端 cookie，下次取session 时如果 session 为null  在看cookie是否有 有效用户信息。
     在这里 我还在数据库里面 加了个 “IsLock” 是否被锁定。如果 检测到 发布恶意  或违法内容 可以用来 锁定用户。使之不能登录。
     效果图：
重置密码
      重置密码，也就是修改密码。
      需要用到的字段：邮箱、新密码
      发送验证码到邮箱，然后判断输入的验证码是否正确。如果正确 则把密码修改成新密码。
      效果图：
总结
        这里主要是分析介绍了下 博客用户的 注册、登录和密码重置。其主要的共用模块功能有 获取激活码、触发激活 和 数据验证。
        注册流程：填写注册信息-> 验证信息-> 邮件验证-> 注册成功
        登录流程：填写登录信息-> 数据库查询-> 
                      1.锁定-> 发送邮箱激活码-> 激活 ->登录成功
                      2.未锁定->登录成功

        演示地址：http://blog.haojima.net/UserManage/Regis  （界面丑是丑了点，后期再美化）
        如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。 当然您还可以加入QQ群:讨论。
        如果您有更好的处理方式，希望不要吝啬赐教。
        一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
        本文链接：http://www.cnblogs.com/zhaopei/p/4770340.html
        开源地址：http://git.oschina.net/zhaopeiym/Hi-Blogs

 
article  60
title: 一步步开发自己的博客 .NET版（1、基本显示）
body: 
前言   

      我们每个猿都有一个搭建自己独立博客的梦，我也不例外。以前想 现在想 以后也想。之所以一直迟迟没有着手，是因为难以跨出第一步。每次心里想着，等我以后技术好了再说，然后就没有然后了。以前用过wordpress，虽然插件很多，不过有时候想改改自己想要的效果很难，因为 我压根就不会php。也看过.net的一些开源博客，代码量多，看得头晕，没那个耐心。
      再说，别人的始终是别人的。得鱼不如得渔。与其花时间去研究php还不如自己写个.net版的。有人说博客园已经很好了啊，我承认确实，而且还可以后台定制自己想要的样式和js。不过始终还是不如自己开发的来得随心所欲。最重要自己开发还可以当作练手 对一个网站的各环节  做一次练习，用以发现自己的不足，并加以提升。那我以后的博客写哪里呢？当然还是会继续发博客园，谁叫这里人气旺呢。
    这次开发的博客主要功能或特点：    第一：可以兼容各终端，特别是手机端。    第二：到时会用到大量html5，炫啊。    第三：导入博客园的精华文章，并做分类。（不要封我）    第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

关于域名和空间
      在以前我们学C#的想要搭一个免费的博客，要不只能用国外的免费空间要么在linux下用php。用起来都是各种坑，网速各种卡。然后，现在我们学C#的时代来了，这里要感谢阿里云（免费主机）。当然域名还是要自己买的。万网 和 新网 可以对比下  哪里便宜买哪里，都可以用。（注意：最好买 .com .net .cc .org 因为有些域名不能在阿里备案）。买好域名之后 然后就是备案了，备案也没什么复杂的，阿里自动备案。中间除了 找阿里 要一块免费的布 照个相 寄过去，就是等了，其他的什么也不用做。大概半个月的样子吧。建议  买域名的时候最好一次性买久一点，不然后期再续费要比第一次买贵。（如果您实在不想花这个钱，这个我最后给您支个招吧，你申请好免费的主机后，你把主机ip给我，我免费给你二级域名。谁叫我是活雷锋）
开发环境
      域名和主机都搞定以后，就开始选择开发环境了。我选的是 vs2013 mvc4 ef6.0 mssql   。
博客迁移
      然后就是博客迁移，之前也老想着搭建博客，可一直没有行动。这就是从0到1 的难。只要你走出了第一步 后面就 顺畅得多了。那么 我们搭博客 没有测试数据 总还是感觉没什么动力。所以，我就写了个程序，把我在博客园发表的文章扒过去。
      那么我们需要哪些数据呢？现在大概想到的有：博客正文、tag标签、文章分类、创建时间、博客标题
      好了，那我们就正式开始扒吧。（可以参考我以前的博客备份小工具3）
      首先是从/mvc/blog/sidecolumn.aspx页面取得 文章分类。然后根据 每个类型 的链接 取得这个类型下的所有文章。然后在取正文的时候发现 文章所属tag标签和分类是异步的到页面的， http://www.cnblogs.com/mvc/blog/CategoriesTags.aspx?blogApp=用户名&postId=文章id。（也许博客园有api，我也没去看没去找。）
1.首先建一个实体数据模型
我这里采用的是 model first(之前搞错概念了,谢谢园友指正) 。这里要说明的是 tag标签和文章是多对多的关系，文章类型和文章也是多对多的关系。

2.然后根据模型生成数据库
       个人觉得这里非常爽，自动帮我建好了 主外键  和索引，免除了我们自己手动去在数据库里面建。
3.从博客园扒数据
       模型和数据库建好了，那么我们现在就开始迁移吧~下面是全部代码，其中有存数据库的部分可以自己改改。


/// <summary>
        /// 根据用户导入cnblog数据
        /// </summary>
        /// <param name="userName"></param>
        /// <returns></returns>
        public string Import(string userName, string iszf = "false")
        {
            int blosNumber = 0;
            JavaScriptSerializer jss = new JavaScriptSerializer();
            string url = "http://www.cnblogs.com/" + userName + @"/mvc/blog/sidecolumn.aspx";
            HtmlAgilityPack.HtmlWeb htmlweb = new HtmlAgilityPack.HtmlWeb();
            var docment = htmlweb.Load(url);
            string userid = GetCnblogUserId(userName);
            var liS = docment.DocumentNode.SelectNodes("//*[@id='sidebar_categories']/div[1]/ul/li");
            foreach (var item in liS)
            {
                var tXPath = item.XPath;
                var href = item.SelectSingleNode(tXPath + "/a").Attributes["href"].Value;
                var blogtype = htmlweb.Load(href);
                //var entrylistItem = blogtype.DocumentNode.SelectNodes("//*[@id='mainContent']/div/div[2]/div[@class='entrylistItem']");
                var entrylistItem = blogtype.DocumentNode.SelectNodes("//div[@class='entrylistItem']");
                if (null == entrylistItem)//做兼容
                    entrylistItem = blogtype.DocumentNode.SelectNodes("//div[@class='post post-list-item']"); //    
                if (null == entrylistItem)
                {
                    continue;
                }
                foreach (var typeitem in entrylistItem)
                {
                    var typeitemXPath = typeitem.XPath;
                    var typeitemhrefObj = typeitem.SelectSingleNode(typeitemXPath + "/div/a");
                    if (null == typeitemhrefObj) //做兼容
                        typeitemhrefObj = typeitem.SelectSingleNode(typeitemXPath + "/h2/a");
                    var typeitemhref = typeitemhrefObj.Attributes["href"].Value;
                    if (IsAreBlog(typeitemhref))
                        continue;//说明这篇文章已经备份过了的
                    var bloghtml = htmlweb.Load(typeitemhref);
                    var blogcontextobj = bloghtml.DocumentNode.SelectSingleNode("//*[@id='cnblogs_post_body']");//.InnerHtml;
                    if (blogcontextobj == null) continue;//有可能是加密文章
                    var blogcontext = blogcontextobj.InnerHtml;
                    var blogtitle = bloghtml.DocumentNode.SelectSingleNode("//*[@id='cb_post_title_url']").InnerText;
                    var blogurl = bloghtml.DocumentNode.SelectSingleNode("//*[@id='cb_post_title_url']").Attributes["href"].Value;
                    var blogtypetagurl = "http://www.cnblogs.com/mvc/blog/CategoriesTags.aspx?blogApp=" + userName + "&blogId=" + userid + "    =" +
                        typeitemhref.Substring(typeitemhref.LastIndexOf('/') + 1, typeitemhref.LastIndexOf('.') - typeitemhref.LastIndexOf('/') - 1);
                    var blogtag = Blogs.Common.Helper.MyHtmlHelper.GetRequest(blogtypetagurl);
                    var jsonobj = jss.Deserialize<Dictionary<string, string>>(blogtag);
                    if (null == jsonobj)
                        continue;//如果没有 则返回  (这里只能去 数字.html  不能取那种自定义的url)
                    var tagSplit = jsonobj["Tags"].Split(',');
                    var blogtagid = new List<int>();
                    for (int i = 0; i < tagSplit.Length; i++)
                    {
                        if (tagSplit[i].Length >= 1 && tagSplit[i].LastIndexOf('<') >= 1)
                        {
                            var blogtagname = tagSplit[i].Substring(tagSplit[i].IndexOf('>') + 1, tagSplit[i].LastIndexOf('<') - tagSplit[i].IndexOf('>') - 1);
                            blogtagid.Add(this.GetTagId(blogtagname, userName));
                        }
                    }
                    var categoriesSplit = jsonobj["Categories"].Split(',');
                    var blogtypeid = new List<int>();
                    for (int i = 0; i < categoriesSplit.Length; i++)
                    {
                        if (categoriesSplit[i].Length >= 1 && categoriesSplit[i].LastIndexOf('<') >= 1)
                        {
                            var blogtypename = categoriesSplit[i].Substring(categoriesSplit[i].IndexOf('>') + 1, categoriesSplit[i].LastIndexOf('<') - categoriesSplit[i].IndexOf('>') - 1);
                            blogtypeid.Add(this.GetTypeId(blogtypename, userName));
                        }
                    }
                    var blogtimeobj = bloghtml.DocumentNode.SelectSingleNode("//*[@id='post-date']");
                    var blogtime = "";
                    if (null != blogtimeobj)
                        blogtime = blogtimeobj.InnerText;


                    BlogsBLL blog = new BlogsBLL();
                    var myBlogTags = new BlogTagsBLL().GetList(t => blogtagid.Contains(t.Id), isAsNoTracking: false).ToList();//.ToList();                                        

                    var myBlogTypes = new BLL.BlogTypesBLL().GetList(t => blogtypeid.Contains(t.Id), isAsNoTracking: false).ToList();//.ToList();
                    try
                    {
                        var modelMyBlogs = new ModelDB.Blogs()
                        {
                            BlogContent = blogcontext,
                            BlogCreateTime = blogtime,
                            BlogTitle = blogtitle,
                            BlogUrl = blogurl,
                            IsDel = false,
                            BlogTags = myBlogTags,
                            BlogTypes = myBlogTypes,
                            UsersId = GetUserId(userName),
                            BlogForUrl = blogurl,
                            IsForwarding = iszf == "checked"
                        };
                        blog.Add(modelMyBlogs);
                        blog.save();
                        blosNumber++;
                    }
                    catch (Exception)
                    {
                        throw;
                    }
                }
            }
            if (blosNumber > 0)
                return "成功导入" + blosNumber + "篇Blog";
            return "ok";
        }

        private int GetTagId(string tagname, string userName)
        {
            BlogTagsBLL blogtag = new BlogTagsBLL();
            try
            {
                var blogtagmode = blogtag.GetList(t => t.TagName == tagname);
                if (blogtagmode.Count() >= 1)
                    return blogtagmode.FirstOrDefault().Id;
                else
                {
                    blogtag.Add(new ModelDB.BlogTags()
                    {
                        TagName = tagname,
                        IsDel = false,
                        UsersId = GetUserId(userName)
                    });
                    blogtag.save();
                    return GetTagId(tagname, userName);
                }
            }
            catch (Exception)
            {
                return -1;
            }
        }


        private int GetTypeId(string typename, string userName)
        {
            BlogTypesBLL blogtype = new BlogTypesBLL();
            var blogtagmode = blogtype.GetList(t => t.TypeName == typename);
            if (blogtagmode.Count() >= 1)
                return blogtagmode.FirstOrDefault().Id;
            else
            {
                blogtype.Add(new ModelDB.BlogTypes()
                {
                    TypeName = typename,
                    CreateTime = DateTime.Now,
                    IsDel = false,
                    UsersId = GetUserId(userName)
                });
                blogtype.save();
                return GetTypeId(typename, userName);
            }
        }

        /// <summary>
        /// 获取haojima用户id
        /// </summary>
        /// <param name="userName"></param>
        /// <returns></returns>
        private int GetUserId(string userName)
        {
            BlogUsersBLL user = new BlogUsersBLL();
            var blogtagmode = user.GetList(t => t.UserName == userName);
            if (blogtagmode.Count() >= 1)
                return blogtagmode.FirstOrDefault().Id;
            else
            {
                user.Add(new ModelDB.BlogUsers()
                {
                    UserName = userName,
                    IsDel = false,
                    UserPass = "admin",
                    UserNickname = userName
                });
                user.save();
                return GetUserId(userName);
            }
        }

        /// <summary>
        /// 检查 这个 url地址 是否被添加过
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private bool IsAreBlog(string url)
        {
            BLL.BlogsBLL blog = new BLL.BlogsBLL();
            var blogs = blog.GetList(t => t.BlogUrl == url);
            return blogs.Count() >= 1;
        }

        /// <summary>
        /// 获取cnblog用户id
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        private string GetCnblogUserId(string url)
        {
            HtmlAgilityPack.HtmlWeb htmlweb = new HtmlAgilityPack.HtmlWeb();
            var docment = htmlweb.Load("http://www.cnblogs.com/" + url);
            var list = docment.DocumentNode.SelectNodes("//link[@rel='stylesheet']");
            foreach (var item in list)
            {
                if (null != item.Attributes && item.Attributes.Contains("href"))
                {
                    var href = item.Attributes["href"].Value;
                    href = href.Substring(href.LastIndexOf("/") + 1, href.IndexOf(".") - href.LastIndexOf("/") - 1);
                    int userid = -1;
                    if (int.TryParse(href, out userid))
                        return userid.ToString();
                }
            }
            return "";
        }

View Code
 
页面布局
      关于页面布局 ，怎样简单怎样来。我是分成了 头、尾、中间。中间二八分。这个不重要，现在暂时这么遭。以后再考虑 多终端的兼容。

数据加载
       现在数据都已经迁移过来的，需要展示在我们自己搭建的博客，我想对于大家来书应该没什么难度。从学编程开始，老师就教我们 增删改查。只是美与丑的问题。
       这里有一点要注意，因为正文内容保存到数据库的都是html代码，而我们要在首页展示文章列表只显示小部分内容，那怎么截取字符串呢？你不能保证刚好是在html标签结尾后截取啊。我这里用到了HtmlAgilityPack取InnerText 的属性。就像jqeruy中 .html() 和 .text()区别，如果截图断了html标签 显示 将会很混乱。       
最后总结
      这个博客我也才刚开始做，现有也仅仅只是实现了博客的展示功能，连分页都还没有去实现。所以本系列博客更新会比较慢。我也需要边做边学边更新，工作中还没用过MVC。
到最后等我做完了，我会放git上开源，到时候大家有兴趣的可以一起来完善和定制自己想要的效果。
       说了这么多来张效果图吧。
       
     

如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。 当然您还可以加入QQ群:讨论。
演示地址：http://blog.haojima.net/
原文链接：http://www.cnblogs.com/zhaopei/p/4737958.html 
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
开源地址：http://git.oschina.net/zhaopeiym/Hi-Blogs

 
article  61
title: 一步步开发自己的博客  .NET版（4、文章发布功能）百度编辑器
body: 
前言 

这次开发的博客主要功能或特点：
第一：可以兼容各终端，特别是手机端。
第二：到时会用到大量html5，炫啊。
第三：导入博客园的精华文章，并做分类。（不要封我）
第四：做个插件，任何网站上的技术文章都可以转发收藏 到本博客。

所以打算写个系类：《一步步搭建自己的博客》

一步步开发自己的博客  .NET版（1、页面布局、blog迁移、数据加载）
一步步开发自己的博客  .NET版（2、评论功能）
一步步开发自己的博客  .NET版（3、注册登录功能）
一步步开发自己的博客  .NET版（4、文章发布功能）
一步步开发自己的博客  .NET版（5、搜索功能）
一步步开发自己的博客  .NET版（6、手机端的兼容）

 
演示地址：http://blog.haojima.net/      群内共享源码：469075305 
 
博客做到这里 基本功能已经粗糙的完成了。注册、登录、发布、评论、博客迁移该有的都有了。这段时间内，差不多都是一个功能一个星期。说是一个星期，其实就周末两天而已。鬼还没天亮 就起来折腾，一做就是两天 不动。说实话，真心累。不过欣慰的是，基本功能都出来了。
今天记录下 文章发布功能的实现过程。
发布，首先得有个富文本编辑器。其它的编辑器 我没了解过。听说 百度的还不错，就 稍微的研究了下。
百度编辑器
 官网：http://ueditor.baidu.com/website/ 下载地址：http://ueditor.baidu.com/website/download.html 
我这里用的是 开发版 
使用到自己的项目里面还是非常的简单，不过这里需要注意的几点。以下是问题记录。
1.问题：
首先 我用的.net 4.5，把UBuilder直接放项目里面，运行报错。没细看报的什么错。
解决方法：我直接把 目录net->Bin文件夹   删了。（可能是版本问题）
2.问题：
我们从http://ueditor.baidu.com/website/umeditor.html 官网演示地址可以看到 有如下 API。

我们通过 getContent()获得 UBuilder 里的html内容 毫无问题。 通过setContent 加载内容时提示编辑器为空。
解决方法：当页面加载完成时 赋值。

//页面加载完成时
    $(function () {
        var html = $(".hidden_data").val();
        // 自定义的编辑器配置项,此处定义的配置项将覆盖editor_config.js中的同名配置
        var editorOption = {       
            autoClearinitialContent: true,
            elementPathEnabled: true
        };
        var editor_a = new baidu.editor.ui.Editor(editorOption);
        editor_a.render('editor');
        editor_a.ready(function () {
            editor_a.setContent(html,false);  //赋值给UEditor
        });
    });

3.问题：
发布后的代码样式  无高亮。
解决方法：页面加载完成是 执行高亮插件。

 $(function () {
        SyntaxHighlighter.highlight();
    });

4.问题：
图片上传显示失败。（原因是改变了路径）
解决方法：目录net->config.json 打开配置文件。 "imageUrlPrefix": "/ueditor/net/", /* 图片访问路径前缀 */  改为UBuilder 放到项目的绝对路径 如我的是放到了 文件夹Plug下 "imageUrlPrefix": "/Plug/ueditor/net/", /* 图片访问路径前缀 */ 
5.问题：
这也不算问题，就是 我们不是专业的视频网站，一般不允许传视屏。
解决方法：可以配置 上传文件的 格式 和大小。


      基本上 我就做了这些处理。 这里还有个存在的问题 ：就是我们在UBuilder 里面 复制过去的代码 会自动给我去除div和样式。所以，像我直接迁移的博客园文章内容，如果用UBuilder 打开 在保存的话  代码就没有了高亮 格式和乱了。（这点比较坑）。
标签
我们在发布文章的时候，经常是需要 标签和分类的。所在 这里最基本的功能  不能省。 
以图为例。输入标签有两种方式。第一：直接在文本框内输入 以逗号 分割。第二种：勾选 复选框。
看似简单的功能，其实不简单。
首先 我们可以通过 勾选 复选框 来选择 标签，那么 我们就可以通过 取消 复选框 来 删除 已经选好的标签。那怎么实现呢？
选中的时候，先判断 文本框内的最好一个字符是不是 , 如果不是    我们在 选中的时候 先 添加 逗号 然后 累加 我们选中的 复选框额值。
取消选中的时候，我们先 用逗号 分割 文本框 内的字符串，然后 如果有 我们要取消的 标签 则删除。
说了这么大堆  其实代码实现也不多。

//点击tag标签时
function clik_tag(obj) {
    if ($(obj).is(":checked")) { //如果选中
        var texttag = $(".text_tag");
        if (texttag.val().length > 1 && texttag.val()[texttag.val().length - 1] != ",") {
            texttag.val(texttag.val() + ",");
        }
        var text_tag = texttag.val() + $(obj).val();
        texttag.val(text_tag + ",");
    }
    else { //如果取消选中
        var text_taglist = $(".text_tag").val().split(",");
        $(".text_tag").val("");
        text_taglist.forEach(function (value, index) {
            if ($(obj).val() != value && value)
                $(".text_tag").val($(".text_tag").val() + value + ",");
        });
    }
}

 
这里还仅仅只是 前台页面的显示。  我们在后台也要判断。 如果 这个标签 已经存在 这直接查询到 标签id  如果不存在 先创建 标签 然后去标签id 和blog 关联。
我们在前台 做点小的动作，分割 文本框内的所有标签，如果存在 下面的 可选 标签 则为旧的标签 否则 是新的标签。我们在传入后台的时候 先进行下分类。这样就免去了 我们在后台处理。（我的原则是，非安全性问题，能在前台处理 就在前台处理。）     

//选择的标签
var oldtag = "", newtag = "";
var text_taglist = $(".text_tag").val().split(",");

var chk_taglsit = new Array();
$(".chk_tag").each(function () {
    chk_taglsit[chk_taglsit.length] = $(this).val();
});

text_taglist.forEach(function (value, index) {
    if ($.inArray(value, chk_taglsit) >= 0) {
        oldtag += value + ",";
    }
    else {
        newtag += value + ",";
    }
});

 
文章分类   
文章分类 我们就没有做 标签那么灵活了。标签  可以随意贴上去。但是 分类 一般都是先 固定好。就像 分类：我们都是中国人。标签：我们是程序员 ，明天可能又是测试员 大后天又能是美工、、没办法 所以  贴标签  就要灵活多了。

逻辑不复杂 操作当然也要简单。不就 是修改个值嘛，干嘛搞的那么 复杂。有的   实现方式需要几个页面 跳来跳去的。 我的实现是 点击 修改 分类 直接变成 可编辑状态。编辑完成后 光标点击任意地方 就可以修改完成。 这样   是不是 方便多了。
首先，我们点击编辑的时候  用一个 input 的 text 控件 替换原来的 a标签 ，并把值也传过来。当 text 失去交点时   直接后台保存。并还原 为 a 标签状态。
这里 需要注意 重复点击 编辑 不能 让 再次替换。需要判断下。   


//新增类型
function addnewtype(obj) {
    var strhtml = "<div class='newtype'><input type='text' class='text_newtype' onblur='newtype_onblur(this);'/></div>";
    var chi = $(obj).parents(".divtitle_chi");
    if (chi.find(".newtype").length <= 0) {
        chi.append(strhtml).find(".text_newtype").focus();
    }
}
function newtype_onblur(obj) {
    var value = $(obj).val();
    if (!value) {
        $(obj).parents(".newtype").remove();
        return;
    }
    $.post("@Url.RouteUrl("ControllerAction", new { controller = "Admin", action = "NewAddType" })",
        { "newtypename": value }, function (data) {
            if (ShowAjaxResult(data)) {

            }
        });
    var newhtml = "<a>" + value + "</a>";
    $(obj).parents(".newtype").removeClass("newtype").addClass("divtitle_chi").html(newhtml);
}

//修改 文章 类型
function edittype(obj) {
    $(obj).parents(".divtitle_chi").find(".text_newtype").unbind("blur");
    if (!$(obj).next().hasClass("newtype")) {
        var value = $(obj).next().html().trim();//取得 文章类型 名称
        var typeid = $(obj).find(".hid_typeid").val();  //取得 文章类型id  onblur='edittype_onblur(this);'
        var strhtml = "<div style='float:left' class='newtype'><input type='text' class='text_newtype' value='" + value + "' keyvalue='" + value + "' keyid='" + typeid + "' /></div>";
        $(obj).next().css("display", "none"); // 隐藏原来显示的文章类型
        $(obj).after(strhtml).next().find(".text_newtype").focus().bind("blur", function () {
            edittype_onblur($(obj).parents(".divtitle_chi").find(".text_newtype"));
        });  //把 修改的文本元素添加 并获得焦点
    }
    else {
        edittype_onblur($(obj).after(strhtml).next().find(".text_newtype"));
    }
}
//鼠标移到目标的上方
function editover(obj) {
    $(obj).parents(".divtitle_chi").find(".text_newtype").unbind("blur");
    //$(".testmess").html("unbind");
}
//鼠标在目标的上方移动
function editmove(obj) {
    $(obj).parents(".divtitle_chi").find(".text_newtype").unbind("blur");
}
//鼠标移出目标的上方
function editout(obj) {
    //$(".testmess").html("bind");
    $(obj).parents(".divtitle_chi").find(".text_newtype").unbind("blur");
    $(obj).parents(".divtitle_chi").find(".text_newtype").bind("blur", function () {
        // $(".testmess").html("bind");
        edittype_onblur($(obj).parents(".divtitle_chi").find(".text_newtype"));
    });
}

function edittype_onblur(obj) {
    var value = $(obj).val().trim(); //新的文章类型
    var typeid = $(obj).attr("keyid").trim();//类型ID
    var oldvalue = $(obj).attr("keyvalue").trim();//旧的文章类型
    if (!value || !typeid || value == oldvalue) { //1.如果值为空 2.如果类型id为空 3.如果没有修改 则直接返回
        $(obj).parents(".newtype").next().css("display", "");
        $(obj).parents(".newtype").remove();
        return;
    }
    $.post("@Url.RouteUrl("ControllerAction", new { controller = "Admin", action = "EditType" })",
    { "typename": value, "typeid": typeid }, function (data) {
        if (ShowAjaxResult(data)) {
            $(obj).parents(".newtype").next().remove();
            var newhtml = "<a>" + value + "</a>";
            var newtype = $(obj).parents(".newtype")
            newtype.after(newhtml);
            newtype.remove();
        }
        else {
            $(obj).parents(".newtype").next().css("display", "");
            $(obj).parents(".newtype").remove();
        }
    });

View Code
最后看看效果图：

总结
关于发布，其实要说的东西也不多。无非就是 用个富文本编辑器   编写好内容   然后 更新到数据库。然后 在更新的 时候  需要填写 标签  和 选择分类。
这里还有一点 需要主要。asp.net 默认  是不允许 提交 标签文本到服务器的。所以  我们这里  需要关闭 默认的 安全 验证。
1.后台 访问的 action 方法上  打上   [ValidateInput(false)] 的特性标签。
2.在配置文件 配置（我用的是MVC是4.0 貌似必须要在配置文件配置）

<system.web >
<httpRuntime requestValidationMode="2.0" / >
</system.web >         


演示地址：http://blog.haojima.net/Admin/Release/7  (需要登录状态 才能发布)
如果您对本篇文章感兴趣，那就麻烦您点个赞，您的鼓励将是我的动力。 当然您还可以加入QQ群:讨论。
如果您有更好的处理方式，希望不要吝啬赐教。
一步步开发自己的博客 .NET版系列：http://www.cnblogs.com/zhaopei/tag/Hi-Blogs/
本文链接：http://www.cnblogs.com/zhaopei/p/4783814.html
开源地址：http://git.oschina.net/zhaopeiym/Hi-Blogs

 
article  62
title: 触发器
body: 
目录
一、DML触发器
二、INSTEAD_OF触发器
三、系统触发器
四、删除触发器  修改触发器状态 关闭打开

--说明
--1.事件发生之前（BEFORE）事件发生之后(AFTER)
--2.触发条件子句WHEN
--3.语句级(STATEMENT)触发器和行级(ROW)触发器
--3.1 STATEMENT：是指当某触发事件发生时，该触发器只执行一次；
--3.2 ROW：是指当某触发事件发生时，对受到该操作影响的每一行数据，触发器都单独执行一次。
--4.在触发器的执行部分只能用DML语句（SELECT、INSERT、UPDATE、DELETE），不能使用DDL语句（CREATE、ALTER、DROP）。

 
一、DML触发器

--创建一个和emp表结构 相同的空表 记录删除日志
create table emp_del as select * from emp where 1=2;
--1.创建DML触发器[行级 删除 触发器]
create or replace trigger tr_del_emp
  before delete --指定为删除是触发
on emp
  for each row --说明 行级触发
begin
  insert into emp_del (deptno, empno) values (:old.deptno, :old.empno);
end;
--
delete emp t where t.empno='7654';
--注意：:NEW 修饰符访问操作完成后列的值     :OLD 修饰符访问操作完成前列的值


--2.限制DML触发器
create or replace trigger tr_dept_time
  before insert or delete or update on dept
begin
  if (true) then--这里可以写自定义条件
    RAISE_APPLICATION_ERROR(-20001, TO_CHAR(sysdate,'DAY')||'不能修改dept表');  --自定义异常消息
  end if;
end;

delete dept t where t.deptno='10';


--3修改字段ename, job 和删除 特定条件 DML触发器
CREATE OR REPLACE TRIGGER tr_emp_sal_comm
  BEFORE UPDATE OF ename, job OR DELETE ON emp  --修改字段ename, job 和删除 触发器
  FOR EACH ROW
  when (old.empno = '7499') --when 子句中old 和new 不能加":",在PL/SQL块语句中 必须加上:new :old 。
BEGIN
  CASE
    WHEN UPDATING('ename') THEN
      IF :new.ename != :old.ename THEN
        /*:new.ename != :old.ename  这里可以用新值和旧值做逻辑判断 注意值为空时 条件恒为false*/
        RAISE_APPLICATION_ERROR(-20001, 'enpno为7369 的ename 不能修改');
      elsif :new.ename = :old.ename THEN
        RAISE_APPLICATION_ERROR(-20001, 'ename 不能修改');
      else
        dbms_output.put_line(:new.ename || ' ' || :old.ename);
        RAISE_APPLICATION_ERROR(-20001, 'ename 其他情况不能修改');
      END IF;
    WHEN UPDATING('job') THEN
      IF :NEW.job != :old.job THEN
        RAISE_APPLICATION_ERROR(-20002, 'enpno为7369 的job 不能修改');
      END IF;
    WHEN DELETING THEN
      RAISE_APPLICATION_ERROR(-20003, 'enpno为7369 不能删除');
  END CASE;
END;

--7499  7566
select * from emp t where t.empno = 7499;
delete emp t where t.empno = 7499;
update emp t set t.job='12223' where t.empno='7499';
update emp t set t.ename='123' where t.empno='7499';

二、INSTEAD_OF触发器

--创建视图
create or replace view my_ceshi_view 
as
 select t.empno  from emp t group by t.empno;
--创建INSTEAD_OF触发器 删除 
create or replace trigger del_ceshi_view
  instead of delete on my_ceshi_view
  for each row
begin
  delete from emp where empno = :old.empno;
end;

--
delete my_ceshi_view t where  t.EMPNO='7698';

三、系统触发器

--创建用于记录事件用的表
CREATE TABLE ddl_event
(crt_date timestamp PRIMARY KEY,
 event_name VARCHAR2(20), 
 user_name VARCHAR2(10),
 obj_type VARCHAR2(20),
 obj_name VARCHAR2(20));

--创建系统事件DDL触发器
CREATE OR REPLACE TRIGGER tr_ddl
  AFTER DDL ON SCHEMA
BEGIN
  INSERT INTO ddl_event
  VALUES
    (systimestamp,
     ora_sysevent,
     ora_login_user,
     ora_dict_obj_type,
     ora_dict_obj_name);
END tr_ddl;

create table emp_bak as select * from emp;
select * from ddl_event;

四、删除触发器  修改触发器状态 关闭打开

--删除触发器  修改触发器状态 关闭打开
DROP TRIGGER trigger_name;
ALTER TRIGGER trigger_name [DISABLE | ENABLE ]; --有效状态(ENABLE) --无效状态(DISABLE)
ALTER TRIGGER tr_del_emp DISABLE ; 

 
article  63
title: 取存过和函数的返回值
body: 
目录
一、取函数的返回值
1.取函数的系统类型数据
2.取函数的自定义类型数据
3.取函数的自定义类型数据集合
二、取存储过程的返回值
1.取存过的系统类型数据
2.取存过的自定义类型数据
3.取存过的自定义类型数据集合
 
一、取函数的返回值
0.创建自定义类型

--自定义类型
create or replace type mytype as object
(
  str1 number,
  str2 varchar2(10)
);
--自定义类型集合
create or replace type  mytype_list as table of mytype;

 
1.取函数的系统类型数据

--1函数 返回字符串
create or replace function fun_ceshi1(num1 number, num2 number)
  return varchar2 as
  str1 varchar2(111);
begin
  str1 := '测试时。。。';
  return str1;
end;
--取值
select fun_ceshi1(1,1) from dual;

 
2.取函数的自定义类型数据

--2函数 返回自定义类型
create or replace function fun_ceshi2(num1 number, num2 number)
  return mytype as
  my mytype;
begin
 select mytype(ename1, ename2)
   into my
   from (select t.empno ename1, t.ename ename2 from emp t where rownum=1);
  return my;
end; 
--
select fun_ceshi2(1,1) from dual;

 
3.取函数的自定义类型数据集合

--3函数 返回自定义类型集合
create or replace function fun_ceshi3(num1 number, num2 number)
  return mytype_list as
  my mytype_list;
begin
 select mytype(ename1, ename2) BULK COLLECT
   into my
   from (select t.empno ename1, t.ename ename2 from emp t);
  return my;
end; 
--
select * from table(fun_ceshi3(1,1));

 
二、取存储过程的返回值
1.取存过的系统类型数据

--1存过 返回字符串
create or replace procedure pro_ceshi1(num1 number,
                                      num2 number,
                                      num3 out varchar2) as
begin
  select '字符串num' into num3 from dual;
end;
--调用
declare
  num3 varchar2(111);
begin
  pro_ceshi1(1, 1, num3);
 dbms_output.put_line(num3);
end;

 
2.取存过的自定义类型数据

--2存过 返回自定义类型
create or replace procedure pro_ceshi2(num1 number,
                                      num2 number,
                                      strType out mytype) as
begin
  select mytype(ename1, ename2)
   into strType
   from (select t.empno ename1, t.ename ename2 from emp t where rownum=1);
end;
--调用
declare
  strType mytype;
begin
  pro_ceshi2(1, 1, strType);
  dbms_output.put_line(strType.str1 || '  ' || strType.str2);
end;

 
3.取存过的自定义类型数据集合

--3存过 返回自定义类型集合
create or replace procedure pro_ceshi3(num1 number,
                                      num2 number,
                                      strType out mytype_list) as
begin
   select mytype(ename1, ename2) BULK COLLECT
   into strType
   from (select t.empno ename1, t.ename ename2 from emp t);
end;

--调用
declare
  strType mytype_list;
  cursor c_c is
    select * from table(strType);
begin
  pro_ceshi3(1, 1, strType);
  for v_r in c_c loop
    dbms_output.put_line(v_r.str1 || '  ' || v_r.str2);
  end loop;
end;

 
article  64
title: 使用EF取数据库返回的数据
body: 
目录
一、取oracle自定义函数返回的自定义类型。
 
一、取oracle自定义函数返回的自定义类型。
 1.首先创建一个函数返回自定义类型集合 

--1.建立自定义类型
CREATE OR REPLACE TYPE UT_BLOCKED_STATISTICS AS OBJECT
(
  TWO_DPT_CDE   VARCHAR2(11), --
  TWO_DPT_NME   VARCHAR2(111),
  THREE_DPT_CDE VARCHAR2(11),
  THREE_DPT_NME VARCHAR2(111),
  CASE_NUM      NUMBER,
  BLOCKED_NUM   NUMBER
)


--2.建立自己定义类型集合
CREATE OR REPLACE TYPE "UT_BLOCKED_STATISTICS_LIST" AS TABLE OF UT_BLOCKED_STATISTICS;


--3.创建自定义函数 返回自定义类型集合
--这里用到了Oracle8i 才有的特性 BULK COLLECT [批量插入]
create or replace function get_BLOCKED_STATISTICS(BEGINTIME IN DATE,
                                                  ENDTIME   IN DATE)
  RETURN UT_BLOCKED_STATISTICS_LIST as
  UT UT_BLOCKED_STATISTICS_LIST; --自定类型集合
BEGIN  
    select UT_BLOCKED_STATISTICS(two_dpt_cde,  --这里需要手动显示 对应自定义类型集合 UT_BLOCKED_STATISTICS_LIST 的字段
                                 two_dpt_nme,
                                 Three_dpt_cde,  
                                 Three_dpt_nme,
                                 CASE_NUM,  
                                 BLOCKED_NUM) BULK COLLECT
      into UT
      from (select two_dpt_cde, two_dpt_nme,Three_dpt_cde,Three_dpt_nme,CASE_NUM,BLOCKED_NUM from Mytable where ....); return UT; end;

 

--4.这里就可以使用table() 查询自定义函数返回的结果集  像查询表数据一样方便
select t.*  from table(get_BLOCKED_STATISTICS(to_date('...', 'yyyy-MM-dd HH24:mi:ss'),to_date(.. .))) t where ....

 
2. EF程序调用
首先创建一个class字段对应数据库的自定义类型UT_BLOCKED_STATISTICS 的模型类 BlockedStatistics

Context.Database.SqlQuery<BlockedStatistics>(strSql).ToList()
//strSql 拼接的sql查询字符串
//BlockedStatistics  创建的与自定义类型对应的class//使用的是 EntityFramework.dll v4.0

 
存过返回自定义类型，怎么在EF中取得返回的值还没搞定....
article  65
title: 关注博客分类
body: 
前端：



地址
 
备注


前端收集
 
 


叶小钗
 
http://www.cnblogs.com/yexiaochai/ 


司徒正美
 
 http://www.cnblogs.com/rubylouvre/


汤姆大叔
 
 深入理解JavaScript系列


Barret/李靖
 
 http://www.cnblogs.com/hustskyking/category/463291.html


当耐特/张磊
 

 http://www.cnblogs.com/iamzhanglei/  [html5]



王福朋
 
《css知多少》



HTML5:
http://www.cnblogs.com/bigbearbb/category/655422.html
http://www.cnblogs.com/iamzhanglei/  
 
 NodeJS



大熊君{{bb}}/王子悦 
大熊君聊聊NodeJS系列



 大熊君大话设计模式JavaScript



后台



网址
 
备注


顾磊(kyo-yo)
 
微软企业库5.0 学习之路系列文章索引


zhuweisky
 
语音视频通信框架



 ASP.NET MVC



Liam Wang/王亮
ASP.NET MVC 小牛 大牛之路


 
 



DBA



 
潇湘隐者
 
 http://www.cnblogs.com/kerrycode/p/3256266.html
 


 
yonghu86
 
 ORACLE PL/SQL编程详解  【强烈推荐】
 


 
CareySon
 
SQL Server文章目录
 



算法



一线码农 
算法系列15天速成          





算法洗脑系列（8篇）



wcf



一线码农
wcf系列学习5天速成


Learning hard
跟我一起学WCF


李林峰的园子
 无废话WCF系列教程



设计模式




Learning hard

C#设计模式


 
 



UML 2
 
webapi1  2  webapi异步3 webapi蒋大4  5 6 7 8 webapi缓存9
code first1 
 
ef领域驱动
 
https://ring0.me/
 
http://www.cnblogs.com/HJL-Blog/p/4459245.html【园友整理】
 
http://www.cnblogs.com/wenxinghaha/tag/.net%20%20solr/   sphinx.net
 
lock（多线程锁）
http://www.cnblogs.com/leotsai/p/lock-string-trap.html（在多线程编程中lock（string）{...}隐藏的机关）
http://www.cnblogs.com/baihmpgy/archive/2011/07/13/2105018.html（确保真正的线程安全——微软为什么不提供线程安全库）
 
Web Deploy
http://www.cnblogs.com/potential/p/3751426.html
http://edi.wang/post/2013/12/21/iis-webdeploy-on-ws2008r2
 
备忘 
常用网站
常用SQL[ORACLE]
常用[js,css,jquery,html]
article  66
title: 函数和存过的创建调用
body: 
函数[in out 参数]

--函数[in out 参数]
create or replace function get_test(m_id in number, str1 out varchar2) --参数不需要类型长度
  return varchar2 is str2 varchar2(10); --变量需要类型长度
begin
  select t.ename, t.job
    into str1, str2
    from scott.emp t
   where t.empno = m_id;
  return str2;
end get_test;

--调用函数[位置表示法]
declare
  s1 varchar2(10);
  s2 varchar2(10);
  s3 number(30) default 7521;  --default 默认值
begin
  s3:=7566;
  s2 := get_test(s3, s1);--参数次序
  dbms_output.put_line(s1 || '  ' || s2);
end;

--调用函数 [名称表示法]
declare
  s1 varchar2(10);
  s2 varchar2(10);
begin
  s2 := get_test( str1=>s1,m_id=>7521);  --名称的对应关系，次序并不重要
  dbms_output.put_line(s1 || '  ' || s2);
end;

 存储过程1

--存储过程1

create or replace procedure get_test1(m_id in number, str1 out varchar2) --参数不需要类型长度
 is
begin
  select t.ename into str1 from scott.emp t where t.empno = m_id;
end get_test1;

--调用
declare
  s1 varchar2(100);
begin
  get_test1(7521, s1);
  dbms_output.put_line(s1);
end;

 存储过程2

create or replace procedure get_test2(m_id in number)
 is
  str1 varchar2(100);  --变量在is后面定义
begin
  select t.ename into str1 from scott.emp t where t.empno = m_id;
  dbms_output.put_line(str1);
end;
--sql窗口执行
begin
  get_test2(7521);
end;
--在命令窗口的执行
EXECUTE get_test2(7521);

 
article  67
title: 动态sql
body: 
目录
1.给动态语句传值(USING 子句)
2.从动态语句检索值(INTO子句)
3.动态调用存过 
4.将返回值传递到PL/SQL记录类型;同样也可用%rowtype变量
5.传递并检索值.INTO子句用在USING子句前
6.多行查询选项.对此选项用insert语句填充临时表
7.动态定义游标
 

--动态执行sql 包括ddl dml
--1.execute immediate  推荐使用 性能更优
--2.dbms_utility.exec_ddl_statement
begin
  execute immediate 'select * from scott.emp';
  execute immediate 'create table emp1121(id number,name varchar2(10),salary number )';
  dbms_utility.exec_ddl_statement('create table emp111(id number,name varchar2(10),salary number )');
end;

1.给动态语句传值(USING 子句)

--1.给动态语句传值(USING 子句)
declare
  l_depnam varchar2(20) := 'testing';
  l_loc    varchar2(10) := 'Dubai';
begin
  execute immediate 'insert into dept values   (:1, :2, :3)'
    using 50, l_depnam, l_loc;
  commit;
end;
select * from dept

 
2.从动态语句检索值(INTO子句)

--2.从动态语句检索值(INTO子句)
declare
  l_cnt varchar2(20);
begin
  execute immediate 'select count(1) from emp'
    into l_cnt;
  dbms_output.put_line(l_cnt);
end;

 
3.动态调用存过 

--创建存过
create or replace procedure get_rowcnt(l_tblnam varchar2,
                                       l_cnt    out number,
                                       l_status out varchar2) as
begin
  select t.empno into l_cnt from emp t where rownum = 1;
  l_cnt    := 3;
  l_status := 'OK';
end;

--3.动态调用存过  
declare
  l_routin varchar2(100) := 'get_rowcnt';
  l_tblnam varchar2(20) := 'emp';
  l_cnt    number;
  l_status varchar2(200);
begin
  execute immediate 'begin ' || l_routin || '(:2, :3, :4); end;'
    using in l_tblnam, out l_cnt, in out l_status;

  if l_status != 'OK' then
    dbms_output.put_line('error');
  end if;
end;

 
4.将返回值传递到PL/SQL记录类型;同样也可用%rowtype变量

--4.将返回值传递到PL/SQL记录类型;同样也可用%rowtype变量 
declare
  type empdtlrec is record(
    empno  number(4),
    ename  varchar2(20));
  empdtl empdtlrec;
begin  
  execute immediate ' select empno, ename from  emp where rownum=1'
    into empdtl;
  dbms_output.put_line(empdtl.empno);
end;

 
5.传递并检索值.INTO子句用在USING子句前

--5.传递并检索值.INTO子句用在USING子句前
declare
  l_dept pls_integer := 20;
  l_nam  varchar2(20);
  l_loc  varchar2(20);
begin
  execute immediate 'select dname, loc from dept where deptno = :1'
    into l_nam, l_loc
    using l_dept;
  dbms_output.put_line(l_nam);
end;

 
6.多行查询选项.对此选项用insert语句填充临时表

--6.多行查询选项.对此选项用insert语句填充临时表，
--用临时表进行进一步的处理,也可以用REF cursors纠正此缺憾.
create table temp
(
empno number,
ename varchar2(111)
);

declare
  l_sal pls_integer := 2000;
begin
  execute immediate 'insert into temp(empno, ename) ' ||
                    '           select empno, ename from emp ' ||
                    '           where   sal > :1'
    using l_sal;
  commit;
end;

select * from temp;

 
7.动态定义游标

--7.动态定义游标
declare
  msql    varchar2(111) := 'select * from emp';
  tbl_emp emp%rowtype;
  type cur_type is ref CURSOR;
  cur cur_type;
begin
  OPEN cur for msql; --打开动态定义的游标
  LOOP
    FETCH cur
      into tbl_emp; --循环赋值
    EXIT WHEN cur%NOTFOUND; --跳出条件
    dbms_output.put_line(tbl_emp.empno || '  ' || tbl_emp.ename); --打印
  END LOOP; 
end;

 
article  68
title: 各大招聘网站信息实时查询浏览
body: 
      最近听得较多的跳槽、面试之类的，相信很多园友也开始蠢蠢欲动了，有的甚至早已经开始了。最近我也在琢磨着换工作的事。说得俗套点，人在外面不就为了那么点工资么。现在找工作大部分都是通过在网上投简历，然后等电话 通知面试的。然，现在的招聘网站也是比较多。一个一个的在各大网站切换的流量招聘信息 实属麻烦。之前看到过一篇博文。《找工作神器，提取各大网站有效的招聘信息（前程无忧、智联招聘、猎聘网）》感觉这想法挺好的。把各大网站信息集中起来浏览，第一省了来回切换，第二还不容易重复投简历。本想拿来用用的，无奈没有提供源码下载，且是客户端版本。于是就只能自己动手，丰衣足食了~。(网站就是强大，可以大家一起分享●０●^_^)
     合并查询本来就是为了简单方便，所以也就没有弄很复杂了，一个页面搞定。如果同学们有什么好的想法，可以建议建议。
效果图：

就一个简单的关键字输入框、工作地点的选择和信息来源网站。
其实看上去很简单，实现起来也很简单。~~代码不多，难度也很小。很多时候需要的技术不是很多，想法更重要。
不想往下看的可以直接用用 演示地址 ,同学们求工作给推荐推荐，上海 浦东 .net。 私密我，或Q我。
 
第一、分析url
进入招聘网站的时候url大串大串的，我们需要用的的就三个。搜索关键字、地址和页码。
智联招聘：
http://sou.zhaopin.com/jobs/searchresult.ashx?jl=地址&kw=关键字&p=页码
jl=地址
kw=关键字
p=页码
然后地址的话 直接中文地址就ok了
猎聘网：
http://www.liepin.com/zhaopin/?key=关键字&dqs=地址&curPage=页码
key=关键字
dqs=地址
curPage=页码
地址有一个对应的编号
("北京", "010");("上海", "020");("广州", "050020");...等等  也是在猎聘网选择地址的地方右键 审查元素可以看到，如下：
前程无忧：
http://search.51job.com/jobsearch/search_result.php?jobarea=地址&keyword=关键字&curr_page=页码
jobarea=地址 [和猎聘一样的查找方法]
keyword=关键字
curr_page=页码
第二、用到了HtmlAgilityPack.DLL HTML解析组件
在之前我发过的 博客转发小工具 有提过HtmlAgilityPack。这里再简单的说说用法。

case ZhaopinType.猎聘网:
    var htmlWeb = new HtmlWeb();
    htmlWeb.OverrideEncoding = Encoding.GetEncoding("UTF-8");
    HtmlAgilityPack.HtmlDocument response = htmlWeb.Load(url);
    #region MyRegion
    var ulS = response.DocumentNode.SelectNodes("//*[@id='sojob']/div[2]/div/div/ul/li");
    foreach (var item in ulS)
    {
        var xpath = item.XPath;
        string titleName, infourl, company, city, date, salary, salary_em, source;
        titleName = item.SelectSingleNode(xpath + "/a").Attributes["title"].Value;
        infourl = item.SelectSingleNode(xpath + "/a").Attributes["href"].Value;
        company = item.SelectSingleNode(xpath + "/a/dl/dt[@class='company']").InnerText;
        city = item.SelectSingleNode(xpath + "/a/dl/dt[@class='city']/span").InnerText;
        date = item.SelectSingleNode(xpath + "/a/dl/dt[@class='date']/span").InnerText;
        salary = item.SelectSingleNode(xpath + "/a/dl/dt[@class='salary']/span").InnerText;
        salary_em = item.SelectSingleNode(xpath + "/a/dl/dt[@class='salary']/em").InnerText;
        source = "猎聘网";

        zpInfoList.Add(
            new ZhaopinInfo()
            {
                city = city,
                company = company,
                date = date,
                info_url = infourl,
                salary = salary,
                salary_em = salary_em,
                titleName = titleName,
                source = source
            });
    }
    #endregion
    break;

1.设置访问url页面的编码
 htmlWeb.OverrideEncoding = Encoding.GetEncoding("UTF-8");
设置编码为UTF-8,具体看对应页面采用的编码。
2.元素路径下的元素集合
var ulS = response.DocumentNode.SelectNodes("//*[@id='sojob']/div[2]/div/div/ul/li");
SelectNodes方法里面的这串字符串怎么来？

右键审查元素 Copy XPath 就ok了。不过如果js有动态修改document树的话 那么这个路径就不准了，需要自己微调下。
3、取标签的属性值 Attributes
如：取a标签的title值。
titleName = item.SelectSingleNode(xpath + "/a").Attributes["title"].Value;
4.取标签的中间的文本 InnerText
 company = item.SelectSingleNode(xpath + "/a/dl/dt[@class='company']").InnerText;
5.过滤选择特定的id 或 class
XPath 中 标签名后面加上中括号 和@ 如： "/a/dl/dt[@class='company']"
第三、浏览器滚动条的onscroll事件
js获取滚动条距离浏览器顶部,底部的高度,兼容ie和firefox
取窗口可视范围的高度[浏览器可见区域高度]

//取窗口可视范围的高度[浏览器可见区域高度]
        getClientHeight: function () {
            var clientHeight = 0;
            if (document.body.clientHeight && document.documentElement.clientHeight) {
                var clientHeight = (document.body.clientHeight < document.documentElement.clientHeight) ? document.body.clientHeight : document.documentElement.clientHeight;
            } else {
                var clientHeight = (document.body.clientHeight > document.documentElement.clientHeight) ? document.body.clientHeight : document.documentElement.clientHeight;
            }
            return clientHeight;
        }

取窗口滚动条高度[滚动条距离顶部的高度]

  getScrollTop: function () {
            var scrollTop = 0;
            if (document.documentElement && document.documentElement.scrollTop) {
                scrollTop = document.documentElement.scrollTop;
            } else if (document.body) {
                scrollTop = document.body.scrollTop;
            }
            return scrollTop;
        }

 
取文档内容实际高度

  getScrollHeight: function () {
            return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        }

 
滚动条距离底部的高度

getScrollbheight: function () { return this.getScrollHeight() - this.getScrollTop() - this.getClientHeight(); }

 
 取滚动条距离底部的高度，当滚动条到最底部的时候，通过ajax异步请求后台，加载下一页数据，这样就可以免了翻页的麻烦了。
 
ps：用jquery 更加简洁（感谢@Samguist）

if ($(window).scrollTop() == $(document).height() - $(window).height()) {
// ajax异步加载数据
}

 
 
 
基本上就是这样简单，没什么难度。记得有什么好工作通知一声哦~^_^ ^_^   ***** 点击本人求职信息*****
环境：vs2013   数据库：无   插件：HtmlAgilityPack   演示地址  源码下载  （源码都下了 顺手点个赞呗~）
下一篇：各大招聘网站信息实时查询浏览【二】
 
article  69
title: IE7中使用Jquery动态操作name问题
body: 

问题：IE7中无法使用Jquery动态操作页面元素的name属性。

在项目中有出现问题，某些客户的机器偶尔会有，后台取不到前台的数据值。
然开发和测试环境总是不能重现问题。坑爹之处就在于此，不能重现就不能调试，就不能知道改了后还会不会有这样的问题。
想想可能与客户环境唯一不同就只有可能是js缓存问题了，然后把所有的js文件引用的地方都加上一个当前时间参数，然问题依然存在。
本来规定的版本就是IE8，所以也没有想过会有版本兼容问题，在说了咱用的是jquery，jqeruy的出现不就是号称为了解决浏览器的兼容问题么。
该死了问题，还真实版本问题。因为某些页面需要用到IE8的兼容模式，然兼容模式其实就是像下兼容，那不就是兼容IE7 了么？

于是本地用demo测试了下。


 <form id="form1" runat="server">
        <div id="div">
            <input id="input" name="1" value="123" />
        </div>
    </form>
    <script src="jquery-1.6.4.min.js"></script>
    <script>
        $("#input").attr("name", "myname");
        alert("name:" + $("#input").attr("name") + "***html:" + $("#div").html());
    </script>

IE8：  ok！
IE8兼容模式：
??为什么 $("#input").attr("name")取到的是修改后的值，而$("#div").html() 取到的name还是原先的值？？
F12查看生成的html
擦 submitName 是什么东东？明显name没有改变。submitName 应该是jquery生成的 然后读取name的时候 也是直接读取的submitName 的值。
那为什么$("#div").html() 取的值中没有submitName 呢？？  我也不知道jquery中的html方法是怎么实现的~~
 
 
项目中的实现方式类似于:

<form id="form1" runat="server">
        <div id="div">
            <input id="input" name="1" value="123" type="text" />
        </div>
        <div id="div2">
        </div>
    </form>
    <script src="jquery-1.6.4.min.js"></script>
    <script>
        //alert("name:" + $("#input").attr("name") + "***html:" + $("#div").html());

        $("#input").attr("name", "myname");
        $("#div2").html($("#div").html());
        var nameVal = $("#div2").find("input[name='myname']").val();
        alert(nameVal);

    </script>

 
这样  在IE8和谷歌浏览器 取值正常，在IE8兼容模式却取不到值。【不要问为什么非要这么赋值取值，这是demo'类似于'的实现，且是一个框架】
 
解决方案：
1.直接用jquery修改name 然后访问name是ok的，虽然 中间是生成了submitName 。
2.可以先$("#div2").html($("#div").html()); 然后在修改.attr("name", "myname");
3.可以直接拼接html。    $("#div").html("<input id="input" name="myname" value="123" type="text" />")
 
最后百度了下，原来是IE7不能用document.getElementsByName()访问js动态创建和修改后的name值。
 
article  70
title: js问题杂记
body: 
 
1.如何把字符串数组 转成数组对象？
eval妙用

var str = "[\"UserName=1,Pwd=1\",\"UserNmae=1,Pwd=1,Sax=0\"]";
var arr = eval(str);
alert(arr[0]);

 
article  71
title: 博客备份小工具3
body: 
    接着 博客转发小工具2 ，又弄了一个第三版。主要功能有：博客备份到本地、浏览备份到本地的博客、关键字搜索本地的博客和转发博客可以选择个人分类 填写Tag标签。其实想了想，转发博客干嘛非要在本地客户端转发，直接在博客园的页面用js不就可以达到目的么。想是这么想，还没尝试。等我写完了这个博客就去试试。。继续回到这个小工具，说实在的本人做的这个小工具界面丑的那是、、反正就是很丑很丑啦。没办法，没有美工的那种艺术细胞。还有就是，整个功能其实真没什么技术含量，还是html的抓取，winfrom在工作中也没用过，就平时偶尔玩玩，望大神们勿喷~~。  
    不过我觉得这个小工具的作用：第一、可以用来备注自己的博客，自己留个底。第二、某些朋友的工作环境可能没有外网（我以前的公司就没有），这样的话可以用来备份一些博友的系类文章当资料。【要是可以的话，把系类文章导成dpf文档那就更爽了。可是我一直没成功~】。
    也许有写人会说：啥啥啥的早就有类似的软件了。我不知道，我没用过，我觉得自己做的用着开心。就当练手吧。
   开始说内容了。

 

功能一：备份博客到本地
备份的博客是博客园推荐的前150个。也可以自己手动输入要备份的url。
1.加载推荐博客

var docment = new HtmlAgilityPack.HtmlDocument();
docment.LoadHtml(BlogCommon.PostReqest(BlogUrlString.推荐博客url));
var nodes = docment.DocumentNode.SelectNodes("//ul//a");
List<object> list = new List<object>();
for (int i = 0; i < nodes.Count; i++)
{
    var url = "http://www.cnblogs.com" + nodes[i].Attributes["href"].Value;
    var name = "NO." + (i + 1).ToString() + " " + nodes[i].InnerText;
    list.Add(new { url = url, name = name });
}
list_tuijian.DataSource = list;
list_tuijian.ValueMember = "url";
list_tuijian.DisplayMember = "name";

 
2.加载随笔分类、档案和标签
 首先选中博客改变url，然后url文本框的TextChanged事件里面加载 随笔分类、档案和标签数据。

var docment = new HtmlAgilityPack.HtmlDocument();
docment.LoadHtml(BlogCommon.GetRequest(BlogUrlString.个人博客分类url(strname)));
//加载随笔类型
LoadTree(docment, "//div[@class='catListPostCategory']//a", tree_suibiType, "随笔分类");
tree_suibiType.CheckBoxes = true;

// 加载随笔档案
LoadTree(docment, "//div[@class='catListPostArchive']//a", tree_suibiTime, "随笔档案");
tree_suibiTime.CheckBoxes = true;

//// 加载文章类型
//LoadTree(docment, "//div[@class='catListArticleCategory']//a", tree_wenzhangType, "文章类型");
//tree_suibiType.CheckBoxes = true;

docment.LoadHtml(BlogCommon.GetRequest(BlogUrlString.标签url(strname)));
// 加载文章类型
LoadTree(docment, "//div[@id='taglist']//a", tree_tag, "标签");
tree_tag.CheckBoxes = true;

 

public void LoadTree(HtmlAgilityPack.HtmlDocument docment, string where, TreeView trre, string TreeName)
{
    try
    {
        trre.Nodes.Clear();
        var nodes = docment.DocumentNode.SelectNodes(where);
        if (nodes == null || nodes.Count <= 0)
            return;
        List<object> list = new List<object>();

        TreeNode treenodeS = new TreeNode() { Name = "", Text = TreeName };
        for (int i = 0; i < nodes.Count; i++)
        {
            TreeNode treenode = new TreeNode();
            var url = nodes[i].Attributes["href"].Value;
            var name = nodes[i].InnerText;
            list.Add(new { url = url, name = name });
            treenode.Text = name;
            treenode.Name = url;
            treenodeS.Nodes.Add(treenode);
        }
        trre.Nodes.Add(treenodeS);
        trre.ExpandAll();//展开节点
    }
    catch (Exception ex)
    {
        MessageBox.Show("加载" + TreeName + "错误" + ex.Message);
    }
}

 
3.点击备份
点击备份，读取选中的复选框所包含的所有url。

#region 获取某个选中树节点 的所有url地址

        public List<string[]> getShuibiType_all_url(string url, ref List<string[]> list_urlS)
        {
            label1.Text = "正在读取" + url;
            var docment = new HtmlAgilityPack.HtmlDocument();
            docment.LoadHtml(BlogCommon.GetRequest(url));
            // a class entrylistItemTitle  entrylistTitle
            var nodes = docment.DocumentNode.SelectNodes("//div[@class='entrylist']//div[@class='entrylistPosttitle']//a");
            if (nodes == null)
                nodes = docment.DocumentNode.SelectNodes("//div[@id='content']//div[@class='post post-list-item']/h2/a");
            var entrylistTitle = docment.DocumentNode.SelectNodes("//h1[@class='entrylistTitle']");
            if (entrylistTitle == null)
                entrylistTitle = docment.DocumentNode.SelectNodes("//div[@id='content']/h2");
            var posts_title = entrylistTitle != null ? entrylistTitle[0].InnerText : "未分类";
            if (nodes != null && nodes.Count > 0)
            {
                for (int j = 0; j < nodes.Count; j++)
                {
                    label1.Text = "正在读取[" + posts_title + "]" + (j + 1) + "/" + nodes.Count + "页" + "url地址";

                    list_urlS.Add(
                        new string[] 
                        { 
                            nodes[j].Attributes["href"].Value,
                            nodes[j].InnerText,
                            entrylistTitle.Count>=1?entrylistTitle[0].InnerText:"未分类"
                        });
                }
            }
            return list_urlS;
        }

        #endregion

 
点击备份，保存到本地。


#region 保存内容到文件
        /// <summary>
        /// 保存内容到文件 
        /// </summary>
        /// <param name="list_str">根据地址集合</param>
        /// <param name="type"></param>
        /// <param name="docment"></param>
        public void SaveFile(List<string[]> list_str, string type, HtmlAgilityPack.HtmlDocument docment)
        {
            if (list_str == null || list_str.Count <= 0)
                return;
            for (int i = 0; i < list_str.Count; i++)
            {
                var url = list_str[i][0];
                var name = url.Split('/').Length >= 4 ? url.Split('/')[3] : "未分类";
                if (list_str[i].Length == 3)
                {
                    try
                    {
                        label1.Text = "正在请求[" + name + "/" + type + "]页面" + (i + 1) + "/" + list_str.Count + "。";

                        #region 文件路径处理
                        //过滤文件名的特殊字符
                        string[] rep = new string[] { "&mdash;", ":", "<", ">", "?", "*", "/", "|", "\"" };
                        string fileNmae = list_str[i][1].Replace("\\", string.Empty);
                        for (int j = 0; j < rep.Length; j++)
                        {
                            if (rep[j].Length == 0)
                                continue;
                            fileNmae = fileNmae.Replace(rep[j], string.Empty);
                        }
                        var Paht = ForwardPath + name + "\\" + type + "\\" + list_str[i][2] + "\\";
                        for (int j = 0; j < rep.Length; j++)
                        {
                            if (rep[j].Length == 0)
                                continue;
                            Paht = Paht.Replace(rep[j], string.Empty);
                        }
                        Paht = FileHelp.PathBlogs + Paht;
                        var FilePath = Paht + fileNmae + ".html"; 
                        #endregion

                        if (radioButton2.Checked && File.Exists(FilePath))
                        {
                            label1.Text = "页面数据存在[" + name + "/" + type + "]页面" + (i + 1) + "/" + list_str.Count + "。";
                            continue;
                        } 

                        var html = BlogCommon.GetRequest(url);
                        docment.LoadHtml(html);                  
                        var Nodes = docment.DocumentNode.SelectNodes("//div[@class='postBody']");
                        if (Nodes == null)
                            Nodes = docment.DocumentNode.SelectNodes("//div[@id='cnblogs_post_body']");
                        html = Nodes[0].InnerHtml;
                        docment.DocumentNode.InnerHtml = "<div id='my_html_postBody'>" + html + "</div>";

                        #region 去掉a标签的超链接
                        //去掉a标签的超链接
                        var html_aS = docment.DocumentNode.SelectNodes("//a");
                        if (html_aS != null)
                            for (int z = 0; z < html_aS.Count; z++)
                                if (html_aS[z].Attributes["href"] != null && html_aS[z].Attributes["href"].Value[0] != '#')
                                    html_aS[z].Attributes["href"].Value = "javascript:void()"; 
                        #endregion 

                        label1.Text = "准备保存[" + name + "/" + type + "]内容" + (i + 1) + "/" + list_str.Count + "~";
                        FileHelp.CreatePath(Paht + @"imgs\");
                        saveImg(docment, Paht + @"imgs\", label1.Text + "...");
                        docment.CreateAttribute("url", url);

                        //profile_block                        
                        docment.DocumentNode.InnerHtml = "<div id='mytext_url'>" + url + "</div>"
                                                        + "<div id='mytext_BlogTitleName'>" + name + "</div>"
                                                        + docment.DocumentNode.InnerHtml;

                        docment.Save(FilePath, Encoding.UTF8);
                        File.SetCreationTime(FilePath, new DateTime(FileHelp.Ticks));
                        LuceneHelp.CreateIndexFilePath(FilePath);
                        //FileHelps.SaveFile(Paht, fileNmae + ".txt", html);
                        label1.Text = "保存成功" + (i + 1) + "/" + list_str.Count + "。";
                    }
                    catch (Exception ex)
                    {
                        string mess = url + "\r\n" + ex.Message + "\r\n" + ex.StackTrace + "\r\n\r\n";
                        string myPath = FileHelp.PathBlogs + ForwardPath + name + "\\" + type + "\\";
                        FileHelp.SaveFile(myPath, "err.txt", mess, false);
                    }
                }
                else
                    FileHelp.SaveFile(FileHelp.PathBlogs + ForwardPath + name + "\\" + type + "\\", "err.txt", "异常373位置", false);
            }
        }
        #endregion

View Code
 
功能二：浏览本地博客
1.递归加载目录下所以博客文件
（这个方法不行，如果文件多的话，会有点卡。以后要改成点击加载下层目录）

public TreeNodeCollection loadTree(string path, TreeNodeCollection treeS, bool isNe = true)
{
    List<string[]> list = FileHelp.FileSystemInfo(path, "3");
    string[] str = new string[] { "", "" };
    if (list != null)
    {

        for (int i = 0, j = 0; i < list.Count; i++, j++)
        {
            if (list[i][0] == "imgs")
            {
                j--;
                continue;
            }
            TreeNode tree1 = new TreeNode() { Text = list[i][0] };
            treeS.Add(tree1);
            loadTree(list[i][1], treeS[j].Nodes);
        }
    }
    return treeS;
}

 
2.点击加载博客内容（这里使用到了webBrowser控件来显示博客内容）

 #region 点击tree树  加载对应内容
        /// <summary>
        /// 点击tree树  加载对应内容
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (e.Action == TreeViewAction.ByMouse || e.Action == TreeViewAction.ByKeyboard)
            {
                htmlPath = FileHelp.PathBlogs + Forward.ForwardPath + e.Node.FullPath;
                string html = FileHelp.GetFile(htmlPath);
                HtmlAgilityPack.HtmlDocument docment = new HtmlAgilityPack.HtmlDocument();
                docment.LoadHtml(html);
                try
                {
                    var text_html = docment.DocumentNode.SelectNodes("//div[@id='my_html_postBody']")[0].InnerHtml;
                    var mytext_url = docment.DocumentNode.SelectNodes("//div[@id='mytext_url']")[0].InnerHtml;
                    webBrowser1.DocumentText = text_html;
                    text_url.Text = mytext_url;
                }
                catch (Exception)
                { }
            }
        }
        #endregion

功能三：本地浏览关键字搜索
搜索使用的Lucenne.net。这里面的水太深了。这里就使用到了点皮毛。这里给出一些资料地址。
1.首先在备份的时候就需要创建搜索索引。

/// <summary>
/// 创建索引
/// </summary>
/// <param name="analyzer"></param>
/// <param name="title"></param>
/// <param name="content"></param>
private static void AddIndex(IndexWriter writer, string title, string content, string filePath, string id, string mytext_BlogTitleName = "Blog", string ClickQuantity = "0")
{
    try
    {
        // Field.Store.YES, Field.Index.ANALYZED, Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS));

        Document doc = new Document();
        doc.Add(new Field("Title", title, Field.Store.YES, Field.Index.ANALYZED));//存储且索引
        //doc.Add(new Field("Content", content, Field.Store.YES, Field.Index.ANALYZED, Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS));// Field.Store.YES, Field.Index.ANALYZED));//存储且索引
        doc.Add(new Field("Content", content, Field.Store.YES, Field.Index.ANALYZED));
        doc.Add(new Field("filePath", filePath, Field.Store.YES, Field.Index.NOT_ANALYZED));//存储且索引
        doc.Add(new Field("BlogTitleName", mytext_BlogTitleName, Field.Store.YES, Field.Index.NOT_ANALYZED));
        doc.Add(new Field("id", id, Field.Store.YES, Field.Index.NOT_ANALYZED));
        doc.Add(new Field("ClickQuantity", ClickQuantity, Field.Store.YES, Field.Index.NOT_ANALYZED));
        //防止重复索引
        writer.DeleteDocuments(new Term("id", id));
        //AddTime
        writer.AddDocument(doc);
    }
    catch (FileNotFoundException fnfe)
    {
        throw fnfe;
    }
    catch (Exception ex)
    {
        throw ex;
    }
}

 
2.点击搜索

#region 点击搜索
        private void but_select_Click(object sender, EventArgs e)
        {
            new Thread(delegate()
            {
                try
                {
                    lab_meg.Text = "正在搜索.....";
                    var htm = "";
                    var list = LuceneHelp.SelectData(FileHelp.PathBlogs + "Index\\", txt_select.Text.Trim(), this.lab_meg);
                    var count = 150;
                    if (list.Count >= count)
                    {
                        var mess = MessageBox.Show("搜索结果过多，是否只显示前" + count + "条~", "提示", MessageBoxButtons.YesNo, MessageBoxIcon.Asterisk);
                        if (mess == System.Windows.Forms.DialogResult.Yes)
                        {
                            int index = 0;
                            foreach (var item in list)
                            {
                                index++;
                                htm += "<a name='click_load_file' href='#' filePath='" + item.FilePath + "'>" +
                                         item.FileName + "</a><br/><div>" + item.Content
                                         + "<div><br/><div style='width:100%;text-align:right;'><span style='margin-right:20px;background-color:#e1d2d2'>作者["
                                         + item.BlogTitleName + "]&nbsp;&nbsp;搜索(" + item.ClickQuantity + ")</span></div><br/><br/>";
                                if (index >= count)
                                    break;
                            }
                        }
                        else
                            foreach (var item in list)
                            {
                                htm += "<a name='click_load_file' href='#' filePath='" + item.FilePath + "'>" +
                                         item.FileName + "</a><br/><div>" + item.Content
                                         + "<div><br/><div style='width:100%;text-align:right;'><span style='margin-right:20px;background-color:#e1d2d2'>作者["
                                         + item.BlogTitleName + "]&nbsp;&nbsp;搜索(" + item.ClickQuantity + ")</span></div><br/><br/>";
                            }

                    }
                    else
                    {
                        foreach (var item in list)
                        {
                            htm += "<a name='click_load_file' href='#' filePath='" + item.FilePath + "'>" +
                                     item.FileName + "</a><br/><div>" + item.Content
                                     + "<div><br/><div style='width:100%;text-align:right;'><span style='margin-right:20px;background-color:#e1d2d2'>作者["
                                     + item.BlogTitleName + "]&nbsp;&nbsp;搜索(" + item.ClickQuantity + ")</span></div><br/><br/>";
                        }
                    }
                    webBrowser1.DocumentText = htm;
                    htmlList = htm;
                }
                catch (Exception ex)
                {
                    //MessageBox.Show(ex.Message);
                    lab_meg.Text = "搜索出错~" + ex.Message;
                }
            }).Start();
        }
        #endregion

 
下载地址：
环境：vs2013 版本：.Net Framework4.5 数据库：无 
程序下载 源码下载  （源码都给您了，顺手点个赞呗~~）
 
article  72
title: MVC学习一：EF
body: 
目录
一.EF修改和删除的多种方法
二.标准查询where
三.include
四.skip take
五.反射获取实例属性
六.EF DLL数据访问帮助类
 
一.EF修改和删除的多种方法
方法1：官方推荐 先查询在修改 或者删除

1 var student = db.Students.FirstOrDefault(t => t.Id == Mid);
2 student.Name = "修改后";//修改值数据
3 db.SaveChanges();//保存 
4 db.Students.Remove(student);//移除对象
5 db.SaveChanges();//保存

 
方法2：先附加到ef实体对象 然后在移除

1 Students s = new Students();
2 s.Id = int.Parse(id);
3 db.Students.Attach(s);//将实体附加到 上下文中 ；
4 db.Students.Remove(s);
5 if (db.SaveChanges() >= 1)
6 {
7     //成功
8 } 

 
方法3：添加到ef实体对象 然后标记删除

1 Students s = new Students();
2 s.Id = int.Parse(id);
3 db.Entry<Students>(s).State = System.Data.EntityState.Deleted;//标记删除
4 int num = db.SaveChanges();

 
方法4：修改实体

 1 //这里需要关闭验证 不然会报错
 2 db.Configuration.ValidateOnSaveEnabled = false;
 3 DbEntityEntry dbS = db.Entry<Students>(s);
 4 dbS.State = System.Data.EntityState.Unchanged;      //清楚所有字段标记  
 5 dbS.Property("Gender").IsModified = true;//标记修改字段 
 6 int num = db.SaveChanges();
 7 db.Configuration.ValidateOnSaveEnabled = true;//打开验证
 8 if (num >= 1)
 9 {
10     //修改成功
11 }

 
二.标准查询where 在不同场景 实现方法不一样

1 //场景1：ef的数据集 使用where 是在 IQueryable 的扩展方法
2 //场景2：List集合的数据集 使用where 是在 IEnumerable 的扩展方法

 
三.include
场景1：自动 连接查询【无Include】

1 //1.自动 连接查询【无Include】
2 var stu1 = db.Students.Where(t => t.Classes.CName == "zha");
3 var cname = stu1.FirstOrDefault();


 1 SELECT TOP (1) 
 2 [Extent1].[Id] AS [Id], 
 3 [Extent1].[CId] AS [CId], 
 4 [Extent1].[Name] AS [Name], 
 5 [Extent1].[Gender] AS [Gender], 
 6 [Extent1].[IsDel] AS [IsDel], 
 7 [Extent1].[AddTime] AS [AddTime]
 8 FROM  [dbo].[Students] AS [Extent1]
 9 INNER JOIN [dbo].[Classes] AS [Extent2] ON [Extent1].[CId] = [Extent2].[CID]
10 WHERE 'zha' = [Extent2].[CName]

 
场景2：手动 内连接查询【有Include】

1 //2手动 内连接查询【有Include】
2 var stu2 = db.Students.Include("Classes").Where(t => t.Id == 11);
3 var ccc = stu2.FirstOrDefault().Classes.CName;


 1 SELECT 
 2 [Limit1].[Id] AS [Id], 
 3 [Limit1].[CId] AS [CId], 
 4 [Limit1].[Name] AS [Name], 
 5 [Limit1].[Gender] AS [Gender], 
 6 [Limit1].[IsDel] AS [IsDel], 
 7 [Limit1].[AddTime] AS [AddTime], 
 8 [Extent2].[CID] AS [CId1], 
 9 [Extent2].[CName] AS [CName], 
10 [Extent2].[CCount] AS [CCount], 
11 [Extent2].[CImg] AS [CImg], 
12 [Extent2].[CIsDel] AS [CIsDel], 
13 [Extent2].[CAddTime] AS [CAddTime]
14 FROM   (SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[CId] AS [CId], [Extent1].[Name] AS [Name], [Extent1].[Gender] AS [Gender], [Extent1].[IsDel] AS [IsDel], [Extent1].[AddTime] AS [AddTime]
15     FROM [dbo].[Students] AS [Extent1]
16     WHERE 11 = [Extent1].[Id] ) AS [Limit1]
17 LEFT OUTER JOIN [dbo].[Classes] AS [Extent2] ON [Limit1].[CId] = [Extent2].[CID]

 
场景3：无连接查询 分两次sql查询【无Include】

1 //3.无连接查询 分两次sql查询【无Include】
2 var stucc = db.Students.Where(t => t.Id == 11);
3 var zz = stucc.FirstOrDefault().Classes.CName;


 1 SELECT TOP (1) 
 2 [Extent1].[Id] AS [Id], 
 3 [Extent1].[CId] AS [CId], 
 4 [Extent1].[Name] AS [Name], 
 5 [Extent1].[Gender] AS [Gender], 
 6 [Extent1].[IsDel] AS [IsDel], 
 7 [Extent1].[AddTime] AS [AddTime]
 8 FROM [dbo].[Students] AS [Extent1]
 9 WHERE 11 = [Extent1].[Id];
10 
11 SELECT 
12 [Extent1].[CID] AS [CID], 
13 [Extent1].[CName] AS [CName], 
14 [Extent1].[CCount] AS [CCount], 
15 [Extent1].[CImg] AS [CImg], 
16 [Extent1].[CIsDel] AS [CIsDel], 
17 [Extent1].[CAddTime] AS [CAddTime]
18 FROM [dbo].[Classes] AS [Extent1]
19 WHERE [Extent1].[CID] = @EntityKeyValue1

 
四.skip take

1 //Skip 跳过序列中指定数量的元素，然后返回剩余的元素。
2 //Take 从序列的开头返回指定数量的连续元素。
3 //根据这两个方法可以 实现 分页效果

 
 
五.反射获取实例属性

1 //利用反射 获取 类 对象 的所有公共 属性 默认是[GetProperties(BindingFlags.Instance | BindingFlags.Public)]
2 var listPro = typeof(Students).GetProperties().ToList();
3 object obj1 = new object();
4 object obj2 = new object();
5 listPro.ForEach(l =>
6 {
7     var newValue = l.GetValue(obj1); //获得某个对象的属性值
8     l.SetValue(obj2, newValue);//修改一个对象的属性 值
9 });

 
六.EF DLL数据访问帮助 父类


  1 using _00EFModel;
  2 using System;
  3 using System.Collections.Generic;
  4 using System.Linq;
  5 using System.Linq.Expressions;
  6 using System.Reflection;
  7 using System.Text;
  8 using System.Threading.Tasks;
  9 
 10 namespace _00EFDLL
 11 {
 12     /// <summary>
 13     /// 数据访问 父类  
 14     /// </summary>
 15     public class BaseDLL<Tclass> where Tclass : class,new()
 16     {
 17         /// <summary>
 18         /// 数据访问上下文
 19         /// </summary>
 20         _00EFModel.Entities db = new _00EFModel.Entities();
 21 
 22         #region 1.0添加数据 + Add(Tclass model)
 23         /// <summary>
 24         /// 1.0添加数据
 25         /// </summary>
 26         /// <param name="model"></param>
 27         public void Add(Tclass model)
 28         {
 29             db.Set<Tclass>().Add(model);
 30         }
 31         #endregion
 32 
 33         #region  2.0 删除方法1 删除给定的对象 +Del(Tclass model)
 34         /// <summary>
 35         /// 2.0 删除方法1 删除给定的对象
 36         /// </summary>
 37         /// <param name="model"></param>
 38         public void Del(Tclass model)
 39         {
 40             //将实体 添加到上下文
 41             db.Set<Tclass>().Attach(model);
 42             //把实体 标记为删除
 43             db.Set<Tclass>().Remove(model);
 44         }
 45         #endregion
 46 
 47         #region  2.1 删除方法2 根据条件删除对象 +Del(Expression<Func<Tclass, bool>> delWhere)
 48         /// <summary>
 49         /// 2.1 删除方法2 根据条件删除对象 
 50         /// </summary>
 51         /// <param name="delWhere"></param>
 52         public void Del(Expression<Func<Tclass, bool>> delWhere)
 53         {
 54             //查询所有满足条件的实体对象
 55             var modelS = db.Set<Tclass>().Where(delWhere).ToList();
 56             modelS.ForEach(m =>
 57             {
 58                 //附加到 上下文
 59                 db.Set<Tclass>().Attach(m);
 60                 //标记为 删除状态
 61                 db.Set<Tclass>().Remove(m);
 62             });
 63         }
 64         #endregion
 65 
 66         #region 3.0 修改方法1 修改某个实体的 某些属性 +Up(Tclass model, params string[] strparams)
 67         /// <summary>
 68         /// 3.0 修改方法1 修改某个实体的 某些属性(根据id修改)【*用这个需要注意关闭检查】
 69         /// </summary>
 70         /// <param name="model"></param>
 71         /// <param name="strparams">可变参数</param>
 72         public int Up(Tclass model, params string[] strparams)
 73         {
 74             //关闭检查
 75             db.Configuration.ValidateOnSaveEnabled = false;
 76             //附加到上下文
 77             var m = db.Entry<Tclass>(model);
 78             //把全部属性标记为 没有修改
 79             m.State = System.Data.Entity.EntityState.Unchanged;
 80             for (int i = 0; i < strparams.Length; i++)
 81             {
 82                 //标记要修改的属性
 83                 m.Property(strparams[i]).IsModified = true;
 84             }
 85             int num = db.SaveChanges();
 86             //打开检查
 87             db.Configuration.ValidateOnSaveEnabled = true;
 88             return num;
 89         }
 90         #endregion
 91 
 92         #region 3.1 修改方法2 根据条件 修改指定的 属性 值 +Up(Expression<Func<Tclass, bool>> upWhere, Tclass model, params string[] strparame)
 93         /// <summary>
 94         /// 3.1 修改方法2 根据条件 修改指定的 属性 值
 95         /// </summary>
 96         /// <param name="upWhere"></param>
 97         /// <param name="model"></param>
 98         /// <param name="strparame"></param>
 99         public void Up(Expression<Func<Tclass, bool>> upWhere, Tclass model, params string[] strparame)
100         {
101             //查询出满足条件的所有实体
102             var modelS = db.Set<Tclass>().Where(upWhere).ToList();
103             //利用反射 获取 类 对象 的所有公共 属性 默认是[GetProperties(BindingFlags.Instance | BindingFlags.Public)]
104             var listPro = typeof(Tclass).GetProperties().ToList();
105             // 属性对象 键值对
106             List<PropertyInfo> dic = new List<PropertyInfo>();
107             listPro.ForEach(l =>
108             {
109                 for (int i = 0; i < strparame.Length; i++)
110                 {
111                     //循环 判断 添加 需要修改的 属性对象
112                     if (l.Name == strparame[i].Trim())
113                     {
114                         dic.Add(l);
115                         break;
116                     }
117                 }
118             });
119 
120             if (dic.Count > 0)//判断 属性对象集合  是否 有 数据
121             {
122                 foreach (var property in dic)
123                 {
124                     //取 传过来的对象 里面的值
125                     var newValue = property.GetValue(model);
126                     foreach (var mymodel in modelS)
127                     {
128                         //修改到 对象集合
129                         property.SetValue(mymodel, newValue);
130                     }
131                 }
132             }
133         }
134         #endregion
135 
136         #region  4.0 查询方法 +GetList<Tkey>(Expression<Func<Tclass, bool>> strWhere, Expression<Func<Tclass, Tkey>> strOrederBy = null, bool order = true)
137         /// <summary>
138         /// 4.0 查询方法 
139         /// </summary>
140         /// <typeparam name="Tkey"></typeparam>
141         /// <param name="strWhere">查询条件</param>
142         /// <param name="strOrederBy">排序条件</param>
143         /// <param name="order">是否升序</param>
144         /// <returns></returns>
145         public List<Tclass> GetList<Tkey>(Expression<Func<Tclass, bool>> strWhere, Expression<Func<Tclass, Tkey>> strOrederBy = null, bool order = true)
146         {
147             var t = db.Set<Tclass>().Where(strWhere);
148             if (strOrederBy != null)
149             {
150                 if (order)
151                     t = t.OrderBy(strOrederBy);
152                 else
153                     t = t.OrderByDescending(strOrederBy);
154             }
155             return t.ToList();
156         }
157         #endregion
158 
159         #region 4.1 查询方法2 分页查询 +GetList<Tkey>(int indexPage, int sizePage, Expression<Func<Tclass, bool>> strWhere, Expression<Func<Tclass, Tkey>> strOrederBy = null, bool order = true)
160         /// <summary>
161         /// 4.1 查询方法2 分页查询
162         /// </summary>
163         /// <typeparam name="Tkey"></typeparam>
164         /// <param name="indexPage">页码</param>
165         /// <param name="sizePage">页容量</param>
166         /// <param name="strWhere">查询条件</param>
167         /// <param name="strOrederBy">排序字段</param>
168         /// <param name="order">是否升序</param>
169         /// <returns></returns>
170         public List<Tclass> GetList<Tkey>(int indexPage, int sizePage, Expression<Func<Tclass, bool>> strWhere, Expression<Func<Tclass, Tkey>> strOrederBy = null, bool order = true)
171         {
172             var t = db.Set<Tclass>().Where(strWhere);
173             if (strOrederBy != null)
174             {
175                 if (order)
176                     t = t.OrderBy(strOrederBy);
177                 else
178                     t = t.OrderByDescending(strOrederBy);
179             }
180             return t.Skip((indexPage - 1) * sizePage).Take(sizePage).ToList();
181         }
182         #endregion
183 
184         #region 提交 +save()
185         /// <summary>
186         /// 提交
187         /// </summary>
188         /// <returns></returns>
189         public int save()
190         {
191             return db.SaveChanges();
192         }
193         #endregion
194     }
195 }

View Code
 
article  73
title: 博客转发小工具2
body: 
下一篇：博客小工具3
昨天发了一个博客转发小工具有朋友说“能一键转发到各主流媒体站上就更好了”。一开始我以为会能难，需要登录啊还有cookie的管理啊模拟post请求啊，乱七八糟一大堆。心想算啦，太累人，还不一定搞得定。后来心里总想着有没有什么简单的办法，就在网上查资料。最后皇天不负有心人让我找到了HttpClient。
ok，接着昨天的来。昨天的只能获取别人文章的内容复制到粘贴板。今天让它能一键发布。
首先需要解决的问题就是登录问题，不然可能是不能发布的。
登录博客园的代码

 1         /// <summary>
 2         /// 登录博客园
 3         /// </summary>
 4         /// <param name="username"></param>
 5         /// <param name="password"></param>
 6         /// <returns></returns>
 7         public bool LoginCnblogs(string username = "", string password = "")
 8         {
 9             httpClient = new HttpClient();
10             httpClient.MaxResponseContentBufferSize = 256000;
11             httpClient.DefaultRequestHeaders.Add("user-agent", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.143 Safari/537.36");
12             String url = "http://passport.cnblogs.com/login.aspx";
13             HttpResponseMessage response = httpClient.GetAsync(new Uri(url)).Result;
14             String result = response.Content.ReadAsStringAsync().Result;
15 
16             String __EVENTVALIDATION = new Regex("id=\"__EVENTVALIDATION\" value=\"(.*?)\"").Match(result).Groups[1].Value;
17             String __VIEWSTATE = new Regex("id=\"__VIEWSTATE\" value=\"(.*?)\"").Match(result).Groups[1].Value;
18             String LBD_VCID_c_login_logincaptcha = new Regex("id=\"LBD_VCID_c_login_logincaptcha\" value=\"(.*?)\"").Match(result).Groups[1].Value;
19 
20             //开始登录
21             url = "http://passport.cnblogs.com/login.aspx";
22             List<KeyValuePair<String, String>> paramList = new List<KeyValuePair<String, String>>();
23             paramList.Add(new KeyValuePair<string, string>("__EVENTTARGET", ""));
24             paramList.Add(new KeyValuePair<string, string>("__EVENTARGUMENT", ""));
25             paramList.Add(new KeyValuePair<string, string>("__VIEWSTATE", __VIEWSTATE));
26             paramList.Add(new KeyValuePair<string, string>("__VIEWSTATEGENERATOR", "C2EE9ABB"));
27             paramList.Add(new KeyValuePair<string, string>("__EVENTVALIDATION", __EVENTVALIDATION));
28             paramList.Add(new KeyValuePair<string, string>("tbUserName", username));
29             paramList.Add(new KeyValuePair<string, string>("tbPassword", password));
30             paramList.Add(new KeyValuePair<string, string>("LBD_VCID_c_login_logincaptcha", LBD_VCID_c_login_logincaptcha));
31             paramList.Add(new KeyValuePair<string, string>("LBD_BackWorkaround_c_login_logincaptcha", "1"));
32             //paramList.Add(new KeyValuePair<string, string>("CaptchaCodeTextBox", imgCode));
33             paramList.Add(new KeyValuePair<string, string>("btnLogin", "登  录"));
34             paramList.Add(new KeyValuePair<string, string>("txtReturnUrl", "http://home.cnblogs.com/"));
35             response = httpClient.PostAsync(new Uri(url), new FormUrlEncodedContent(paramList)).Result;
36             result = response.Content.ReadAsStringAsync().Result;
37 
38             if (result.Contains("用户登录"))
39                 return false;
40             else if (result.Contains("返回博客园首页"))
41                 return true;
42             else
43                 return false;
44         }

然后就是发布的代码

 1         /// <summary>
 2         /// 发布转发文章
 3         /// </summary>
 4         /// <returns></returns>
 5         public bool Release(string title = "", string content = "")
 6         {
 7             List<KeyValuePair<String, String>> paramList = new List<KeyValuePair<String, String>>();
 8             paramList.Add(new KeyValuePair<string, string>("__VIEWSTATE", @""));
 9             paramList.Add(new KeyValuePair<string, string>("__VIEWSTATEGENERATOR", "FE27D343"));
10             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$txbTitle", title));
11             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$EditorBody", content));
12             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$ckbPublished", "on"));
13             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$chkDisplayHomePage", "on"));
14             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$chkComments", "on"));
15             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$chkMainSyndication", "on"));
16             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$txbEntryName", ""));
17             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$txbExcerpt", ""));
18             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$txbTag", ""));
19             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$Advanced$tbEnryPassword", ""));
20             paramList.Add(new KeyValuePair<string, string>("Editor$Edit$lkbPost", "发布"));
21 
22             HttpResponseMessage response = httpClient.PostAsync(new Uri("http://i.cnblogs.com/EditPosts.aspx?opt=1"), new FormUrlEncodedContent(paramList)).Result;
23             String result = response.Content.ReadAsStringAsync().Result;
24             if (result.Contains("发布成功"))
25                 return true;
26             else
27                 return false;
28 
29         }

 关键代码就只有这么几句，没什么好讲的。我也不知其所以然。
不说了 上效果图。

转发成功。
说明：
   因为我登录博客园没有要输入验证码的情况，所以我就没有做验证码的处理了。大家的应该也不用输验证码吧。
还有就是没有做其他主流博客直接的相互转发，只有博客园内的转发。同学们有兴趣可以在次基础上做修改，欢迎改得“面目全非”。
环境：
  vs2013  .net4.5
功能：
  支持博客园一键转发，密码保存。下次就可以不用输入密码了。但是没有做加密措施。同学们可以自己接着折腾。
 
好了~最后发源码了。如果能感兴趣，拿起您的小手点个赞。如果您要反对 求您给你理由。
 程序下载  源码下载
 
下一篇：博客小工具3
 

 
article  74
title: 博客转发小工具1
body: 
有些朋友在转发别人博客的时候会问，博客怎么转发的啊？让我一段一段的复制吗？那图片怎么办？隐藏代码要一个一个的打开了复制？
对，很麻烦。费时费力。有的同学会说收藏不就可以了吗？收藏只是收藏了别人的地址，并没有收藏人家的全部内容。如果人家删除原文章，那就等于白收藏了。
我不知道 博客园有没有一键转发的功能，反正我是没找到的。于是，闲来无事，做了个博客转发小工具。
其实很简单，分三步。 
一：取得页面内容
取页面内容需要用到HtmlAgilityPack.dll 详细用法可以百度之。

 1          /// <summary>
 2         /// 抓取方法
 3         /// </summary>
 4         /// <param name="url">url地址</param>
 5         /// <returns></returns>
 6         public Result getList(string url)
 7         {
 8             if (string.IsNullOrEmpty(url) || string.IsNullOrEmpty(url.Trim()))
 9                 return null;//如果url为空 则立刻返回
10             Result result = new Result();
11             HtmlWeb htmlWeb = new HtmlWeb();
12             try
13             {
14                 HtmlAgilityPack.HtmlDocument htmlDoc = htmlWeb.Load(url);
15                 result.url = url;
16                 result.content = htmlDoc.DocumentNode.SelectSingleNode("//div[@id='cnblogs_post_body']").InnerHtml;//这里是去div id为cnblogs_post_body的全部内容  也就是我们发布的博客全部内容
17                 result.title = htmlDoc.DocumentNode.SelectSingleNode("//a[@id='cb_post_title_url']").InnerText; //取标题
18             }
19             catch (Exception) { return null; }
20             return result;
21         }

二：复制页面内容

Clipboard.SetText(txt_content.Text);//把内容复制到粘贴板

三：粘贴内容发布
这里就没有我的事了。你自己去后台发布就ok了。
不过发布的时候要注意了。粘贴的时候一定要切换到html模式。

贴图了
 
这里贴出全部代码，因为代码量非常少，就放一个文件了。

 1 using HtmlAgilityPack;
 2 using System;
 3 using System.Collections.Generic;
 4 using System.ComponentModel;
 5 using System.Data;
 6 using System.Drawing;
 7 using System.Text;
 8 using System.Windows.Forms;
 9 
10 namespace 博客转发
11 {
12     public partial class Form1 : Form
13     {
14         public Form1()
15         {
16             InitializeComponent();
17         }
18 
19         private void button1_Click(object sender, EventArgs e)
20         {
21             //string url = @"http://www.cnblogs.com/zhaopei/p/4174811.html";           
22             Result re = getList(txt_url.Text);
23             if (re == null)
24             {
25                 MessageBox.Show("请输入正确博客园的博客地址~"); return;
26             }
27             string str = @"<a href='" + re.url + "'>【转】" + re.title + "</a><br/>";
28             txt_content.Text = str + re.content;
29             txt_title.Text = "【转】" + re.title;
30             Clipboard.SetText(txt_content.Text);//把内容复制到粘贴板
31             MessageBox.Show("已经成功复制到粘贴板~");
32         }
33 
34         /// <summary>
35         /// 抓取方法
36         /// </summary>
37         /// <param name="url">url地址</param>
38         /// <returns></returns>
39         public Result getList(string url)
40         {
41             if (string.IsNullOrEmpty(url) || string.IsNullOrEmpty(url.Trim()))
42                 return null;//如果url为空 则立刻返回
43             Result result = new Result();
44             HtmlWeb htmlWeb = new HtmlWeb();
45             try
46             {
47                 HtmlAgilityPack.HtmlDocument htmlDoc = htmlWeb.Load(url);
48                 result.url = url;
49                 result.content = htmlDoc.DocumentNode.SelectSingleNode("//div[@id='cnblogs_post_body']").InnerHtml;//这里是去div id为cnblogs_post_body的全部内容  也就是我们发布的博客全部内容
50                 result.title = htmlDoc.DocumentNode.SelectSingleNode("//a[@id='cb_post_title_url']").InnerText; //取标题
51             }
52             catch (Exception) { return null; }
53             return result;
54         }
55     }
56 
57     public class Result
58     {
59         /// <summary>
60         /// 链接
61         /// </summary>
62         public string url { get; set; }
63         /// <summary>
64         /// 标题
65         /// </summary>
66         public string title { get; set; }
67         /// <summary>
68         /// 正文内容
69         /// </summary>
70         public string content { get; set; }
71     }
72 }

 
程序下载 密码：5c6q  源码下载 密码：60fr
如果大家有兴趣可以在此基础上进行自己的扩展和修改。
article  75
title: 博客园页面设置
body: 
注册博客园已经老久老久了，现在依然是个老菜鸟。最近开始尝试着写写博客，一来可以督促自己，二来可以回顾自己在过去到底学了些什么。看到很多人的博客都很炫，自己也就开始慢慢摸索。这里把自己摸索的一些经验总结一下。
目录
  一、编辑器
     1.链接
     2.书签
     3.html
     4.插入代码
 二、后台设置
     1.页面定制CSS代码
     2.公告栏
     3.首页html代码
     4.开通js权限
     5.推荐按钮
  补充
    1.为什么没效果
   2.代码具体放哪里
一、编辑器

1.链接
我们很多时候需要引用别人或自己以前的代码。这里可以很方便的加上链接。
一个添加链接 一个取消链接
选中要链接的文字右键就可以选中链接。

填入URL地址，目标一般选择在新窗口打开。
 
2.书签
插入书签
写入书签名
这样可以在文章开始写目录 跳到任意的书签。右键插入链接的时候可以绑定到书签。
 
3.html
点击可以看到源码，任意修改。
 
4.插入代码
这里可以选中编程语言。如果代码量比较多可以全部折叠。

 
二、后台设置
1.页面定制CSS代码
这里就可以和前面编辑器联合起来。在编辑器里面的文字选中格式时

如果选择的是标题 那么对应的是<h>标签，这样就可以在用CSS控制其样式。

显示效果，风格统一的小标题。

 
2.公告栏
公告栏一般大家都是贴上自己的靓照，加上自己的简单介绍。
还有的就是挂个漂亮的flash。
例1：


<embed wmode="transparent" src="http://chabudai.sakura.ne.jp/blogparts/honehoneclock/honehone_clock_tr.swf" quality="high" bgcolor="#ffffff" width="160" height="70" name="honehoneclock" align="middle" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">

 
例2：


<object type="application/x-shockwave-flash" style="outline:none;" data="http://cdn.abowman.com/widgets/hamster/hamster.swf?up_bodyColor=f0e9cc&amp;up_feetColor=D4C898&amp;up_eyeColor=000567&amp;up_wheelSpokeColor=DEDEDE&amp;up_wheelColor=FFFFFF&amp;up_waterColor=E0EFFF&amp;up_earColor=b0c4de&amp;up_wheelOuterColor=FF4D4D&amp;up_snoutColor=F7F4E9&amp;up_bgColor=F0E4E4&amp;up_foodColor=cba920&amp;up_wheelCenterColor=E4EB2F&amp;up_tailColor=E6DEBE&amp;" width="200" height="160">
<param name="movie" value="http://cdn.abowman.com/widgets/hamster/hamster.swf?up_bodyColor=f0e9cc&amp;up_feetColor=D4C898&amp;up_eyeColor=000567&amp;up_wheelSpokeColor=DEDEDE&amp;up_wheelColor=FFFFFF&amp;up_waterColor=E0EFFF&amp;up_earColor=b0c4de&amp;up_wheelOuterColor=FF4D4D&amp;up_snoutColor=F7F4E9&amp;up_bgColor=F0E4E4&amp;up_foodColor=cba920&amp;up_wheelCenterColor=E4EB2E&amp;up_tailColor=E6DEBE&amp;">
<param name="AllowScriptAccess" value="always">
<param name="wmode" value="opaque"></object>
<span style="color: #3E8BD6;font-size: 9pt;">求投食~（点图即可）</span>

补充：发现新大陆 好多时钟flash 地址
 
例3：
还可以贴上

<!--把“XXXXXXXX”替换成你的QQ号-->
<a target="_blank" href="http://wpa.qq.com/msgrd?v=3&amp;uin=XXXXXXXX&amp;site=qq&amp;menu=yes"><img border="0" src="http://wpa.qq.com/pa?p=1:XXXXXXXX:13" alt="有事您Q我" title="有事您Q我"></a>

 
例4：
还可以贴上你的主页被访问次数
先注册

<div style="font-size:20px;font-weight:bold;">访次:&nbsp;<a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=XXXXXXXX&amp;c=XXXXXXXX" alt="AmazingCounters.com"></a>&nbsp;次</div>

 例5：
园友补充 这个详细记录了ip什么   功能详细 强大  http://www.clicki.cn/

3.页首Html代码
这个我见得比较多的就是大家的GitHub，源码管理。
如：
这里还有很多别的样式图片 （注意，要将上图链接中的you换成自己的在Github上的账号） 
GitHub在windows中的使用
 
4.开通js权限
博客园默认是没有开通js权限的。可以向管理员申请开通。邮箱：contact@cnblogs.com
开通js权限后可以做很多事。
如：在公告栏中自己写个日历或者时钟表什么的。我的就是自己加了个时钟表

 时钟代码


  1 <!DOCTYPE html>
  2 <html xmlns="http://www.w3.org/1999/xhtml">
  3 <head>
  4 <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  5     <title></title>
  6 </head>
  7 <body>
  8     <div style="text-align: center; color: #ffffff;">
  9         <canvas id="canvas" height="160" width="160">
 10             您的浏览器不支持html5的canvas
 11         </canvas>
 12         <div style="height: 10px">
 13         </div>
 14         <div style="background-color: #0094ff;">
 15             <div id="div1">
 16             </div>
 17             <div id="div2">
 18             </div>
 19         </div>
 20     </div>
 21     <script type="text/javascript">
 22         window.onload = function () {
 23             var canvas = document.getElementById("canvas");
 24             var can = canvas.getContext("2d");
 25             var radius = 80; //半径
 26             var centre = [80, 80]; //中心点
 27 
 28             setInterval(function () {
 29                 mydrawclock();
 30 
 31             }, 1000);
 32             //   mydrawclock();
 33 
 34             function mydrawclock() {
 35                 //清空画布
 36                 can.clearRect(0, 0, 500, 500);
 37                 //钟的大小（圆）
 38                 can.fillStyle = "#ebf0eb";
 39                 can.beginPath();
 40                 can.arc(centre[0], centre[1], radius, 0, Math.PI * 2, true);
 41                 can.closePath();
 42                 can.fill();
 43                 //中心点
 44                 can.fillStyle = "#0094ff";
 45                 can.beginPath();
 46                 can.arc(centre[0], centre[1], 4, 0, Math.PI * 2, true);
 47                 can.closePath();
 48                 can.fill();
 49                 //画钟 宽度 度数 颜色 长度
 50                 function drawclock(w, d, c, l) {
 51                     can.beginPath();
 52                     can.strokeStyle = c;
 53                     can.lineWidth = w;
 54                     can.moveTo(centre[0], centre[1]);
 55                     can.lineTo(centre[0] + (radius - l) * Math.cos(d), centre[1] + (radius - l) * Math.sin(d));
 56                     can.stroke();
 57                 }
 58 
 59                 var date = new Date();
 60                 //因为画圆是从3点钟方向开始的 所以要减去
 61                 var hours = date.getHours();
 62                 var minutes = date.getMinutes();
 63                 var seconds = date.getSeconds();
 64                 var day = date.getDay();
 65 
 66                 drawclock(4, (hours - 3 + minutes / 60) * 30 * Math.PI / 180, "#0094ff", 33);
 67                 drawclock(3, (minutes - 15 + seconds / 60) * 6 * Math.PI / 180, "#0094ff", 22);
 68                 drawclock(2, (seconds - 15) * 6 * Math.PI / 180, "#0094ff", 1);
 69 
 70                 document.getElementById("div1").innerHTML = hours + ":" + minutes + ":" + seconds;
 71 
 72                 switch (day) {
 73                     case 0:
 74                         day = "星期天";
 75                         break;
 76                     case 1:
 77                         day = "星期一";
 78                         break;
 79                     case 2:
 80                         day = "星期二";
 81                         break;
 82                     case 3:
 83                         day = "星期三";
 84                         break;
 85                     case 4:
 86                         day = "星期四";
 87                         break;
 88                     case 5:
 89                         day = "星期五";
 90                         break;
 91                     case 6:
 92                         day = "星期六";
 93                         break;
 94                     default:
 95                         break;
 96                 }
 97 
 98                 document.getElementById("div2").innerHTML = day; // "</br>" + day;
 99                 // centre[0], centre[1]
100                 //画分钟刻度
101                 for (var i = 0; i < 60; i++) {
102                     var angle = i * 6 * Math.PI / 180;
103                     can.strokeStyle = "red";
104                     can.beginPath();
105                     can.lineWidth = 1;
106                     can.moveTo(centre[0] + radius * Math.cos(angle), centre[1] + radius * Math.sin(angle));
107                     can.lineTo(centre[0] + (radius - 5) * Math.cos(angle), centre[1] + (radius - 5) * Math.sin(angle));
108                     can.stroke();
109                 }
110                 //画时钟刻度
111                 for (var i = 0; i < 12; i++) {
112                     var angle = i * 30 * Math.PI / 180;
113                     can.strokeStyle = "#0094ff";
114                     can.lineWidth = 2;
115                     can.beginPath();
116                     can.moveTo(centre[0] + radius * Math.cos(angle), centre[1] + radius * Math.sin(angle));
117                     can.lineTo(centre[0] + (radius - 8) * Math.cos(angle), centre[1] + (radius - 8) * Math.sin(angle));
118                     can.stroke();
119                 }
120             }
121 
122 
123         }
124     </script>
125 </body>
126 </html>

View Code
 
5.推荐按钮
原本的推荐按钮是在最底下，不熟悉的人有时候可能找都找不到。

为了方便我们可以设置样式，使之悬浮。

/*快速评论*/
#div_digg {
  position: fixed;
  bottom: 10px;
  right: 15px;
  border: 2px solid #ECD7B1;
  padding: 10px;
  width: 140px;
  background-color: #fff;
  border-radius: 5px 5px 5px 5px !important;
  box-shadow: 0 0 0 1px #5F5A4B, 1px 1px 6px 1px rgba(10, 10, 0, 0.5);
}

 
如果开通了js权限的话，我们还可以动态添加别的快捷按钮。
如：关注，回到顶部，快速评价。


 1 <script type="text/javascript">
 2         /**
 3           不知道为什么页面加载完成时还读不到div_digg。可能也是动态生成的。
 4           所以这里只能用定时器 不断的读取，当读取到了再给它动态添加快捷按钮
 5         **/
 6 
 7         //自定义 定时器[当元素加载完成是执行回调函数]
 8         function customTimer(inpId, fn) {
 9             if ($(inpId).length) {
10                 fn();
11             }
12             else {
13                 var intervalId = setInterval(function () {
14                     if ($(inpId).length) {  //如果存在了
15                         clearInterval(intervalId);  // 则关闭定时器
16                         customTimer(inpId, fn);              //执行自身
17                     }
18                 }, 100);
19             }
20         }
21 
22         //页面加载完成是执行
23         $(function () {
24             customTimer("#div_digg", function () {
25                 var div_html = "<div class=''>\
26                         <a href='javascript:void(0);' onclick='c_follow();'>关注</a>\
27                          &nbsp;|&nbsp;\
28                         <a href='#top'>顶部</a>\
29                          &nbsp;|&nbsp;\
30                         <a href='javascript:void(0);' onclick=\" $('#tbCommentBody').focus();\">评论</a>\
31                    </div>";
32                 $("#div_digg").append(div_html);
33                 //tbCommentBody    
34             });
35         });
36  </script>

 
 ps：平时看大家的博客看得特爽。今天才知道原来写博客是件费时又费力的事情。不过写博客的好处也只有谁写谁知道！
大家如果有自己的窍门谢谢分享到评论区。
 
 

-----------------------------------------------------分割线--------------------------------------------------------------------------------------- 
有朋友问代码具体放哪里，有朋友问放入了代码为什么没有效果。那么我在这里详细说说。
1.为什么没有效果
注意没有效果很有可能是没有开通js权限。那么怎么测试自己是否有js权限呢？很简单放入一段测试代码就ok了。

<script type="text/javascript">console.log("测试成功~");</script>

把这句代码放入“页脚Html代码”保存即可。然后刷新你的页面。按F12点击Console，是否有打印了“测试成功”。（博客园貌似屏蔽了alert函数，所以不能弹出测试。）

如果没有，那么你可以发邮件到contact@cnblogs.com确认是否开通，没有开通的话可以申请开通。
2.代码具体放哪里
具体步骤图片分解


公告，页首和脚本地方都可以放html和js代码。
这里最后注意了！！之前我没有测试 原来代码直接贴进去是有问题的。不知道博客园有什么限制还是什么。
像我这样引用js是没有问题的。至于你的js代码放哪里？你可以上传到博客园的文件，也可以用https://git.oschina.net   或  https://github.com
article  76
title: 常用[js,css,jquery,html]
body: 
目录：
一、javascript事件和属性
二、jquery事件和方法
三、js
四、css
五、html
六、js操作cookies
七、插件
 
javascript事件和属性
事件
onblur         //当失去输入焦点后产生该事件
onfocus       //当输入获得焦点后，产生该事件
onchange     //当文字值改变,并失去焦点时，产生该事件
onselect      //事件会在文本框中的文本被选中时发生。
removeChild//方法删除指定节点。
replace       //替换
属性
parentNode 属性可返回某节点的父节点。
firstChild     属性返回被选节点的第一个子节点
lastChild     属性可返回文档的最后一个子节点。
 
jquery事件
blur         //当失去输入焦点后产生该事件                      $("#myinput").blur(function () {//alert("juqery 事件 blur");});
focus       //当输入获得焦点后，产生该事件                   $("#myinput").focus(function () {//alert("juqery 事件 focus");});
change     //当文字值改变,并失去焦点时，产生该事件       $("#myinput").change(function () {//alert("juqery 事件 change");});
select      //事件会在文本框中的文本被选中时发生。         $("#myinput").select(function () {//alert("juqery 事件 select");});
 
inArray
 
异步提交表单
 serializeArray序列化成json
 serialize序列化成字符串
取所以子元素
children
取父节点
parents() 方法允许我们在 DOM 树中搜索这些元素的祖先元素，并用从最近的父元素向上的顺序排列的匹配元素构造一个新的 jQuery 对象。元素是按照从最近的父元素向外的顺序被返回的。
兄弟节点
jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点
jQuery.prevAll()，返回所有之前的兄弟节点
jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点
jQuery.nextAll()，返回所有之后的兄弟节点
jQuery.siblings(),返回兄弟姐妹节点，不分前后
兄弟节点
追加和插入元素
append、prepend、before、after
append(): 方法在被选元素的结尾插入内容。(被选内容里面)
prepend():方法在被选元素的开头插入内容(被选内容里面)
after():方法在被选元素之后插入内容。(被选内容外面)
before():方法在被选元素之前插入内容。 (被选内容外面)
JS鼠标事件

mousedown：鼠标的键钮被按下。
mouseup：鼠标的键钮被释放弹起。
click：单击鼠标的键钮。
dblclick：鼠标的键钮被按下。
contextmenu ：弹出右键菜单。
mouseover：鼠标移到目标的上方。
mouseout：鼠标移出目标的上方。
mousemove：鼠标在目标的上方移动。

JQuery鼠标事件
(1):click事件：click事件于用户在元素敲击鼠标左键，并在相同元素上松开左键时触发。        $('p').click(function(){                alert('click function is running !');              });    (2):dbclick事件：dbclick事件在用户完成迅速连续的两次点击之后触发，双击的速度取决于操作系统的设置。一般双击事件在页面中不经常使用。        $('p').dbclick(function(){                alert('dbclick function is running !');              });    (3):mousedown事件：mousedown事件在用户敲击鼠标键时触发，跟keydown事件不一样，该事件仅在按下鼠标时触发。        $('p').mousedown(function(){                alert('mousedown function is running !');              });    (4):mouseup事件：mouseup事件在用户松开鼠标时触发，如果在与按下鼠标的元素相同元素上松开，那么click事件也会触发。        $('p').mouseup(function(){                alert('mouseup function is running !');              }).click(function(){                 alert('click function is running too !');                 });    (5):mouseover事件：mouseover事件于用户把鼠标从一个元素移动到另外一个元素上时触发，如果需要知道来自那个元素可以使用，relatedTagrget属性。    (6):mouseout事件：mouseout事件于用户把鼠标移出一个元素时触发，这包括从父元素移动到子元素上，或者使用键盘跳到元素上。   (5)和(6)这两个事件一般不常用，很难实现与用户的交互，也就是说不易捕获用户事件。    (7):mouseenter事件：mouseenter事件是在用户光标进入元素上时触发。         $('p').mouseenter(function(){                alert('mouseenter function is running !');              });    (8):mouseleaver事件：mouseleaver事件是在用户的光标离开元素时触发。           $('p').mouseleaver(function(){                alert('mouseleaver function is running !');             });     (7)和(8)这两个事件一般连起来使用，在jQuery中可以使用hover这个函数来代替这两个函数。       $('p').hover(function(){                       alert('mouseenter function is running !');                      },function(){                              alert('mouseleaver function is running !');                         });
js
当失去焦点时保留两位小数


1    window.onload = function () {
2             document.getElementById("myinput").onblur = function () {
3                 this.value = parseFloat(this.value).toFixed(2);
4             };
5         }

View Code
 文本框只能输入数字,并保留两位小数     [execCommand()的用法]


 1   window.onload = function () {
 2             window.document.getElementById("iptID").onblur = function () {
 3                 if (isNaN(this.value)) {     //如果是非数字
 4                     document.execCommand('undo'); //撤销
 5                     alert('只能输入数字');
 6                 }
 7                 else if (this.value) //如果 不为false undefined null ""
 8                     this.value = parseFloat(this.value).toFixed(2);//保留两位小数
 9             }
10         }

View Code   
控件的隐藏


1 document.getElementById("div").style.visibility = "hidden";//占空间隐藏
2 document.getElementById("div").style.display = "none";//不占空间隐藏

View Code
 
CSS
1.border边框 table常用样式

<!--cellpadding 表格单元边界与单元内容之间的间距像素-->
<!--border 第一个是边框像素 第二个是边框样式 第三个是边框颜色-->
<table cellpadding="0" style="border:1px solid red"></table>
<!--等效于-->
table{  
  border-collapse:collapse;  
  border-spacing:0;  
}  
 

 2.margin外边距  padding 内边距

1  <!--margin边距 margin-top margin-right margin-bottom margin-left-->
2  <!--我们很多时候那个边框挨一起了显得变粗了 我们需要去掉其中一边 或者拉开距离-->
3  <!--去掉下边框-->
4  <table style="margin-bottom:-1px"></table> 
5  <!--边框把下面元素推开一个像素-->
6  <table style="margin-bottom:1px"></table> 

 
3.position 属性


absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
 
fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。

元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
 
relative 生成相对定位的元素，相对于其正常位置进行定位。

因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。
 
static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 
inherit 规定应该从父元素继承 position 属性的值。 

View Code
 4.垂直居中 
我们很多时候需要垂直居中 不得，反法有2. 其一：line-height 相对于容器 设置行之间的距离  其二：margin 相对于 容器内的控件 上下左右 的具体

<div style="background-color: #0094ff; line-height: 55px">
    <input type="button" value="button" />
    <span>我想上下居中</span>
</div>
<br />
<div style="background-color: #0094ff;"> 
    <input style="margin:50px" type="button" value="button" />
    <span>我想上下居中</span>
</div>

 
 clearfix ：

.clearfix:after {
    content: ' ';
    display: table;
    clear: both
}

.clearfix {
    *zoom:1}

 
clientX、offsetX 、screenX ：
clientX 设置或获取鼠标指针位置相对于当前窗口的 x 坐标，其中客户区域不包括窗口自身的控件和滚动条。 clientY 设置或获取鼠标指针位置相对于当前窗口的 y 坐标，其中客户区域不包括窗口自身的控件和滚动条。 offsetX 设置或获取鼠标指针位置相对于触发事件的对象的 x 坐标。 offsetY 设置或获取鼠标指针位置相对于触发事件的对象的 y 坐标。 screenX 设置或获取获取鼠标指针位置相对于用户屏幕的 x 坐标。 screenY 设置或获取鼠标指针位置相对于用户屏幕的 y 坐标。 x 设置或获取鼠标指针位置相对于父文档的 x 像素坐标(亦即相对于当前窗口)。 y 设置或获取鼠标指针位置相对于父文档的 y 像素坐标(亦即相对于当前窗口)。
 
 clientX 和x值在实验过程中，没有发现值不一样的例子，所以我认为它们在效果上是一样的！  offsetX 是相对于当前窗口内，本触发事件对象（或者是某一区域）而言，如本例中你单击a区域，值是相对于a所在<td>区域而言，同理b，c，d都一样！  clientX ，x，offsetX共同点：它们是相对位置，相对于当前窗口，只是offsetX相对于当前窗口的某个触发对象的父容器而言！  screenX是相对与客户端显示器而言，是绝对位置！
html
1.<select>标签

1     <!--multiple 属性规定可同时选择多个选项 selected默认选中-->
2     <select multiple="multiple" size="2">
3         <option value="volvo">Volvo</option>
4         <option value="saab" selected="selected">Saab</option>
5         <option value="opel">Opel</option>
6         <option value="audi">Audi</option>
7     </select>

2.div滚动条.

<div style=" overflow-y:auto; overflow-x:auto; width:400px; height:400px;”></div>

3.a标签

 1  a:link { /* 未访问 */
 2      color: #000;
 3  } 
 4  a:visited { /* 已访问 */
 5      color: #F00;
 6  } 
 7  a:hover { /* 在鼠标下 */
 8      color: #0F0;
 9      text-decoration: none; /*鼠标放上去没有下划线;*/
10  } 
11  a:active { /* 点击过的激活链接 */
12      color: #00F;
13  }

 
CSS鼠标样式语法如下：
任意标签中插入 style="cursor:*"  例子：<span style="cursor:*">文本或其它页面元素</span>  <a href="#" style="cursor:*">文本或其它页面元素</a>  注意把 * 换成如下15个效果的一种：
hand是手型 pointer也是手型，这里推荐使用这种，因为这可以在多种浏览器下使用。 crosshair是十字型 text是移动到文本上的那种效果 wait是等待的那种效果 default是默认效果 help是问号 e-resize是向右的箭头 ne-resize是向右上的箭头 n-resize是向上的箭头 nw-resize是向左上的箭头 w-resize是向左的箭头 sw-resize是左下的箭头 s-resize是向下的箭头 se-resize是向右下的箭头 auto是由系统自动给出效果
 js操作cookies 
1.写cookies  

1 var exp = new Date(); 
2 exp.setTime(exp.getTime() + '天数'*24*60*60*1000); //有效时间
3 document.cookie =  "name=值;expires=" + exp.toGMTString(); 

2.读cookies

1 var name=document.cookie.split(";")[0].split("=")[1]; 

3.删cookies

1 var date = new Date(); 
2 date.setTime(date.getTime() - 10000); 
3 document.cookie =  "name=值; expires=" + date.toGMTString(); 

 
插件
jQuery Autocomplete
article  77
title: MVC学习二：基础语法
body: 
目录
一：重载方法的调用
二：数据的传递
三：生成控件
四：显示加载视图
五：强类型视图
六：@Response.Write() 和 @Html.Raw()区别
七：视图中字符串的输入
八：模板页
 
一：重载方法的调用
同一个控制器内的同名方法调用，可以用HttpGet 和HttpPost区分。

[HttpGet]
public void request(int id = 0)
{
    Response.Write("get 请求成功~");
}

[HttpPost]
public void request(Models.Classes c = null)
{
    Response.Write("post 请求成功~取到值：" + c.CName + " " + c.CImg);
}

 
 
二：数据的传递
控制器向视图传递数据的方法：
1.ViewBag 2.ViewData 3.TempData 4.Model
TempData 不允许添加重复的 key
后台的赋值：

 //1.ViewBag
 ViewBag.bag = "ViewBagbag";
 //2.ViewData
 ViewData.Add("key", "viewdata");
 //3.TempData
 if (!TempData.Keys.Contains("temp"))
     TempData.Add("temp", "tempdata");  //不能重复 添加 相同的 键
 //4.Model
 Models.Classes cl = new Models.Classes() { CName = "model name" };  //数据
 return View(cl);

 
前台的取值：

ViewBag : @ViewBag.bag
<br />
ViewData :  @ViewData["key"]
<br />
TempData  :  @TempData["temp"]
<br />       
强类型视图: @Model.CName
<br />

 
这里要说的是，Model 类型的值  其实等效于  ViewData.Model

//4.Model 
ViewData.Model = new Models.Classes() { CName = "ViewData.Model" };
//等效于
Models.Classes cl = new Models.Classes() { CName = "model name" };  //数据
return View(cl);

 
三：生成控件
前台视图 可以 通过 @Html.DropDownList 绑定后台ViewData数据 生成下拉框控件
后台代码：

ViewData.Add("myselect", new List<SelectListItem>() { 
    new SelectListItem() { Text = "值2", Value = "zhier" },
    new SelectListItem() { Text = "值1", Value = "zhiyi" }
});

 前台视图：

生成下拉框控件:@Html.DropDownList("myselect", "值一")

网页源码：

<select id="myselect" name="myselect"><option value="">值一</option>
<option value="zhier">值2</option>
<option value="zhiyi">值1</option>
</select>

 
四：显示加载视图
视图加载可以分为 默认加载与控制器同名的 视图， 也可以显示加载自己指定的 视图。

public ActionResult setData()
{
    return View(); //加载默认 ActionResult 方法 同名的 视图 setData.cshtml
    //return View("Index");  // 显示加载 Index.cshtml 视图  注意：不要带后缀 .cshtml
}

 
五：强类型视图
在视图页面 定义 model 强类型 ，这样可以方便 编译器 给出 只能提示 ，仅此而已。

@model _1MVC学习.Models.Classes

强类型视图: @Model.CName

 
六：@Response.Write() 和 @Html.Raw()区别
前台：

Html.Raw:
@Html.Raw("Html.Raw")
<br />
Response.Write:  这里输出到最上面了
@{
    Response.Write("Response.Write输出~");
}

 
页面源码：

Response.Write输出~


<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>setData</title>
</head>
<body>
    <div>

        Html.Raw:
        Html.Raw
        <br />
        Response.Write:  这里输出到最上面了

 
七：视图中字符串的输入
在视图页面Razor语法 输入 “纯”字符串 方法：
1. <text>标签 2.@: 

@{
    <text>字符串一</text>
}
<br />
字符串二
<br />
@{
    @:字符串三
}

 
页面源码没有任何标签 包住

     字符串一

        <br />
        字符串二
        <br />
            字符串三

 
 
八：模板页
在添加视图的时候  选择 勾选 使用布局或模板页
使用了模板页的视图：　　

@{
    //标题
    ViewBag.Title = "mby"; 
}

<h2>我使用了模板页</h2>

@*    这里是注释
    @section 可以指定使用哪个“部分”  对应 模板页 的位置 @RenderSection("hhh", required: false)
     required 是否为必须填入
    除了 @section 的其余部分  全部填充到 模板页的  @RenderBody() 位置

*@

@section hhh{   
    我只是一个小坑而已啦~~~
}

 
模板页代码(_Layout.cshtml):

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>@ViewBag.Title</title>

</head>
<body>
    <h1>模板页</h1>
    @RenderBody()

    @RenderSection("hhh", required: false)  
</body>
</html>

 
说明：此类文章仅供本人学习记录使用。如有2B的错误，欢迎指出。不喜勿喷！
article  78
title: 流程控制语句【循环、条件】
body: 
--简单循环

declare                    --声明
  mynum number(3) := 0;    
begin
  loop
    mynum := mynum + 1;
    dbms_output.put_line(mynum);
    exit when mynum = 200; --退出循环条件
  end loop;
end;

 
--while循环

declare
  i number := 1;
begin
  while i <= 100 loop  --执行循环条件       
    dbms_output.put_line(i);
    i := i + 1;
  end loop;
end;

 
--for循环

begin
  for i in 1 .. 10 loop
    dbms_output.put_line(i);
  end loop;
end;

 
--goto循环

declare
   i number := 1;
begin
   loop 
     dbms_output.put_line('i:'||i);
     i := i + 1;
   if i > 100 then
       goto biaoji;
   end if;
   end loop;
   <<biaoji>>
     dbms_output.put_line('i:'||i);
end;

 
--if条件语句

declare
  v_value1 number := 20;
begin
  if v_value1 < 10 then
    dbms_output.put_line('v_value1小于10');
  elsif v_value1 < 20 then  --注意elsif 不是 else if
    dbms_output.put_line('v_value1小于20');
  else
    dbms_output.put_line('v_value1大于或等于20');
  end if;
end;

 
--case when

declare
  v_value1 varchar2(2) := 'A';
  v_value2 varchar2(100);
begin
  v_value2 := case v_value1
                when 'A' then
                 '优秀'
                when 'B' then
                 '一般'
                else
                 '差劲'
              end;
  dbms_output.put_line(v_value2);
end;


declare
  v_value1 varchar2(2) := 'A';
  v_value2 varchar2(100);
begin
  v_value2 := case
                when v_value1 = 'A' then
                 '优秀'
                when v_value1 = 'B' then
                 '一般'
                else
                 '差劲'
              end;
  dbms_output.put_line(v_value2);
end;

以上两种方式都是可以的，这里注意了，case when语句 始终都都返回值（这点和if条件语句不一样）。
也可以用于查询结果和查询条件

select case t.c_type
         when 'B' then
          '一般'
         when 'A' then
          '优秀'
         else
          '差劲'
       end,
       case
         when t.c_case_no = '4090003002115000012' then
          '4090003002015000012'
       end
  from tbl_claim t
 where t.c_case_no = case
         when t.c_case_no = '4090003002015000012' then
          '4090003002015000012'
       end;

 
--decode

decode(条件,值1,翻译值1,值2,翻译值2,...值n,翻译值n,缺省值)


select decode('A', 'B', '一般', 'A', '优秀', '差劲') from dual;

可用于查询结果和查询条件。（但是不能像case when一样赋值）

select decode(t.type, 'B', '一般', '差劲')
  from mytable t
 where t.c_no = decode(t.c_no, '111', '111', '222');

 
article  79
title: 前台和后台的相互传值
body: 
目录
一、把json对象转成字符串
二、创建数据容器对象 [用来绑定要传给后台的前台控件值]
三、创建绑定前台数据对象 [用来读取后台传过来的值，并绑定到前台页面]
四、使用示例
 
前后台的相互传值如果值太多，写的麻烦累人，且容易出错。这里整理出一套使用标记 标签属性的办法来传值， 后台取值和前台的绑定都有了大大的简化。
一、把json对象转成字符串

 1    $.extend({
 2             //将json对象转换成字符串   [貌似jquery没有自带的这种方法]
 3             toJSONString: function (object) {
 4                 if (object == null)
 5                     return;
 6                 var type = typeof object;
 7                 if ('object' == type) {
 8                     if (Array == object.constructor) type = 'array';
 9                     else if (RegExp == object.constructor) type = 'regexp';
10                     else type = 'object';
11                 }
12                 switch (type) {
13                     case 'undefined':
14                     case 'unknown':
15                         return;
16                         break;
17                     case 'function':
18                     case 'boolean':
19                     case 'regexp':
20                         return object.toString();
21                         break;
22                     case 'number':
23                         return isFinite(object) ? object.toString() : 'null';
24                         break;
25                     case 'string':
26                         return '"' + object.replace(/(\\|\")/g, "\\$1").replace(/\n|\r|\t/g, function () {
27                             var a = arguments[0];
28                             return (a == '\n') ? '\\n' : (a == '\r') ? '\\r' : (a == '\t') ? '\\t' : ""
29                         }) + '"';
30                         break;
31                     case 'object':
32                         if (object === null) return 'null';
33                         var results = [];
34                         for (var property in object) {
35                             var value = $.toJSONString(object[property]);
36                             if (value !== undefined) results.push($.toJSONString(property) + ':' + value);
37                         }
38                         return '{' + results.join(',') + '}';
39                         break;
40                     case 'array':
41                         var results = [];
42                         for (var i = 0; i < object.length; i++) {
43                             var value = $.toJSONString(object[i]);
44                             if (value !== undefined) results.push(value);
45                         }
46                         return '[' + results.join(',') + ']';
47                         break;
48                 }
49             }
50         });

 
二、创建数据容器对象 [用来绑定要传给后台的前台控件值]

 1 var DataClass = {
 2     create: function () {
 3                 return function () {
 4                     this.MyInit.apply(this, arguments);//创建对象的构造函数  //arguments 参数集合  系统名称 不能写错
 5                 }
 6             }
 7 }
 8 var MyDataPack = DataClass.create();
 9 MyDataPack.prototype = {
10     //初始化
11     MyInit: function (url, operation, params) {
12 
13                 this.data = new Object();   //所有数据容量
14 
15                 var bdata = new Object();
16                 bdata.url = url;            //地址
17                 bdata.operation = operation;//操作
18                 bdata.params = params;      //参数
19 
20                 this.data.BasicData = bdata; //基本数据
21             },
22     //添加数据 如：addValue("obj", "111");
23     addValue: function (p, obj) {
24         this.data[p] = obj;
25     },
26     //取得 所有标记控件的值 并写入数据
27     getValueSetData: function (togName) {
28                 var values = Object(); //值的集合
29                 $("[subtag='" + togName + "']").each(function () {
30                     //如果是input 类型 控件
31                     if (this.localName == "input") {
32                         //如果是text 控件
33                         if (this.type == "text" || this.type == "hidden") {
34                             values[this.id] = this.value;
35                         }
36                         else if (this.type == "...") {
37 
38                         }
39                         //......
40                     }
41                     else if (this.localName == "...") {
42 
43                     }
44                     //................
45                 });
46                 this.data[togName] = values;//添加到数据集合
47             },
48     //取值 如：getValue("BasicData")
49     getValue: function (p) {
50                 return this.data[p];
51             },
52     //获取或设置url
53     getUrl: function (url) {
54                 if (url)
55                     this.data.BasicData["url"] = url;
56                 else
57                     return this.data.BasicData["url"];
58             }
59     ,
60     //取值 转成字符串的对象 数据
61     getJsonData: function () {
62         return $.toJSONString(this.data);
63     }
64 }

 
三、创建绑定前台数据对象 [用来读取后台传过来的值，并绑定到前台页面]

var MyDataBinder = {
    //绑定数据到 控件 data：数据 tag：标签
    Bind: function (data, Tag) {
        var MJson = $.parseJSON(data);
        //只绑定 标记 了的 标签
        $("[bindtag='" + Tag + "']").each(function () {
            if (this.localName == "input") {
                if (MJson[this.id]) //如果后台传了值
                    $(this).attr("value", MJson[this.id]);
            }
            else if (this.localName == "...") {
            }
            //....
        });
    }
};

 
四、使用示例
前台html：

 1 <table>
 2     <tr>
 3         <th>一</th>
 4         <th>二</th>
 5         <th>三</th>
 6     </tr>
 7     <tr>
 8         <td id="td1"><input type="text" id="inp_1" subtag="subtag" bindtag="bind" /></td>
 9         <td id="td2"><input type="text" id="inp_2" subtag="subtag" value="我只是测试一下下" /></td>
10         <td><input type="text" id="inp_3" subtag="subtag" bindtag="bind" /></td>
11     </tr>       
12 </table>

 
前台js：

1 //====================使用示例======================================
2 var MyDataPack = new MyDataPack("Handler1.ashx", "CESHI", "");
3 MyDataPack.getValueSetData("subtag");//将控件数据写入对象   “subtag”为要取 控件 值 的标签
4 //-------------------传前台值到后台---------------
5 $.post(MyDataPack.getUrl(), MyDataPack.getJsonData(), function (data) {
6     //-------------------绑定后台值到前台-----------------
7     MyDataBinder.Bind(data, "bind");  //"bind" 为 要绑定控件的 标签
8 });

 
后台：

 1         public void ProcessRequest(HttpContext context)
 2         {
 3             context.Response.ContentType = "text/plain";
 4             //====================取前台值=============================================
 5             //因为后台传过来的是 json对象 转换后的字符串  所以 所有数据都 做为一个参数传过来了
 6             var values = context.Request.Form[0];
 7             //需要引入程序集System.Web.Extensions.dll
 8             JavaScriptSerializer _jsSerializer = new JavaScriptSerializer();
 9             //将 json 对象字符串  转成 Dictionary 对象
10             Dictionary<string, Dictionary<string, string>> dic = _jsSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(values);
11 
12             //现在 dic 里面就包含了 所有前台传过来的值 想怎么用 就怎么用了。
13             string inp_2 = dic["subtag"]["inp_2"];//这样就直接取到了前台 页面 id为 inp_2 的 控件value 值
14 
15 
16 
17             //=====================传值到前台============================================
18             Dictionary<string, string> dic2 = new Dictionary<string, string>();
19             dic2.Add("inp_1", "修改1");//这里只用对应控件id 传值即可
20             dic2.Add("inp_2", "修改2");
21             dic2.Add("inp_3", "修改3");
22             context.Response.Write(_jsSerializer.Serialize(dic2));
23         }

 
article  80
title: 游标
body: 
--显式游标

declare
  cursor c_c is select * from scott.emp;--定义游标
  r_r scott.emp%rowtype;                --定义变量[rowtype为行类型]
begin
  open c_c;                        --打开游标
  loop                             --简单循环
    fetch c_c into r_r;            --将数据放入变量[执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。]
    dbms_output.put_line(r_r.job); --输出行变量中字段数据
    exit when c_c%notfound;        --如果没有下一条数据[退出条件 found有下条数据 notfound没有下条数据]
  end loop;
  close c_c;                       --关闭游标
end;

--带有参数的游标

declare
  cursor c_c(mid number default 7521) is select * from scott.emp where empno=mid;--定义游标
  r_r scott.emp%rowtype;                --定义变量[rowtype为行类型]
begin
  open c_c(7788);                       --打开游标
  loop                                  --简单循环
    fetch c_c into r_r; 
    dbms_output.put_line(r_r.job||' '||r_r.empno); --输出行变量中字段数据
    exit when c_c%notfound;             --如果没有下一条数据[退出条件 found有下条数据 notfound没有下条数据]
  end loop;
  close c_c;                            --关闭游标
end;

 --隐式游标

declare
  cursor c_c is
    select * from scott.emp;
  r_r scott.emp %rowtype;
begin
  for v_r in c_c loop                --自动打开游标，自动检测NOTFOUND
    dbms_output.put_line(v_r.job);
  end loop;
  --隐含关闭游标
end;

--游标变量

declare
  type m_c_type is ref cursor; --定义游标类型 m_c_type
  c_c m_c_type;                --声明游标变量
  r_r scott.emp%rowtype;
begin
  open c_c for                 --打开游标变量
    select * from scott.emp;
  loop
    fetch c_c
      into r_r;
    dbms_output.put_line(r_r.job);
    exit when c_c%notfound;
  end loop;
end;

--动态定义游标 

declare
  msql    varchar2(111) := 'select * from emp';
  tbl_emp emp%rowtype;
  type cur_type is ref CURSOR;
  cur cur_type;
begin
  OPEN cur for msql; --打开动态定义的游标
  LOOP
    FETCH cur
      into tbl_emp; --循环赋值
    EXIT WHEN cur%NOTFOUND; --跳出条件
    dbms_output.put_line(tbl_emp.empno || '  ' || tbl_emp.ename); --打印
  END LOOP; 
end;

 
article  81
title: js问题杂记
body: 
   问题一：
   由于jquery可以动态异步添加页面元素，很多时候我们都不知道一个页面元素什么时候加载完成。常规的jquery的ready和js的document.onload执行是也许我们需要操作的元素还没生成完成。所以我们只能用定时器不断的循环，判断如果元素生成了。则执行我们想要的操作。

 1 //页面加载完成是执行
 2         $(function () {
 3             customTimer();
 4         });
 5         //自定义 定时器(假设div_digg是动态生成)
 6         function customTimer() {
 7             if ($("#div_digg").length) {
 8                 //$("#div_digg").    这里就可以执行想要的操作
 9             }
10             else {
11                 var intervalId = setInterval(function () {
12                     if ($("#div_digg").length) {    //循环判断是否存在
13                         clearInterval(intervalId);  // 则关闭定时器
14                         customTimer();              //执行自身
15                     }
16                 }, 100);
17             }
18         }

 
问题二：IE中console未被定义 错误。

1 window.console = window.console || (function () {
2     var c = {};
3     c.log = c.warn = c.debug = c.info
4           = c.error = c.time = c.dir = c.profile
5           = c.clear = c.exception = c.trace = c.assert =
6              function () { };
7     return c;
8 })();

 
问题三：使用JS或jQuery模拟鼠标点击a标签事件
方法1:

<a id="alink" href="abc.aspx"  style="visibility: hidden;">下一步</a>

$("#alink").click();  // 触发了a标签的点击事件，但是没有触发页面跳转
document.getElementById("alink").click(); //既触发了a标签的点击事件，又触发了页面跳转

 方法2：
把 “下一步” 改为 “<span id="spanId">下一步</span>” 即给A标签中的文字添加一个能被jQuery捕获的元素，然后$("#spanId").click()；，才可以触发页面跳转。

<a id="alink" href="abc.aspx"  style="visibility: hidden;"><span id="spanId">下一步</span></a>

$("#spanId").click();

 
article  82
title: 常用网站
body: 
目录
一、常用网站
二、开发文档
三、站内搜索
 
一、常用网站
http://www.cnblogs.com/         博客园
http://www.csdn.net/              csdn
http://www.51cto.com/           51cto
http://www.jb51.net/              脚本之家
http://www.oschina.net/         开源中国社区
https://git.oschina.net            开源中国源码管理 Windows 下使用git 将代码托管到开源中国
http://www.mycodes.net/        源码之家
http://www.iteye.com/             iteye
http://www.w3school.com.cn/   离线下载
http://www.xiazaiba.com/        下载吧（雨林木风旗下）
https://github.com/                 开源代码库 window下环节配置 VS下配置 GitHub详解
 
博客园博客相关APIhttp://wcf.open.cnblogs.com/blog/help博客园新闻相关APIhttp://wcf.open.cnblogs.com/news/help
二、开发文档
chrome插件开发文档
chrome插件中文开发文档(非官方)
chrome插件开发文档360版   离线版 密码:xmef
【Hemin】jQuery API 中文手册
《Swift语言》中文版Swift 2.0
三、站内搜索
站内搜索 谷歌被墙 百度不能搜二级域名网   所以 还是选择必应比较好
必应搜索
http://cn.bing.com/search?q=关键字+site:网站地址  
如：http://cn.bing.com/search?q=常用+site:cnblogs.com/zhaopei
百度搜索
如：http://www.baidu.com/s?wd=常用+site:cnblogs.com
 
article  83
title: 备忘
body: 
html中的空格  &nbsp;
 
正则              
 [xyz] 字符集合。匹配所包含的任意一个字符。  [^xyz]  负值字符集合。匹配未包含的任意字符
 
时间格式转换
oracle:

select  TO_CHAR(SYSDATE, 'yyyy/mm/dd hh24:mi:ss') from dual;

C#:

string time = DateTime.Now.ToString("yyyy/MM/dd hh:mm:ss");

 秒转到时分秒 (int)是关键

 TimeSpan ts = new TimeSpan(0, 0, int.Parse(m));
 return (int)ts.TotalHours + ":" + ts.Minutes + ":" + ts.Seconds;

 
目录 路径
以/开头代表根目录。
~/开头代表网站根目录。
../表示上一级目录。
../../上上一级目录。
./表示当前目录。
 
 
1、取得控制台应用程序的根目录方法     方法1、Environment.CurrentDirectory 取得或设置当前工作目录的完整限定路径     方法2、AppDomain.CurrentDomain.BaseDirectory 获取基目录，它由程序集冲突解决程序用来探测程序集 2、取得Web应用程序的根目录方法     方法1、HttpRuntime.AppDomainAppPath.ToString();//获取承载在当前应用程序域中的应用程序的应用程序目录的物理驱动器路径。用于App_Data中获取     方法2、Server.MapPath("") 或者 Server.MapPath("~/");//返回与Web服务器上的指定的虚拟路径相对的物理文件路径     方法3、Request.ApplicationPath;//获取服务器上ASP.NET应用程序的虚拟应用程序根目录 3、取得WinForm应用程序的根目录方法     1、Environment.CurrentDirectory.ToString();//获取或设置当前工作目录的完全限定路径     2、Application.StartupPath.ToString();//获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称     3、Directory.GetCurrentDirectory();//获取应用程序的当前工作目录     4、AppDomain.CurrentDomain.BaseDirectory;//获取基目录，它由程序集冲突解决程序用来探测程序集     5、AppDomain.CurrentDomain.SetupInformation.ApplicationBase;//获取或设置包含该应用程序的目录的名称其中：以下两个方法可以获取执行文件名称     1、Process.GetCurrentProcess().MainModule.FileName;//可获得当前执行的exe的文件名。     2、Application.ExecutablePath;//获取启动了应用程序的可执行文件的路径，包括可执行文件的名称
     3、System.IO.Path类中有一些获取路径的方法，可以在控制台程序或者WinForm中根据相对路径来获取绝对路径
 
一些嵌入数据库：Firebird Access SQLite 
 
一些winfrom内嵌浏览器 
WebKit .NETwebkit-sharpCefSharpawesomiumOpenWebKitSharp geckofxMozNET Web Component
ChromeWebBrowser.Net
 
.NET下各种可用的HTML解析组件

CsQuery
AngleSharp
Jumony                 //在NugGet 中 搜索 Jumony Core



var jumony = new JumonyParser();
var htmlSource = jumony.LoadDocument(url).InnerHtml();

 

HtmlAgilityPack
Fizzler
ScrapySharp
NSoup

地区数据：http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2013/43/06/23/430623111.html
 
图片服务：1.http://developer.qiniu.com/ 2. 贴图库
 
使用MVC4 WebAPI 安装 helpPage
ASP.Net MVC 4项目升级MVC 5的方法
api缓存：CacheCow与OutputCache，
article  84
title: 常用SQL[ORACLE]
body: 
  
1.常用系统函数
2.常用sql语句
3.一些定义和关键字
4.需要注意点
 
1.常用系统函数 ↑
--decode

decode(column,if_value,value,elseif_value,value,default_value);

decode(条件,值1,翻译值1,值2,翻译值2,...值n,翻译值n,缺省值)

好比一张表：

select decode(score,'A','优秀','B','良好','C','及格','不及格') from t_table

--sum

求和函数

--wm_concat

该函数可以把列值以","号分隔起来,并显示成一行


 2.常用sql语句 ↑
--新建用户

create user zhaopei identified by zhaopei;

 
--给用户权限

grant dba to zhaopei ;

 
--删除表字段

alter table Tbl_Survey_Human_New DROP COLUMN 字段名;
alter table Tbl_Survey_Human_New DROP COLUMN n_oa_report_FLAG;

--新增表字段

alter table Tbl_Survey_Human_New add(字段名 字段类型);
alter table Tbl_Survey_Human_New add(n_protocaryon_report_FLAG varchar2(2));

--修改表字段

alter table Tbl_Survey_Human_New modify(字段名 字段类型);
alter table Tbl_Survey_Human_New modify(c_caseisreal_type varchar2(30));

--添加字段备注

comment on column 表名.字段名  is '注释';
comment on column Tbl_Report_Caseseat.BLOCKED  is '派查勘员受阻';

 
--创建序列


create sequence mysq
minvalue 1                   --最小值 
maxvalue 99999999999999999   --最大值
start with 1                 --开始值
increment by 1               --每次增长值
cache 20;                    --缓存大小

View Code
--Union 并集操作 .

对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；

--Union All 并集操作

对两个结果集进行并集操作，包括重复行，不进行排序；

-- CASE WHEN 表达式

--简单Case函数  

CASE sex  
WHEN '1' THEN '男'  
WHEN '2' THEN '女'  
ELSE '其他' END  

--Case搜索函数  

CASE
WHEN sex = '1' THEN '男'  
WHEN sex = '2' THEN '女'  
ELSE '其他' END 

 
 
--查询相同条件的其中一条数据

select * from tb k_id in (select min(k_id) from tb group by d_id)

 --动态SQL.


--动态sql   execute immediate
begin
  execute immediate 'select * from scott.emp';
  execute immediate 'create table emp1121(id number,name varchar2(10),salary number )';
end;

View Code
--异常处理1


 1 declare
 2   num1 number := 1;
 3   num2 number := 0;
 4   my_exce exception;   --定义错误类型
 5 begin
 6   if num2 = 0 then
 7     raise my_exce;     --自定义错误
 8   end if;
 9   num1 := num1 / num2;
10 exception
11   when my_exce then    --自定义错误处理
12     dbms_output.put_line(sqlcode || '===' || sqlerrm);
13     dbms_output.put_line('自定义 错误');
14   when others then
15     dbms_output.put_line(sqlcode || '===' || sqlerrm);
16     dbms_output.put_line('除零错误');
17 end;

View Code
--异常处理2


 1 declare
 2   num1 number := 1;
 3   num2 number := 0;
 4 begin
 5   if num2 = 0 then
 6     raise_application_error(-20991, '部门代码为空'); --自定义异常错误消息
 7     --RAISE_APPLICATION_ERROR(error_number,error_message,[keep_errors] );--keep_errors 为可选
 8     --error_number 是从 –20,000 到 –20,999 之间的参数
 9     --error_message 是相应的提示信息(< 2048 字节)
10   end if;
11   num1 := num1 / num2;
12 exception
13   when others then
14     dbms_output.put_line(sqlcode || '===' || sqlerrm);
15     dbms_output.put_line('除零错误');
16 end;

View Code

 3.一些定义和关键字 ↑
--DDL和DML

DDL：如drop，alter，truncate。
DML：如insert，update，delete，merge。

 
--DECLARE 

declare 声明变量

 --DEFAULT

default 默认值

 
--数组类型.


 1 DECLARE
 2 --定义一个最多保存5个VARCHAR(25)数据类型成员的VARRAY数据类型
 3    TYPE REG_VARRAY_TYPE IS VARRAY(5) OF VARCHAR(25);
 4 --声明一个该VARRAY数据类型的变量
 5    V_REG_VARRAY REG_VARRAY_TYPE;
 6 
 7 BEGIN
 8 --用构造函数语法赋予初值
 9    v_reg_varray := reg_varray_type
10          ('中国', '美国', '英国', '日本', '法国');
11 
12    DBMS_OUTPUT.PUT_LINE('地区名称：'||v_reg_varray(1)||'、'
13                                     ||v_reg_varray(2)||'、'
14                                     ||v_reg_varray(3)||'、'
15                                     ||v_reg_varray(4));
16    DBMS_OUTPUT.PUT_LINE('赋予初值NULL的第5个成员的值：'||v_reg_varray(5)||' count:'||v_reg_varray.count);--count可查数组的长度
17 --用构造函数语法赋予初值后就可以这样对成员赋值
18    v_reg_varray(5) := '国';
19    DBMS_OUTPUT.PUT_LINE('第5个成员的值：'||v_reg_varray(5));
20 END;

View Code
 
--记录类型


 1 declare
 2   type test_type is record(
 3     name varchar2(10) not null := 'zhangsan',
 4     id   varchar2(10));
 5   test_v test_type;
 6 begin
 7   test_v.name := '李四';
 8   test_v.id   := '111';
 9   dbms_output.put_line(test_v.name || '  ' || test_v.id);
10 end;

View Code

 4.需要注意的 ↑
存储过程中is和as的区别

在存储过程（PROCEDURE）和函数(FUNCTION)中没有区别，在视图（VIEW）中只能用AS不能用IS，在游标(CURSOR)中只能用IS不能用AS。

赋值

str1 := 'str'; --数据库中的赋值 是 :=

比较

str1=str2 --数据库中的比较符 是单等号

 LENGTH,LENGTHB,LENGTHC,LENGTH2,LENGTH4的区别


LENGTH(string1) 返回以字符为单位的长度.
LENGTHB(string1) 返回以字节为单位的长度.
LENGTHC(string1) 返回以Unicode完全字符为单位的长度.
LENGTH2(string1) 返回以UCS2代码点为单位的长度.
LENGTH4(string1) 返回以UCS4代码点为单位的长度.

View Code
oracle中 substrb() substrc() substr2() substr4()的区别


substr 按字符截取，单位字符
substrb 按字节，单位字节
substrc unicode字符为单位
substr2 ucs2代码点为单位
substr4 ucs4代码点为单位

substr是按字符来计算，一个字母或汉字都按一个字符计算如：
substr('智能ABC',2,2)='能A'
如果想要按字节来计算则可以采用substrb函数，用法一样
substrb('智能ABC',3,4)='能AB'
 
当然还有另外几个按不同编码计算的函数
substrc:按Unicode编码,
substr2:按UCS2编码,
substr4:按UCS4编码。

View Code
 
